var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"SimpleFOC","ref":false,"files":[{"name":"SimpleFOC.c","type":"source","group":"model","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * SimpleFOC.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"SimpleFOC.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"SimpleFOC_private.h\"\r\n#include <math.h>\r\n#include \"rt_nonfinite.h\"\r\n#include <float.h>\r\n#include <string.h>\r\n\r\n/* Block signals (default storage) */\r\nB_SimpleFOC_T SimpleFOC_B;\r\n\r\n/* Continuous states */\r\nX_SimpleFOC_T SimpleFOC_X;\r\n\r\n/* Block states (default storage) */\r\nDW_SimpleFOC_T SimpleFOC_DW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_SimpleFOC_T SimpleFOC_M_;\r\nRT_MODEL_SimpleFOC_T *const SimpleFOC_M = &SimpleFOC_M_;\r\n\r\n/*\r\n * This function updates continuous states using the ODE3 fixed-step\r\n * solver algorithm\r\n */\r\nstatic void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\r\n{\r\n  /* Solver Matrices */\r\n  static const real_T rt_ODE3_A[3] = {\r\n    1.0/2.0, 3.0/4.0, 1.0\r\n  };\r\n\r\n  static const real_T rt_ODE3_B[3][3] = {\r\n    { 1.0/2.0, 0.0, 0.0 },\r\n\r\n    { 0.0, 3.0/4.0, 0.0 },\r\n\r\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\r\n  };\r\n\r\n  time_T t = rtsiGetT(si);\r\n  time_T tnew = rtsiGetSolverStopTime(si);\r\n  time_T h = rtsiGetStepSize(si);\r\n  real_T *x = rtsiGetContStates(si);\r\n  ODE3_IntgData *id = (ODE3_IntgData *)rtsiGetSolverData(si);\r\n  real_T *y = id->y;\r\n  real_T *f0 = id->f[0];\r\n  real_T *f1 = id->f[1];\r\n  real_T *f2 = id->f[2];\r\n  real_T hB[3];\r\n  int_T i;\r\n  int_T nXc = 6;\r\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\r\n\r\n  /* Save the state values at time t in y, we'll use x as ynew. */\r\n  (void) memcpy(y, x,\r\n                (uint_T)nXc*sizeof(real_T));\r\n\r\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\r\n  /* f0 = f(t,y) */\r\n  rtsiSetdX(si, f0);\r\n  SimpleFOC_derivatives();\r\n\r\n  /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\r\n  hB[0] = h * rt_ODE3_B[0][0];\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0]);\r\n  }\r\n\r\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\r\n  rtsiSetdX(si, f1);\r\n  SimpleFOC_step();\r\n  SimpleFOC_derivatives();\r\n\r\n  /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\r\n  for (i = 0; i <= 1; i++) {\r\n    hB[i] = h * rt_ODE3_B[1][i];\r\n  }\r\n\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\r\n  }\r\n\r\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\r\n  rtsiSetdX(si, f2);\r\n  SimpleFOC_step();\r\n  SimpleFOC_derivatives();\r\n\r\n  /* tnew = t + hA(3);\r\n     ynew = y + f*hB(:,3); */\r\n  for (i = 0; i <= 2; i++) {\r\n    hB[i] = h * rt_ODE3_B[2][i];\r\n  }\r\n\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\r\n  }\r\n\r\n  rtsiSetT(si, tnew);\r\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\r\n}\r\n\r\nreal_T rt_modd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  y = u0;\r\n  if (u1 == 0.0) {\r\n    if (u0 == 0.0) {\r\n      y = u1;\r\n    }\r\n  } else if (rtIsNaN(u0) || rtIsNaN(u1) || rtIsInf(u0)) {\r\n    y = (rtNaN);\r\n  } else if (u0 == 0.0) {\r\n    y = 0.0 / u1;\r\n  } else if (rtIsInf(u1)) {\r\n    if ((u1 < 0.0) != (u0 < 0.0)) {\r\n      y = u1;\r\n    }\r\n  } else {\r\n    boolean_T yEq;\r\n    y = fmod(u0, u1);\r\n    yEq = (y == 0.0);\r\n    if ((!yEq) && (u1 > floor(u1))) {\r\n      real_T q;\r\n      q = fabs(u0 / u1);\r\n      yEq = !(fabs(q - floor(q + 0.5)) > DBL_EPSILON * q);\r\n    }\r\n\r\n    if (yEq) {\r\n      y = u1 * 0.0;\r\n    } else if ((u0 < 0.0) != (u1 < 0.0)) {\r\n      y += u1;\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Model step function */\r\nvoid SimpleFOC_step(void)\r\n{\r\n  real_T Bias;\r\n  real_T cosOut;\r\n  real_T cosOut_tmp;\r\n  real_T tmp;\r\n  real_T tmp_0;\r\n  real_T tmp_1;\r\n  real_T tmp_2;\r\n  real_T tmp_3;\r\n  real_T tmp_4;\r\n  real_T *tmp_5;\r\n  int32_T i;\r\n  real32_T u0;\r\n  uint32_T Sum_l;\r\n  int8_T rtAction;\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* set solver stop time */\r\n    if (!(SimpleFOC_M->Timing.clockTick0+1)) {\r\n      rtsiSetSolverStopTime(&SimpleFOC_M->solverInfo,\r\n                            ((SimpleFOC_M->Timing.clockTickH0 + 1) *\r\n        SimpleFOC_M->Timing.stepSize0 * 4294967296.0));\r\n    } else {\r\n      rtsiSetSolverStopTime(&SimpleFOC_M->solverInfo,\r\n                            ((SimpleFOC_M->Timing.clockTick0 + 1) *\r\n        SimpleFOC_M->Timing.stepSize0 + SimpleFOC_M->Timing.clockTickH0 *\r\n        SimpleFOC_M->Timing.stepSize0 * 4294967296.0));\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  /* Update absolute time of base rate at minor time step */\r\n  if (rtmIsMinorTimeStep(SimpleFOC_M)) {\r\n    SimpleFOC_M->Timing.t[0] = rtsiGetT(&SimpleFOC_M->solverInfo);\r\n  }\r\n\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* Constant: '<S8>/Pos0' */\r\n    SimpleFOC_B.Pos0 = SimpleFOC_P.Initial.bldc.ITheta;\r\n  }\r\n\r\n  /* Integrator: '<S15>/Integrator' */\r\n  if (SimpleFOC_DW.Integrator_IWORK != 0) {\r\n    SimpleFOC_X.Integrator_CSTATE = SimpleFOC_B.Pos0;\r\n  }\r\n\r\n  /* Integrator: '<S15>/Integrator' */\r\n  SimpleFOC_B.Integrator = SimpleFOC_X.Integrator_CSTATE;\r\n\r\n  /* Gain: '<S7>/pole-pair1' */\r\n  SimpleFOC_B.polepair1 = SimpleFOC_P.BLDC_p * SimpleFOC_B.Integrator;\r\n\r\n  /* Math: '<S7>/Mod' incorporates:\r\n   *  Constant: '<S7>/Constant'\r\n   */\r\n  SimpleFOC_B.Mod = rt_modd_snf(SimpleFOC_B.polepair1,\r\n    SimpleFOC_P.Constant_Value_k);\r\n\r\n  /* Trigonometry: '<S5>/SinCos' incorporates:\r\n   *  Trigonometry: '<S6>/SinCos'\r\n   */\r\n  cosOut = SimpleFOC_B.Mod;\r\n  Bias = sin(cosOut);\r\n  cosOut_tmp = cos(cosOut);\r\n  cosOut = cosOut_tmp;\r\n\r\n  /* Trigonometry: '<S5>/SinCos' */\r\n  SimpleFOC_B.SinCos_o1 = Bias;\r\n\r\n  /* Trigonometry: '<S5>/SinCos' */\r\n  SimpleFOC_B.SinCos_o2 = cosOut;\r\n\r\n  /* SignalConversion generated from: '<S5>/MatrixMultiply' */\r\n  SimpleFOC_B.TmpSignalConversionAtMatrixMult[0] = SimpleFOC_B.SinCos_o1;\r\n  SimpleFOC_B.TmpSignalConversionAtMatrixMult[1] = SimpleFOC_B.SinCos_o2;\r\n\r\n  /* Product: '<S5>/MatrixMultiply' incorporates:\r\n   *  Constant: '<S5>/Minus120'\r\n   */\r\n  cosOut = SimpleFOC_P.Minus120_Value[0];\r\n  tmp_3 = SimpleFOC_P.Minus120_Value[1];\r\n  tmp_1 = SimpleFOC_P.Minus120_Value[2];\r\n  tmp_4 = SimpleFOC_P.Minus120_Value[3];\r\n  tmp_0 = SimpleFOC_B.TmpSignalConversionAtMatrixMult[0];\r\n  tmp_2 = SimpleFOC_B.TmpSignalConversionAtMatrixMult[1];\r\n  tmp = cosOut * tmp_0;\r\n  tmp += tmp_1 * tmp_2;\r\n\r\n  /* Product: '<S5>/MatrixMultiply' */\r\n  SimpleFOC_B.MatrixMultiply[0] = tmp;\r\n\r\n  /* Product: '<S5>/MatrixMultiply' */\r\n  tmp = tmp_3 * tmp_0;\r\n  tmp += tmp_4 * tmp_2;\r\n\r\n  /* Product: '<S5>/MatrixMultiply' */\r\n  SimpleFOC_B.MatrixMultiply[1] = tmp;\r\n\r\n  /* Product: '<S5>/MatrixMultiply1' incorporates:\r\n   *  Constant: '<S5>/Plus120'\r\n   */\r\n  cosOut = SimpleFOC_P.Plus120_Value[0];\r\n  tmp_3 = SimpleFOC_P.Plus120_Value[1];\r\n  tmp_1 = SimpleFOC_P.Plus120_Value[2];\r\n  tmp_4 = SimpleFOC_P.Plus120_Value[3];\r\n  tmp_0 = SimpleFOC_B.TmpSignalConversionAtMatrixMult[0];\r\n  tmp_2 = SimpleFOC_B.TmpSignalConversionAtMatrixMult[1];\r\n  tmp = cosOut * tmp_0;\r\n  tmp += tmp_1 * tmp_2;\r\n\r\n  /* Product: '<S5>/MatrixMultiply1' */\r\n  SimpleFOC_B.MatrixMultiply1[0] = tmp;\r\n\r\n  /* Product: '<S5>/MatrixMultiply1' */\r\n  tmp = tmp_3 * tmp_0;\r\n  tmp += tmp_4 * tmp_2;\r\n\r\n  /* Product: '<S5>/MatrixMultiply1' */\r\n  SimpleFOC_B.MatrixMultiply1[1] = tmp;\r\n\r\n  /* SignalConversion generated from: '<S5>/Matrix Concatenate1' incorporates:\r\n   *  Concatenate: '<S5>/Matrix Concatenate1'\r\n   */\r\n  SimpleFOC_B.MatrixConcatenate1[0] = SimpleFOC_B.SinCos_o2;\r\n  SimpleFOC_B.MatrixConcatenate1[1] = SimpleFOC_B.MatrixMultiply[1];\r\n  SimpleFOC_B.MatrixConcatenate1[2] = SimpleFOC_B.MatrixMultiply1[1];\r\n\r\n  /* Gain: '<S5>/Gain2' incorporates:\r\n   *  Concatenate: '<S5>/Matrix Concatenate1'\r\n   */\r\n  SimpleFOC_B.MatrixConcatenate1[3] = SimpleFOC_P.Gain2_Gain_n *\r\n    SimpleFOC_B.SinCos_o1;\r\n  SimpleFOC_B.MatrixConcatenate1[4] = SimpleFOC_P.Gain2_Gain_n *\r\n    SimpleFOC_B.MatrixMultiply[0];\r\n  SimpleFOC_B.MatrixConcatenate1[5] = SimpleFOC_P.Gain2_Gain_n *\r\n    SimpleFOC_B.MatrixMultiply1[0];\r\n\r\n  /* SignalConversion generated from: '<S5>/Matrix Concatenate1' incorporates:\r\n   *  Concatenate: '<S5>/Matrix Concatenate1'\r\n   *  Constant: '<S5>/Constant2'\r\n   */\r\n  SimpleFOC_B.MatrixConcatenate1[6] = SimpleFOC_P.Constant2_Value;\r\n  SimpleFOC_B.MatrixConcatenate1[7] = SimpleFOC_P.Constant2_Value;\r\n  SimpleFOC_B.MatrixConcatenate1[8] = SimpleFOC_P.Constant2_Value;\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* Constant: '<S16>/Id_0' */\r\n    SimpleFOC_B.Id_0 = SimpleFOC_P.Initial.bldc.ILd;\r\n  }\r\n\r\n  /* Integrator: '<S19>/Integrator' */\r\n  if (SimpleFOC_DW.Integrator_IWORK_n != 0) {\r\n    SimpleFOC_X.Integrator_CSTATE_l = SimpleFOC_B.Id_0;\r\n  }\r\n\r\n  /* Integrator: '<S19>/Integrator' */\r\n  SimpleFOC_B.Integrator_d = SimpleFOC_X.Integrator_CSTATE_l;\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* Constant: '<S17>/Id_0' */\r\n    SimpleFOC_B.Id_0_e = SimpleFOC_P.Initial.bldc.ILq;\r\n  }\r\n\r\n  /* Integrator: '<S21>/Integrator' */\r\n  if (SimpleFOC_DW.Integrator_IWORK_o != 0) {\r\n    SimpleFOC_X.Integrator_CSTATE_g = SimpleFOC_B.Id_0_e;\r\n  }\r\n\r\n  /* Integrator: '<S21>/Integrator' */\r\n  SimpleFOC_B.Integrator_a = SimpleFOC_X.Integrator_CSTATE_g;\r\n\r\n  /* SignalConversion generated from: '<S4>/MatrixMultiply2' incorporates:\r\n   *  Constant: '<S9>/Constant'\r\n   */\r\n  SimpleFOC_B.TmpSignalConversionAtMatrixMu_m[0] = SimpleFOC_B.Integrator_d;\r\n  SimpleFOC_B.TmpSignalConversionAtMatrixMu_m[1] = SimpleFOC_B.Integrator_a;\r\n  SimpleFOC_B.TmpSignalConversionAtMatrixMu_m[2] = SimpleFOC_P.Constant_Value_mp;\r\n\r\n  /* Product: '<S4>/MatrixMultiply2' incorporates:\r\n   *  Concatenate: '<S5>/Matrix Concatenate1'\r\n   *  Product: '<S1>/MatrixMultiply'\r\n   */\r\n  tmp_5 = &SimpleFOC_B.MatrixConcatenate1[0];\r\n  cosOut = SimpleFOC_B.TmpSignalConversionAtMatrixMu_m[0];\r\n  tmp_3 = SimpleFOC_B.TmpSignalConversionAtMatrixMu_m[1];\r\n  tmp_1 = SimpleFOC_B.TmpSignalConversionAtMatrixMu_m[2];\r\n  for (i = 0; i < 3; i++) {\r\n    tmp = tmp_5[i] * cosOut;\r\n    tmp += tmp_5[i + 3] * tmp_3;\r\n    tmp += tmp_5[i + 6] * tmp_1;\r\n\r\n    /* Product: '<S4>/MatrixMultiply2' */\r\n    SimpleFOC_B.MatrixMultiply2[i] = tmp;\r\n  }\r\n\r\n  /* Bias: '<S24>/Bias3' */\r\n  SimpleFOC_B.Bias3 = SimpleFOC_B.Mod + SimpleFOC_P.Bias3_Bias;\r\n\r\n  /* Math: '<S24>/Mod' incorporates:\r\n   *  Constant: '<S24>/Constant7'\r\n   */\r\n  SimpleFOC_B.Mod_i = rt_modd_snf(SimpleFOC_B.Bias3, SimpleFOC_P.Constant7_Value);\r\n\r\n  /* RelationalOperator: '<S27>/Compare' incorporates:\r\n   *  Constant: '<S27>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare = (SimpleFOC_B.Mod_i <=\r\n    SimpleFOC_P.CompareToConstant_const);\r\n\r\n  /* Switch: '<S24>/Switch' */\r\n  if (SimpleFOC_B.Compare) {\r\n    /* Gain: '<S24>/Gain' */\r\n    SimpleFOC_B.Gain_n = SimpleFOC_P.Gain_Gain * SimpleFOC_B.Mod_i;\r\n\r\n    /* Bias: '<S24>/Bias1' */\r\n    SimpleFOC_B.Bias1_m = SimpleFOC_B.Gain_n + SimpleFOC_P.Bias1_Bias;\r\n\r\n    /* Switch: '<S24>/Switch' */\r\n    SimpleFOC_B.Switch = SimpleFOC_B.Bias1_m;\r\n  } else {\r\n    /* Switch: '<S24>/Switch' incorporates:\r\n     *  Constant: '<S24>/Constant8'\r\n     */\r\n    SimpleFOC_B.Switch = SimpleFOC_P.Constant8_Value;\r\n  }\r\n\r\n  /* End of Switch: '<S24>/Switch' */\r\n\r\n  /* RelationalOperator: '<S28>/Compare' incorporates:\r\n   *  Constant: '<S28>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_n = (SimpleFOC_B.Mod_i >\r\n    SimpleFOC_P.CompareToConstant1_const);\r\n\r\n  /* RelationalOperator: '<S29>/Compare' incorporates:\r\n   *  Constant: '<S29>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_k = (SimpleFOC_B.Mod_i <=\r\n    SimpleFOC_P.CompareToConstant2_const);\r\n\r\n  /* Logic: '<S24>/AND' */\r\n  SimpleFOC_B.AND = (SimpleFOC_B.Compare_n && SimpleFOC_B.Compare_k);\r\n\r\n  /* Switch: '<S24>/Switch1' */\r\n  if (SimpleFOC_B.AND) {\r\n    /* Switch: '<S24>/Switch1' incorporates:\r\n     *  Constant: '<S24>/Constant1'\r\n     */\r\n    SimpleFOC_B.Switch1 = SimpleFOC_P.Constant1_Value;\r\n  } else {\r\n    /* Switch: '<S24>/Switch1' incorporates:\r\n     *  Constant: '<S24>/Constant3'\r\n     */\r\n    SimpleFOC_B.Switch1 = SimpleFOC_P.Constant3_Value_l;\r\n  }\r\n\r\n  /* End of Switch: '<S24>/Switch1' */\r\n\r\n  /* RelationalOperator: '<S30>/Compare' incorporates:\r\n   *  Constant: '<S30>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_p = (SimpleFOC_B.Mod_i >\r\n    SimpleFOC_P.CompareToConstant3_const);\r\n\r\n  /* RelationalOperator: '<S31>/Compare' incorporates:\r\n   *  Constant: '<S31>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_c = (SimpleFOC_B.Mod_i <=\r\n    SimpleFOC_P.CompareToConstant6_const);\r\n\r\n  /* Logic: '<S24>/AND1' */\r\n  SimpleFOC_B.AND1 = (SimpleFOC_B.Compare_p && SimpleFOC_B.Compare_c);\r\n\r\n  /* Switch: '<S24>/Switch2' */\r\n  if (SimpleFOC_B.AND1) {\r\n    /* Gain: '<S24>/Gain1' */\r\n    SimpleFOC_B.Gain1_k = SimpleFOC_P.Gain1_Gain * SimpleFOC_B.Mod_i;\r\n\r\n    /* Bias: '<S24>/Bias' */\r\n    SimpleFOC_B.Bias_k = SimpleFOC_B.Gain1_k + SimpleFOC_P.Bias_Bias;\r\n\r\n    /* Switch: '<S24>/Switch2' */\r\n    SimpleFOC_B.Switch2 = SimpleFOC_B.Bias_k;\r\n  } else {\r\n    /* Switch: '<S24>/Switch2' incorporates:\r\n     *  Constant: '<S24>/Constant2'\r\n     */\r\n    SimpleFOC_B.Switch2 = SimpleFOC_P.Constant2_Value_i;\r\n  }\r\n\r\n  /* End of Switch: '<S24>/Switch2' */\r\n\r\n  /* RelationalOperator: '<S32>/Compare' incorporates:\r\n   *  Constant: '<S32>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_m = (SimpleFOC_B.Mod_i >\r\n    SimpleFOC_P.CompareToConstant7_const);\r\n\r\n  /* RelationalOperator: '<S33>/Compare' incorporates:\r\n   *  Constant: '<S33>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_h = (SimpleFOC_B.Mod_i <=\r\n    SimpleFOC_P.CompareToConstant8_const);\r\n\r\n  /* Logic: '<S24>/AND3' */\r\n  SimpleFOC_B.AND3 = (SimpleFOC_B.Compare_m && SimpleFOC_B.Compare_h);\r\n\r\n  /* Switch: '<S24>/Switch3' */\r\n  if (SimpleFOC_B.AND3) {\r\n    /* Switch: '<S24>/Switch3' incorporates:\r\n     *  Constant: '<S24>/Constant4'\r\n     */\r\n    SimpleFOC_B.Switch3 = SimpleFOC_P.Constant4_Value;\r\n  } else {\r\n    /* Switch: '<S24>/Switch3' incorporates:\r\n     *  Constant: '<S24>/Constant5'\r\n     */\r\n    SimpleFOC_B.Switch3 = SimpleFOC_P.Constant5_Value;\r\n  }\r\n\r\n  /* End of Switch: '<S24>/Switch3' */\r\n\r\n  /* RelationalOperator: '<S34>/Compare' incorporates:\r\n   *  Constant: '<S34>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_h4 = (SimpleFOC_B.Mod_i >\r\n    SimpleFOC_P.CompareToConstant9_const);\r\n\r\n  /* Switch: '<S24>/Switch4' */\r\n  if (SimpleFOC_B.Compare_h4) {\r\n    /* Gain: '<S24>/Gain2' */\r\n    SimpleFOC_B.Gain2_ng = SimpleFOC_P.Gain2_Gain * SimpleFOC_B.Mod_i;\r\n\r\n    /* Bias: '<S24>/Bias2' */\r\n    SimpleFOC_B.Bias2_b = SimpleFOC_B.Gain2_ng + SimpleFOC_P.Bias2_Bias;\r\n\r\n    /* Switch: '<S24>/Switch4' */\r\n    SimpleFOC_B.Switch4 = SimpleFOC_B.Bias2_b;\r\n  } else {\r\n    /* Switch: '<S24>/Switch4' incorporates:\r\n     *  Constant: '<S24>/Constant6'\r\n     */\r\n    SimpleFOC_B.Switch4 = SimpleFOC_P.Constant6_Value;\r\n  }\r\n\r\n  /* End of Switch: '<S24>/Switch4' */\r\n\r\n  /* Sum: '<S24>/Add' */\r\n  SimpleFOC_B.Add = (((SimpleFOC_B.Switch + SimpleFOC_B.Switch1) +\r\n                      SimpleFOC_B.Switch2) + SimpleFOC_B.Switch3) +\r\n    SimpleFOC_B.Switch4;\r\n\r\n  /* Bias: '<S25>/Bias3' */\r\n  SimpleFOC_B.Bias3_c = SimpleFOC_B.Mod + SimpleFOC_P.Bias3_Bias_g;\r\n\r\n  /* Math: '<S25>/Mod' incorporates:\r\n   *  Constant: '<S25>/Constant7'\r\n   */\r\n  SimpleFOC_B.Mod_f = rt_modd_snf(SimpleFOC_B.Bias3_c,\r\n    SimpleFOC_P.Constant7_Value_n);\r\n\r\n  /* RelationalOperator: '<S35>/Compare' incorporates:\r\n   *  Constant: '<S35>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_cg = (SimpleFOC_B.Mod_f <=\r\n    SimpleFOC_P.CompareToConstant_const_f);\r\n\r\n  /* Switch: '<S25>/Switch' */\r\n  if (SimpleFOC_B.Compare_cg) {\r\n    /* Gain: '<S25>/Gain' */\r\n    SimpleFOC_B.Gain_h = SimpleFOC_P.Gain_Gain_c * SimpleFOC_B.Mod_f;\r\n\r\n    /* Bias: '<S25>/Bias1' */\r\n    SimpleFOC_B.Bias1_p = SimpleFOC_B.Gain_h + SimpleFOC_P.Bias1_Bias_a;\r\n\r\n    /* Switch: '<S25>/Switch' */\r\n    SimpleFOC_B.Switch_d = SimpleFOC_B.Bias1_p;\r\n  } else {\r\n    /* Switch: '<S25>/Switch' incorporates:\r\n     *  Constant: '<S25>/Constant8'\r\n     */\r\n    SimpleFOC_B.Switch_d = SimpleFOC_P.Constant8_Value_h;\r\n  }\r\n\r\n  /* End of Switch: '<S25>/Switch' */\r\n\r\n  /* RelationalOperator: '<S36>/Compare' incorporates:\r\n   *  Constant: '<S36>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_i = (SimpleFOC_B.Mod_f >\r\n    SimpleFOC_P.CompareToConstant1_const_l);\r\n\r\n  /* RelationalOperator: '<S37>/Compare' incorporates:\r\n   *  Constant: '<S37>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_nw = (SimpleFOC_B.Mod_f <=\r\n    SimpleFOC_P.CompareToConstant2_const_f);\r\n\r\n  /* Logic: '<S25>/AND' */\r\n  SimpleFOC_B.AND_n = (SimpleFOC_B.Compare_i && SimpleFOC_B.Compare_nw);\r\n\r\n  /* Switch: '<S25>/Switch1' */\r\n  if (SimpleFOC_B.AND_n) {\r\n    /* Switch: '<S25>/Switch1' incorporates:\r\n     *  Constant: '<S25>/Constant1'\r\n     */\r\n    SimpleFOC_B.Switch1_k = SimpleFOC_P.Constant1_Value_d;\r\n  } else {\r\n    /* Switch: '<S25>/Switch1' incorporates:\r\n     *  Constant: '<S25>/Constant3'\r\n     */\r\n    SimpleFOC_B.Switch1_k = SimpleFOC_P.Constant3_Value_l3;\r\n  }\r\n\r\n  /* End of Switch: '<S25>/Switch1' */\r\n\r\n  /* RelationalOperator: '<S38>/Compare' incorporates:\r\n   *  Constant: '<S38>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_hx = (SimpleFOC_B.Mod_f >\r\n    SimpleFOC_P.CompareToConstant3_const_b);\r\n\r\n  /* RelationalOperator: '<S39>/Compare' incorporates:\r\n   *  Constant: '<S39>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_cy = (SimpleFOC_B.Mod_f <=\r\n    SimpleFOC_P.CompareToConstant6_const_k);\r\n\r\n  /* Logic: '<S25>/AND1' */\r\n  SimpleFOC_B.AND1_j = (SimpleFOC_B.Compare_hx && SimpleFOC_B.Compare_cy);\r\n\r\n  /* Switch: '<S25>/Switch2' */\r\n  if (SimpleFOC_B.AND1_j) {\r\n    /* Gain: '<S25>/Gain1' */\r\n    SimpleFOC_B.Gain1_l = SimpleFOC_P.Gain1_Gain_l * SimpleFOC_B.Mod_f;\r\n\r\n    /* Bias: '<S25>/Bias' */\r\n    SimpleFOC_B.Bias_o = SimpleFOC_B.Gain1_l + SimpleFOC_P.Bias_Bias_a;\r\n\r\n    /* Switch: '<S25>/Switch2' */\r\n    SimpleFOC_B.Switch2_j = SimpleFOC_B.Bias_o;\r\n  } else {\r\n    /* Switch: '<S25>/Switch2' incorporates:\r\n     *  Constant: '<S25>/Constant2'\r\n     */\r\n    SimpleFOC_B.Switch2_j = SimpleFOC_P.Constant2_Value_l;\r\n  }\r\n\r\n  /* End of Switch: '<S25>/Switch2' */\r\n\r\n  /* RelationalOperator: '<S40>/Compare' incorporates:\r\n   *  Constant: '<S40>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_l = (SimpleFOC_B.Mod_f >\r\n    SimpleFOC_P.CompareToConstant7_const_o);\r\n\r\n  /* RelationalOperator: '<S41>/Compare' incorporates:\r\n   *  Constant: '<S41>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_b = (SimpleFOC_B.Mod_f <=\r\n    SimpleFOC_P.CompareToConstant8_const_l);\r\n\r\n  /* Logic: '<S25>/AND3' */\r\n  SimpleFOC_B.AND3_p = (SimpleFOC_B.Compare_l && SimpleFOC_B.Compare_b);\r\n\r\n  /* Switch: '<S25>/Switch3' */\r\n  if (SimpleFOC_B.AND3_p) {\r\n    /* Switch: '<S25>/Switch3' incorporates:\r\n     *  Constant: '<S25>/Constant4'\r\n     */\r\n    SimpleFOC_B.Switch3_j = SimpleFOC_P.Constant4_Value_k;\r\n  } else {\r\n    /* Switch: '<S25>/Switch3' incorporates:\r\n     *  Constant: '<S25>/Constant5'\r\n     */\r\n    SimpleFOC_B.Switch3_j = SimpleFOC_P.Constant5_Value_a;\r\n  }\r\n\r\n  /* End of Switch: '<S25>/Switch3' */\r\n\r\n  /* RelationalOperator: '<S42>/Compare' incorporates:\r\n   *  Constant: '<S42>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_hm = (SimpleFOC_B.Mod_f >\r\n    SimpleFOC_P.CompareToConstant9_const_c);\r\n\r\n  /* Switch: '<S25>/Switch4' */\r\n  if (SimpleFOC_B.Compare_hm) {\r\n    /* Gain: '<S25>/Gain2' */\r\n    SimpleFOC_B.Gain2_e = SimpleFOC_P.Gain2_Gain_b * SimpleFOC_B.Mod_f;\r\n\r\n    /* Bias: '<S25>/Bias2' */\r\n    SimpleFOC_B.Bias2_k = SimpleFOC_B.Gain2_e + SimpleFOC_P.Bias2_Bias_j;\r\n\r\n    /* Switch: '<S25>/Switch4' */\r\n    SimpleFOC_B.Switch4_g = SimpleFOC_B.Bias2_k;\r\n  } else {\r\n    /* Switch: '<S25>/Switch4' incorporates:\r\n     *  Constant: '<S25>/Constant6'\r\n     */\r\n    SimpleFOC_B.Switch4_g = SimpleFOC_P.Constant6_Value_h;\r\n  }\r\n\r\n  /* End of Switch: '<S25>/Switch4' */\r\n\r\n  /* Sum: '<S25>/Add' */\r\n  SimpleFOC_B.Add_h = (((SimpleFOC_B.Switch_d + SimpleFOC_B.Switch1_k) +\r\n                        SimpleFOC_B.Switch2_j) + SimpleFOC_B.Switch3_j) +\r\n    SimpleFOC_B.Switch4_g;\r\n\r\n  /* Bias: '<S26>/Bias3' */\r\n  SimpleFOC_B.Bias3_n = SimpleFOC_B.Mod + SimpleFOC_P.Bias3_Bias_f;\r\n\r\n  /* Math: '<S26>/Mod' incorporates:\r\n   *  Constant: '<S26>/Constant7'\r\n   */\r\n  SimpleFOC_B.Mod_a = rt_modd_snf(SimpleFOC_B.Bias3_n,\r\n    SimpleFOC_P.Constant7_Value_k);\r\n\r\n  /* RelationalOperator: '<S43>/Compare' incorporates:\r\n   *  Constant: '<S43>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_mi = (SimpleFOC_B.Mod_a <=\r\n    SimpleFOC_P.CompareToConstant_const_b);\r\n\r\n  /* Switch: '<S26>/Switch' */\r\n  if (SimpleFOC_B.Compare_mi) {\r\n    /* Gain: '<S26>/Gain' */\r\n    SimpleFOC_B.Gain_g = SimpleFOC_P.Gain_Gain_o * SimpleFOC_B.Mod_a;\r\n\r\n    /* Bias: '<S26>/Bias1' */\r\n    SimpleFOC_B.Bias1 = SimpleFOC_B.Gain_g + SimpleFOC_P.Bias1_Bias_h;\r\n\r\n    /* Switch: '<S26>/Switch' */\r\n    SimpleFOC_B.Switch_g = SimpleFOC_B.Bias1;\r\n  } else {\r\n    /* Switch: '<S26>/Switch' incorporates:\r\n     *  Constant: '<S26>/Constant8'\r\n     */\r\n    SimpleFOC_B.Switch_g = SimpleFOC_P.Constant8_Value_g;\r\n  }\r\n\r\n  /* End of Switch: '<S26>/Switch' */\r\n\r\n  /* RelationalOperator: '<S44>/Compare' incorporates:\r\n   *  Constant: '<S44>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_he = (SimpleFOC_B.Mod_a >\r\n    SimpleFOC_P.CompareToConstant1_const_lf);\r\n\r\n  /* RelationalOperator: '<S45>/Compare' incorporates:\r\n   *  Constant: '<S45>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_hr = (SimpleFOC_B.Mod_a <=\r\n    SimpleFOC_P.CompareToConstant2_const_c);\r\n\r\n  /* Logic: '<S26>/AND' */\r\n  SimpleFOC_B.AND_nc = (SimpleFOC_B.Compare_he && SimpleFOC_B.Compare_hr);\r\n\r\n  /* Switch: '<S26>/Switch1' */\r\n  if (SimpleFOC_B.AND_nc) {\r\n    /* Switch: '<S26>/Switch1' incorporates:\r\n     *  Constant: '<S26>/Constant1'\r\n     */\r\n    SimpleFOC_B.Switch1_j = SimpleFOC_P.Constant1_Value_j;\r\n  } else {\r\n    /* Switch: '<S26>/Switch1' incorporates:\r\n     *  Constant: '<S26>/Constant3'\r\n     */\r\n    SimpleFOC_B.Switch1_j = SimpleFOC_P.Constant3_Value_o;\r\n  }\r\n\r\n  /* End of Switch: '<S26>/Switch1' */\r\n\r\n  /* RelationalOperator: '<S46>/Compare' incorporates:\r\n   *  Constant: '<S46>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_g = (SimpleFOC_B.Mod_a >\r\n    SimpleFOC_P.CompareToConstant3_const_k);\r\n\r\n  /* RelationalOperator: '<S47>/Compare' incorporates:\r\n   *  Constant: '<S47>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_pv = (SimpleFOC_B.Mod_a <=\r\n    SimpleFOC_P.CompareToConstant6_const_f);\r\n\r\n  /* Logic: '<S26>/AND1' */\r\n  SimpleFOC_B.AND1_i = (SimpleFOC_B.Compare_g && SimpleFOC_B.Compare_pv);\r\n\r\n  /* Switch: '<S26>/Switch2' */\r\n  if (SimpleFOC_B.AND1_i) {\r\n    /* Gain: '<S26>/Gain1' */\r\n    SimpleFOC_B.Gain1_e = SimpleFOC_P.Gain1_Gain_f * SimpleFOC_B.Mod_a;\r\n\r\n    /* Bias: '<S26>/Bias' */\r\n    SimpleFOC_B.Bias = SimpleFOC_B.Gain1_e + SimpleFOC_P.Bias_Bias_h;\r\n\r\n    /* Switch: '<S26>/Switch2' */\r\n    SimpleFOC_B.Switch2_g = SimpleFOC_B.Bias;\r\n  } else {\r\n    /* Switch: '<S26>/Switch2' incorporates:\r\n     *  Constant: '<S26>/Constant2'\r\n     */\r\n    SimpleFOC_B.Switch2_g = SimpleFOC_P.Constant2_Value_c;\r\n  }\r\n\r\n  /* End of Switch: '<S26>/Switch2' */\r\n\r\n  /* RelationalOperator: '<S48>/Compare' incorporates:\r\n   *  Constant: '<S48>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_bo = (SimpleFOC_B.Mod_a >\r\n    SimpleFOC_P.CompareToConstant7_const_b);\r\n\r\n  /* RelationalOperator: '<S49>/Compare' incorporates:\r\n   *  Constant: '<S49>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_ka = (SimpleFOC_B.Mod_a <=\r\n    SimpleFOC_P.CompareToConstant8_const_b);\r\n\r\n  /* Logic: '<S26>/AND3' */\r\n  SimpleFOC_B.AND3_a = (SimpleFOC_B.Compare_bo && SimpleFOC_B.Compare_ka);\r\n\r\n  /* Switch: '<S26>/Switch3' */\r\n  if (SimpleFOC_B.AND3_a) {\r\n    /* Switch: '<S26>/Switch3' incorporates:\r\n     *  Constant: '<S26>/Constant4'\r\n     */\r\n    SimpleFOC_B.Switch3_k = SimpleFOC_P.Constant4_Value_l;\r\n  } else {\r\n    /* Switch: '<S26>/Switch3' incorporates:\r\n     *  Constant: '<S26>/Constant5'\r\n     */\r\n    SimpleFOC_B.Switch3_k = SimpleFOC_P.Constant5_Value_ay;\r\n  }\r\n\r\n  /* End of Switch: '<S26>/Switch3' */\r\n\r\n  /* RelationalOperator: '<S50>/Compare' incorporates:\r\n   *  Constant: '<S50>/Constant'\r\n   */\r\n  SimpleFOC_B.Compare_f = (SimpleFOC_B.Mod_a >\r\n    SimpleFOC_P.CompareToConstant9_const_g);\r\n\r\n  /* Switch: '<S26>/Switch4' */\r\n  if (SimpleFOC_B.Compare_f) {\r\n    /* Gain: '<S26>/Gain2' */\r\n    SimpleFOC_B.Gain2_n = SimpleFOC_P.Gain2_Gain_p * SimpleFOC_B.Mod_a;\r\n\r\n    /* Bias: '<S26>/Bias2' */\r\n    SimpleFOC_B.Bias2 = SimpleFOC_B.Gain2_n + SimpleFOC_P.Bias2_Bias_c;\r\n\r\n    /* Switch: '<S26>/Switch4' */\r\n    SimpleFOC_B.Switch4_h = SimpleFOC_B.Bias2;\r\n  } else {\r\n    /* Switch: '<S26>/Switch4' incorporates:\r\n     *  Constant: '<S26>/Constant6'\r\n     */\r\n    SimpleFOC_B.Switch4_h = SimpleFOC_P.Constant6_Value_b;\r\n  }\r\n\r\n  /* End of Switch: '<S26>/Switch4' */\r\n\r\n  /* Sum: '<S26>/Add' */\r\n  SimpleFOC_B.Add_l = (((SimpleFOC_B.Switch_g + SimpleFOC_B.Switch1_j) +\r\n                        SimpleFOC_B.Switch2_g) + SimpleFOC_B.Switch3_k) +\r\n    SimpleFOC_B.Switch4_h;\r\n\r\n  /* Gain: '<S11>/Max_Lampda_PM_rate' */\r\n  cosOut = 2.0 * SimpleFOC_P.BLDC_Lambda / 2.617993877991494;\r\n\r\n  /* Gain: '<S11>/Max_Lampda_PM_rate' */\r\n  SimpleFOC_B.Max_Lampda_PM_rate[0] = cosOut * SimpleFOC_B.Add;\r\n  SimpleFOC_B.Max_Lampda_PM_rate[1] = cosOut * SimpleFOC_B.Add_h;\r\n  SimpleFOC_B.Max_Lampda_PM_rate[2] = cosOut * SimpleFOC_B.Add_l;\r\n\r\n  /* Product: '<S4>/Product2' */\r\n  SimpleFOC_B.Product2[0] = SimpleFOC_B.MatrixMultiply2[0] *\r\n    SimpleFOC_B.Max_Lampda_PM_rate[0];\r\n  SimpleFOC_B.Product2[1] = SimpleFOC_B.MatrixMultiply2[1] *\r\n    SimpleFOC_B.Max_Lampda_PM_rate[1];\r\n  SimpleFOC_B.Product2[2] = SimpleFOC_B.MatrixMultiply2[2] *\r\n    SimpleFOC_B.Max_Lampda_PM_rate[2];\r\n\r\n  /* Sum: '<S4>/Sum of Elements' */\r\n  cosOut = SimpleFOC_B.Product2[0];\r\n  cosOut += SimpleFOC_B.Product2[1];\r\n  cosOut += SimpleFOC_B.Product2[2];\r\n\r\n  /* Sum: '<S4>/Sum of Elements' */\r\n  SimpleFOC_B.SumofElements = cosOut;\r\n\r\n  /* Gain: '<S4>/Gain1' */\r\n  SimpleFOC_B.Gain1 = SimpleFOC_P.BLDC_p * SimpleFOC_B.SumofElements;\r\n\r\n  /* Product: '<S4>/Product' */\r\n  SimpleFOC_B.Product = SimpleFOC_B.Integrator_d * SimpleFOC_B.Integrator_a;\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* Sum: '<S4>/Subtract2' incorporates:\r\n     *  Constant: '<S4>/Ld'\r\n     *  Constant: '<S4>/Lq'\r\n     */\r\n    SimpleFOC_B.Subtract2 = SimpleFOC_P.BLDC_Ld - SimpleFOC_P.BLDC_Lq;\r\n  }\r\n\r\n  /* Product: '<S4>/Product1' */\r\n  SimpleFOC_B.Product1 = SimpleFOC_B.Product * SimpleFOC_B.Subtract2;\r\n\r\n  /* Gain: '<S4>/Gain3' */\r\n  cosOut = 3.0 * SimpleFOC_P.BLDC_p / 2.0;\r\n\r\n  /* Gain: '<S4>/Gain3' */\r\n  SimpleFOC_B.Gain3 = cosOut * SimpleFOC_B.Product1;\r\n\r\n  /* Sum: '<S4>/Add' */\r\n  SimpleFOC_B.Add_i = SimpleFOC_B.Gain1 + SimpleFOC_B.Gain3;\r\n\r\n  /* Trigonometry: '<S6>/SinCos' */\r\n  cosOut = cosOut_tmp;\r\n\r\n  /* Trigonometry: '<S6>/SinCos' */\r\n  SimpleFOC_B.SinCos_o1_p = Bias;\r\n\r\n  /* Trigonometry: '<S6>/SinCos' */\r\n  SimpleFOC_B.SinCos_o2_j = cosOut;\r\n\r\n  /* Gain: '<S6>/Gain' */\r\n  SimpleFOC_B.Gain = SimpleFOC_P.Gain_Gain_pp * SimpleFOC_B.SinCos_o1_p;\r\n\r\n  /* SignalConversion generated from: '<S6>/Matrix Concatenate1' incorporates:\r\n   *  Concatenate: '<S6>/Matrix Concatenate1'\r\n   *  Constant: '<S6>/Constant2'\r\n   */\r\n  SimpleFOC_B.MatrixConcatenate1_h[0] = SimpleFOC_B.SinCos_o2_j;\r\n  SimpleFOC_B.MatrixConcatenate1_h[1] = SimpleFOC_B.Gain;\r\n  SimpleFOC_B.MatrixConcatenate1_h[2] = SimpleFOC_P.Constant2_Value_h;\r\n\r\n  /* SignalConversion generated from: '<S6>/MatrixMultiply' */\r\n  SimpleFOC_B.TmpSignalConversionAtMatrixMu_a[0] = SimpleFOC_B.SinCos_o1_p;\r\n  SimpleFOC_B.TmpSignalConversionAtMatrixMu_a[1] = SimpleFOC_B.SinCos_o2_j;\r\n\r\n  /* Product: '<S6>/MatrixMultiply' incorporates:\r\n   *  Constant: '<S6>/Minus120'\r\n   */\r\n  cosOut = SimpleFOC_P.Minus120_Value_i[0];\r\n  tmp_3 = SimpleFOC_P.Minus120_Value_i[1];\r\n  tmp_1 = SimpleFOC_P.Minus120_Value_i[2];\r\n  tmp_4 = SimpleFOC_P.Minus120_Value_i[3];\r\n  tmp_0 = SimpleFOC_B.TmpSignalConversionAtMatrixMu_a[0];\r\n  tmp_2 = SimpleFOC_B.TmpSignalConversionAtMatrixMu_a[1];\r\n  tmp = cosOut * tmp_0;\r\n  tmp += tmp_1 * tmp_2;\r\n\r\n  /* Product: '<S6>/MatrixMultiply' */\r\n  SimpleFOC_B.MatrixMultiply_c[0] = tmp;\r\n\r\n  /* Product: '<S6>/MatrixMultiply' */\r\n  tmp = tmp_3 * tmp_0;\r\n  tmp += tmp_4 * tmp_2;\r\n\r\n  /* Product: '<S6>/MatrixMultiply' */\r\n  SimpleFOC_B.MatrixMultiply_c[1] = tmp;\r\n\r\n  /* Gain: '<S6>/Gain2' */\r\n  SimpleFOC_B.Gain2 = SimpleFOC_P.Gain2_Gain_bt * SimpleFOC_B.MatrixMultiply_c[0];\r\n\r\n  /* SignalConversion generated from: '<S6>/Matrix Concatenate1' incorporates:\r\n   *  Concatenate: '<S6>/Matrix Concatenate1'\r\n   *  Constant: '<S6>/Constant2'\r\n   */\r\n  SimpleFOC_B.MatrixConcatenate1_h[3] = SimpleFOC_B.MatrixMultiply_c[1];\r\n  SimpleFOC_B.MatrixConcatenate1_h[4] = SimpleFOC_B.Gain2;\r\n  SimpleFOC_B.MatrixConcatenate1_h[5] = SimpleFOC_P.Constant2_Value_h;\r\n\r\n  /* Product: '<S6>/MatrixMultiply1' incorporates:\r\n   *  Constant: '<S6>/Plus120'\r\n   */\r\n  cosOut = SimpleFOC_P.Plus120_Value_j[0];\r\n  tmp_3 = SimpleFOC_P.Plus120_Value_j[1];\r\n  tmp_1 = SimpleFOC_P.Plus120_Value_j[2];\r\n  tmp_4 = SimpleFOC_P.Plus120_Value_j[3];\r\n  tmp_0 = SimpleFOC_B.TmpSignalConversionAtMatrixMu_a[0];\r\n  tmp_2 = SimpleFOC_B.TmpSignalConversionAtMatrixMu_a[1];\r\n  tmp = cosOut * tmp_0;\r\n  tmp += tmp_1 * tmp_2;\r\n\r\n  /* Product: '<S6>/MatrixMultiply1' */\r\n  SimpleFOC_B.MatrixMultiply1_c[0] = tmp;\r\n\r\n  /* Product: '<S6>/MatrixMultiply1' */\r\n  tmp = tmp_3 * tmp_0;\r\n  tmp += tmp_4 * tmp_2;\r\n\r\n  /* Product: '<S6>/MatrixMultiply1' */\r\n  SimpleFOC_B.MatrixMultiply1_c[1] = tmp;\r\n\r\n  /* Gain: '<S6>/Gain3' */\r\n  SimpleFOC_B.Gain3_m = SimpleFOC_P.Gain3_Gain * SimpleFOC_B.MatrixMultiply1_c[0];\r\n\r\n  /* SignalConversion generated from: '<S6>/Matrix Concatenate1' incorporates:\r\n   *  Concatenate: '<S6>/Matrix Concatenate1'\r\n   *  Constant: '<S6>/Constant2'\r\n   */\r\n  SimpleFOC_B.MatrixConcatenate1_h[6] = SimpleFOC_B.MatrixMultiply1_c[1];\r\n  SimpleFOC_B.MatrixConcatenate1_h[7] = SimpleFOC_B.Gain3_m;\r\n  SimpleFOC_B.MatrixConcatenate1_h[8] = SimpleFOC_P.Constant2_Value_h;\r\n  for (i = 0; i < 9; i++) {\r\n    /* Gain: '<S6>/Gain1' incorporates:\r\n     *  Concatenate: '<S6>/Matrix Concatenate1'\r\n     */\r\n    SimpleFOC_B.Gain1_i[i] = SimpleFOC_P.Gain1_Gain_o *\r\n      SimpleFOC_B.MatrixConcatenate1_h[i];\r\n  }\r\n\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* Switch: '<S64>/Switch1' incorporates:\r\n     *  Constant: '<S64>/enableInportSatMethod'\r\n     */\r\n    if (SimpleFOC_P.enableInportSatMethod_Value != 0) {\r\n      /* Switch: '<S64>/Switch1' incorporates:\r\n       *  Constant: '<S52>/ReplaceInport_satMethod'\r\n       */\r\n      SimpleFOC_B.Switch1_o = SimpleFOC_P.ReplaceInport_satMethod_Value;\r\n    } else {\r\n      /* Switch: '<S64>/Switch1' incorporates:\r\n       *  Constant: '<S64>/ChosenMethod'\r\n       */\r\n      SimpleFOC_B.Switch1_o = SimpleFOC_P.ChosenMethod_Value;\r\n    }\r\n\r\n    /* End of Switch: '<S64>/Switch1' */\r\n\r\n    /* Constant: '<S2>/Constant1' */\r\n    SimpleFOC_B.SPQC = SimpleFOC_P.Constant1_Value_c;\r\n\r\n    /* UnitDelay generated from: '<Root>/Unit Delay' */\r\n    SimpleFOC_B.IaStator = SimpleFOC_DW.UnitDelay_1_DSTATE;\r\n\r\n    /* UnitDelay generated from: '<Root>/Unit Delay' */\r\n    SimpleFOC_B.IbStator = SimpleFOC_DW.UnitDelay_2_DSTATE;\r\n\r\n    /* Outputs for Atomic SubSystem: '<S2>/Clarke Transform' */\r\n    /* Sum: '<S51>/a_plus_2b' */\r\n    SimpleFOC_B.a_plus_2b = (SimpleFOC_B.IaStator + SimpleFOC_B.IbStator) +\r\n      SimpleFOC_B.IbStator;\r\n\r\n    /* Gain: '<S51>/one_by_sqrt3' */\r\n    SimpleFOC_B.one_by_sqrt3 = SimpleFOC_P.one_by_sqrt3_Gain *\r\n      SimpleFOC_B.a_plus_2b;\r\n\r\n    /* AlgorithmDescriptorDelegate generated from: '<S51>/a16' */\r\n    SimpleFOC_B.algDD_o1_e = SimpleFOC_B.IaStator;\r\n\r\n    /* AlgorithmDescriptorDelegate generated from: '<S51>/a16' */\r\n    SimpleFOC_B.algDD_o2_h = SimpleFOC_B.one_by_sqrt3;\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/Clarke Transform' */\r\n\r\n    /* UnitDelay generated from: '<Root>/Unit Delay' */\r\n    SimpleFOC_B.MtrPos = SimpleFOC_DW.UnitDelay_9_DSTATE;\r\n\r\n    /* Gain: '<S181>/convert_pu' */\r\n    SimpleFOC_B.convert_pu = SimpleFOC_P.convert_pu_Gain * SimpleFOC_B.MtrPos;\r\n\r\n    /* RelationalOperator: '<S182>/Compare' incorporates:\r\n     *  Constant: '<S182>/Constant'\r\n     */\r\n    SimpleFOC_B.Compare_pg = (SimpleFOC_B.convert_pu <\r\n      SimpleFOC_P.Constant_Value_h);\r\n\r\n    /* DataTypeConversion: '<S181>/Data Type Conversion' */\r\n    SimpleFOC_B.DataTypeConversion = SimpleFOC_B.Compare_pg;\r\n  }\r\n\r\n  /* If: '<S181>/If' */\r\n  if (rtsiIsModeUpdateTimeStep(&SimpleFOC_M->solverInfo)) {\r\n    rtAction = (int8_T)(SimpleFOC_B.DataTypeConversion <= 0);\r\n    SimpleFOC_DW.If_ActiveSubsystem = rtAction;\r\n  } else {\r\n    rtAction = SimpleFOC_DW.If_ActiveSubsystem;\r\n  }\r\n\r\n  if (rtAction == 0) {\r\n    /* Outputs for IfAction SubSystem: '<S181>/If Action Subsystem' incorporates:\r\n     *  ActionPort: '<S183>/Action Port'\r\n     */\r\n    /* DataTypeConversion: '<S183>/Convert_uint16' */\r\n    tmp = floor(SimpleFOC_B.convert_pu);\r\n    if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n      tmp = 0.0;\r\n    } else {\r\n      tmp = fmod(tmp, 65536.0);\r\n    }\r\n\r\n    /* DataTypeConversion: '<S183>/Convert_uint16' */\r\n    SimpleFOC_B.Convert_uint16_n = (int16_T)(tmp < 0.0 ? (int32_T)(int16_T)\r\n      -(int16_T)(uint16_T)-tmp : (int32_T)(int16_T)(uint16_T)tmp);\r\n\r\n    /* DataTypeConversion: '<S183>/Convert_back' */\r\n    SimpleFOC_B.Convert_back_k = SimpleFOC_B.Convert_uint16_n;\r\n\r\n    /* Merge: '<S181>/Merge' incorporates:\r\n     *  Sum: '<S183>/Sum'\r\n     */\r\n    SimpleFOC_B.Merge = SimpleFOC_B.convert_pu - SimpleFOC_B.Convert_back_k;\r\n\r\n    /* End of Outputs for SubSystem: '<S181>/If Action Subsystem' */\r\n  } else {\r\n    /* Outputs for IfAction SubSystem: '<S181>/If Action Subsystem1' incorporates:\r\n     *  ActionPort: '<S184>/Action Port'\r\n     */\r\n    /* DataTypeConversion: '<S184>/Convert_uint16' */\r\n    tmp = trunc(SimpleFOC_B.convert_pu);\r\n    if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n      tmp = 0.0;\r\n    } else {\r\n      tmp = fmod(tmp, 65536.0);\r\n    }\r\n\r\n    /* DataTypeConversion: '<S184>/Convert_uint16' */\r\n    SimpleFOC_B.Convert_uint16 = (int16_T)(tmp < 0.0 ? (int32_T)(int16_T)\r\n      -(int16_T)(uint16_T)-tmp : (int32_T)(int16_T)(uint16_T)tmp);\r\n\r\n    /* DataTypeConversion: '<S184>/Convert_back' */\r\n    SimpleFOC_B.Convert_back = SimpleFOC_B.Convert_uint16;\r\n\r\n    /* Merge: '<S181>/Merge' incorporates:\r\n     *  Sum: '<S184>/Sum'\r\n     */\r\n    SimpleFOC_B.Merge = SimpleFOC_B.convert_pu - SimpleFOC_B.Convert_back;\r\n\r\n    /* End of Outputs for SubSystem: '<S181>/If Action Subsystem1' */\r\n  }\r\n\r\n  /* End of If: '<S181>/If' */\r\n\r\n  /* Gain: '<S61>/indexing' */\r\n  SimpleFOC_B.indexing = SimpleFOC_P.indexing_Gain * SimpleFOC_B.Merge;\r\n\r\n  /* DataTypeConversion: '<S61>/Get_Integer' */\r\n  tmp = trunc(SimpleFOC_B.indexing);\r\n  if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n    tmp = 0.0;\r\n  } else {\r\n    tmp = fmod(tmp, 65536.0);\r\n  }\r\n\r\n  /* DataTypeConversion: '<S61>/Get_Integer' */\r\n  SimpleFOC_B.Get_Integer = (uint16_T)(tmp < 0.0 ? (int32_T)(uint16_T)-(int16_T)\r\n    (uint16_T)-tmp : (int32_T)(uint16_T)tmp);\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* Sum: '<S61>/Sum' incorporates:\r\n     *  Constant: '<S61>/offset'\r\n     */\r\n    Sum_l = (uint32_T)SimpleFOC_P.offset_Value[0] + SimpleFOC_B.Get_Integer;\r\n    SimpleFOC_B.Sum_l[0] = Sum_l;\r\n\r\n    /* Selector: '<S61>/Lookup' incorporates:\r\n     *  Constant: '<S61>/sine_table_values'\r\n     */\r\n    SimpleFOC_B.Lookup[0] = SimpleFOC_P.sine_table_values_Value[(int32_T)Sum_l];\r\n\r\n    /* Sum: '<S61>/Sum' incorporates:\r\n     *  Constant: '<S61>/offset'\r\n     */\r\n    Sum_l = (uint32_T)SimpleFOC_P.offset_Value[1] + SimpleFOC_B.Get_Integer;\r\n    SimpleFOC_B.Sum_l[1] = Sum_l;\r\n\r\n    /* Selector: '<S61>/Lookup' incorporates:\r\n     *  Constant: '<S61>/sine_table_values'\r\n     */\r\n    SimpleFOC_B.Lookup[1] = SimpleFOC_P.sine_table_values_Value[(int32_T)Sum_l];\r\n\r\n    /* Sum: '<S61>/Sum' incorporates:\r\n     *  Constant: '<S61>/offset'\r\n     */\r\n    Sum_l = (uint32_T)SimpleFOC_P.offset_Value[2] + SimpleFOC_B.Get_Integer;\r\n    SimpleFOC_B.Sum_l[2] = Sum_l;\r\n\r\n    /* Selector: '<S61>/Lookup' incorporates:\r\n     *  Constant: '<S61>/sine_table_values'\r\n     */\r\n    SimpleFOC_B.Lookup[2] = SimpleFOC_P.sine_table_values_Value[(int32_T)Sum_l];\r\n\r\n    /* Sum: '<S61>/Sum' incorporates:\r\n     *  Constant: '<S61>/offset'\r\n     */\r\n    Sum_l = (uint32_T)SimpleFOC_P.offset_Value[3] + SimpleFOC_B.Get_Integer;\r\n    SimpleFOC_B.Sum_l[3] = Sum_l;\r\n\r\n    /* Selector: '<S61>/Lookup' incorporates:\r\n     *  Constant: '<S61>/sine_table_values'\r\n     */\r\n    SimpleFOC_B.Lookup[3] = SimpleFOC_P.sine_table_values_Value[(int32_T)Sum_l];\r\n\r\n    /* Sum: '<S180>/Sum3' */\r\n    SimpleFOC_B.Sum3 = SimpleFOC_B.Lookup[0] - SimpleFOC_B.Lookup[1];\r\n  }\r\n\r\n  /* DataTypeConversion: '<S61>/Data Type Conversion1' */\r\n  SimpleFOC_B.DataTypeConversion1 = SimpleFOC_B.Get_Integer;\r\n\r\n  /* Sum: '<S61>/Sum2' */\r\n  SimpleFOC_B.Sum2 = SimpleFOC_B.indexing - SimpleFOC_B.DataTypeConversion1;\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* Product: '<S180>/Product' */\r\n    SimpleFOC_B.Product_d = SimpleFOC_B.Sum3 * SimpleFOC_B.Sum2;\r\n\r\n    /* Sum: '<S180>/Sum4' */\r\n    SimpleFOC_B.Sum4 = SimpleFOC_B.Product_d + SimpleFOC_B.Lookup[1];\r\n\r\n    /* Sum: '<S180>/Sum5' */\r\n    SimpleFOC_B.Sum5 = SimpleFOC_B.Lookup[2] - SimpleFOC_B.Lookup[3];\r\n\r\n    /* Product: '<S180>/Product1' */\r\n    SimpleFOC_B.Product1_i = SimpleFOC_B.Sum5 * SimpleFOC_B.Sum2;\r\n\r\n    /* Sum: '<S180>/Sum6' */\r\n    SimpleFOC_B.Sum6 = SimpleFOC_B.Product1_i + SimpleFOC_B.Lookup[3];\r\n\r\n    /* Outputs for Atomic SubSystem: '<S2>/Park Transform' */\r\n    /* Product: '<S60>/bcos' */\r\n    SimpleFOC_B.bcos = SimpleFOC_B.algDD_o2_h * SimpleFOC_B.Sum6;\r\n\r\n    /* Product: '<S60>/asin' */\r\n    SimpleFOC_B.asin_d = SimpleFOC_B.algDD_o1_e * SimpleFOC_B.Sum4;\r\n\r\n    /* Sum: '<S60>/sum_Qs' */\r\n    SimpleFOC_B.sum_Qs = SimpleFOC_B.bcos - SimpleFOC_B.asin_d;\r\n\r\n    /* Product: '<S60>/acos' */\r\n    SimpleFOC_B.acos_f = SimpleFOC_B.algDD_o1_e * SimpleFOC_B.Sum6;\r\n\r\n    /* Product: '<S60>/bsin' */\r\n    SimpleFOC_B.bsin = SimpleFOC_B.algDD_o2_h * SimpleFOC_B.Sum4;\r\n\r\n    /* Sum: '<S60>/sum_Ds' */\r\n    SimpleFOC_B.sum_Ds = SimpleFOC_B.acos_f + SimpleFOC_B.bsin;\r\n\r\n    /* Switch: '<S179>/Switch' incorporates:\r\n     *  Constant: '<S179>/Offset'\r\n     */\r\n    if (SimpleFOC_P.Offset_Value_h > SimpleFOC_P.Switch_Threshold_b) {\r\n      /* UnaryMinus: '<S179>/Unary_Minus' */\r\n      SimpleFOC_B.Unary_Minus = -SimpleFOC_B.sum_Qs;\r\n\r\n      /* Switch: '<S179>/Switch' */\r\n      SimpleFOC_B.Switch_a[0] = SimpleFOC_B.Unary_Minus;\r\n      SimpleFOC_B.Switch_a[1] = SimpleFOC_B.sum_Ds;\r\n    } else {\r\n      /* Switch: '<S179>/Switch' */\r\n      SimpleFOC_B.Switch_a[0] = SimpleFOC_B.sum_Ds;\r\n      SimpleFOC_B.Switch_a[1] = SimpleFOC_B.sum_Qs;\r\n    }\r\n\r\n    /* End of Switch: '<S179>/Switch' */\r\n\r\n    /* AlgorithmDescriptorDelegate generated from: '<S60>/a16' */\r\n    SimpleFOC_B.algDD_o1 = SimpleFOC_B.Switch_a[0];\r\n\r\n    /* AlgorithmDescriptorDelegate generated from: '<S60>/a16' */\r\n    SimpleFOC_B.algDD_o2 = SimpleFOC_B.Switch_a[1];\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/Park Transform' */\r\n\r\n    /* Sum: '<S2>/Sum2' */\r\n    SimpleFOC_B.ErrorQC = SimpleFOC_B.SPQC - SimpleFOC_B.algDD_o2;\r\n\r\n    /* Gain: '<S160>/Proportional Gain' */\r\n    SimpleFOC_B.ProportionalGain = SimpleFOC_P.Kp_iq * SimpleFOC_B.ErrorQC;\r\n\r\n    /* Constant: '<S2>/Constant' */\r\n    SimpleFOC_B.SPDC = SimpleFOC_P.Constant_Value_j;\r\n\r\n    /* Sum: '<S2>/Sum1' */\r\n    SimpleFOC_B.ErrorDC = SimpleFOC_B.SPDC - SimpleFOC_B.algDD_o1;\r\n\r\n    /* Gain: '<S112>/Proportional Gain' */\r\n    SimpleFOC_B.ProportionalGain_j = SimpleFOC_P.Kp_id * SimpleFOC_B.ErrorDC;\r\n  }\r\n\r\n  /* Integrator: '<S155>/Integrator' */\r\n  SimpleFOC_B.Integrator_l = SimpleFOC_X.Integrator_CSTATE_lo;\r\n\r\n  /* Sum: '<S164>/Sum' */\r\n  SimpleFOC_B.Sum = SimpleFOC_B.ProportionalGain + SimpleFOC_B.Integrator_l;\r\n\r\n  /* Integrator: '<S107>/Integrator' */\r\n  SimpleFOC_B.Integrator_g = SimpleFOC_X.Integrator_CSTATE_p;\r\n\r\n  /* Sum: '<S116>/Sum' */\r\n  SimpleFOC_B.Sum_d = SimpleFOC_B.ProportionalGain_j + SimpleFOC_B.Integrator_g;\r\n\r\n  /* Product: '<S65>/Product' */\r\n  SimpleFOC_B.Product_b = SimpleFOC_B.Sum_d * SimpleFOC_B.Sum_d;\r\n\r\n  /* Product: '<S65>/Product1' */\r\n  SimpleFOC_B.Product1_h = SimpleFOC_B.Sum * SimpleFOC_B.Sum;\r\n\r\n  /* Sum: '<S65>/Sum1' */\r\n  SimpleFOC_B.Sum1 = SimpleFOC_B.Product_b + SimpleFOC_B.Product1_h;\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* Switch: '<S64>/Switch' incorporates:\r\n     *  Constant: '<S64>/enableInportSatLim'\r\n     */\r\n    if (SimpleFOC_P.enableInportSatLim_Value != 0) {\r\n      /* Switch: '<S64>/Switch' incorporates:\r\n       *  Constant: '<S52>/ReplaceInport_satLim'\r\n       */\r\n      SimpleFOC_B.Switch_i = SimpleFOC_P.ReplaceInport_satLim_Value;\r\n    } else {\r\n      /* Switch: '<S64>/Switch' incorporates:\r\n       *  Constant: '<S64>/Constant3'\r\n       */\r\n      SimpleFOC_B.Switch_i = SimpleFOC_P.Constant3_Value;\r\n    }\r\n\r\n    /* End of Switch: '<S64>/Switch' */\r\n\r\n    /* Product: '<S64>/Product' */\r\n    SimpleFOC_B.Product_dk = SimpleFOC_B.Switch_i * SimpleFOC_B.Switch_i;\r\n\r\n    /* If: '<S52>/If' */\r\n    if (rtsiIsModeUpdateTimeStep(&SimpleFOC_M->solverInfo)) {\r\n      rtAction = (int8_T)((SimpleFOC_B.Switch1_o != 1) && (SimpleFOC_B.Switch1_o\r\n        != 2));\r\n      SimpleFOC_DW.If_ActiveSubsystem_p = rtAction;\r\n    } else {\r\n      rtAction = SimpleFOC_DW.If_ActiveSubsystem_p;\r\n    }\r\n\r\n    if (rtAction == 0) {\r\n      /* Outputs for IfAction SubSystem: '<S52>/D//Q Axis Priority' incorporates:\r\n       *  ActionPort: '<S63>/Action Port'\r\n       */\r\n      /* RelationalOperator: '<S68>/Compare' incorporates:\r\n       *  Constant: '<S68>/Constant'\r\n       */\r\n      SimpleFOC_B.Compare_o = (SimpleFOC_B.Switch1_o ==\r\n        SimpleFOC_P.CompareToConstant_const_j);\r\n\r\n      /* RelationalOperator: '<S69>/Compare' incorporates:\r\n       *  Constant: '<S69>/Constant'\r\n       */\r\n      SimpleFOC_B.Compare_c0 = (SimpleFOC_B.Switch1_o ==\r\n        SimpleFOC_P.CompareToConstant1_const_a);\r\n\r\n      /* Switch: '<S63>/Switch' */\r\n      if (SimpleFOC_B.Compare_o) {\r\n        /* Switch: '<S63>/Switch' */\r\n        SimpleFOC_B.Switch_az[0] = SimpleFOC_B.Sum_d;\r\n        SimpleFOC_B.Switch_az[1] = SimpleFOC_B.Sum;\r\n      } else {\r\n        /* Switch: '<S63>/Switch' */\r\n        SimpleFOC_B.Switch_az[0] = SimpleFOC_B.Sum;\r\n        SimpleFOC_B.Switch_az[1] = SimpleFOC_B.Sum_d;\r\n      }\r\n\r\n      /* End of Switch: '<S63>/Switch' */\r\n\r\n      /* RelationalOperator: '<S73>/LowerRelop1' */\r\n      SimpleFOC_B.LowerRelop1 = (SimpleFOC_B.Switch_az[0] > SimpleFOC_B.Switch_i);\r\n\r\n      /* Switch: '<S73>/Switch2' */\r\n      if (SimpleFOC_B.LowerRelop1) {\r\n        /* Switch: '<S73>/Switch2' */\r\n        SimpleFOC_B.Switch2_h = SimpleFOC_B.Switch_i;\r\n      } else {\r\n        /* Gain: '<S72>/Gain' */\r\n        SimpleFOC_B.Gain_e = SimpleFOC_P.Gain_Gain_k * SimpleFOC_B.Switch_i;\r\n\r\n        /* RelationalOperator: '<S73>/UpperRelop' */\r\n        SimpleFOC_B.UpperRelop = (SimpleFOC_B.Switch_az[0] < SimpleFOC_B.Gain_e);\r\n\r\n        /* Switch: '<S73>/Switch' */\r\n        if (SimpleFOC_B.UpperRelop) {\r\n          /* Switch: '<S73>/Switch' */\r\n          SimpleFOC_B.Switch_l = SimpleFOC_B.Gain_e;\r\n        } else {\r\n          /* Switch: '<S73>/Switch' */\r\n          SimpleFOC_B.Switch_l = SimpleFOC_B.Switch_az[0];\r\n        }\r\n\r\n        /* End of Switch: '<S73>/Switch' */\r\n\r\n        /* Switch: '<S73>/Switch2' */\r\n        SimpleFOC_B.Switch2_h = SimpleFOC_B.Switch_l;\r\n      }\r\n\r\n      /* End of Switch: '<S73>/Switch2' */\r\n\r\n      /* Product: '<S72>/Product' */\r\n      SimpleFOC_B.Product_p = SimpleFOC_B.Switch2_h * SimpleFOC_B.Switch2_h;\r\n\r\n      /* Sum: '<S72>/Sum' */\r\n      SimpleFOC_B.Sum_m = SimpleFOC_B.Product_dk - SimpleFOC_B.Product_p;\r\n\r\n      /* Product: '<S72>/Product2' */\r\n      SimpleFOC_B.Product2_l = SimpleFOC_B.Switch_az[1] * SimpleFOC_B.Switch_az\r\n        [1];\r\n\r\n      /* RelationalOperator: '<S72>/Relational Operator' */\r\n      SimpleFOC_B.RelationalOperator_g = (SimpleFOC_B.Sum_m >=\r\n        SimpleFOC_B.Product2_l);\r\n\r\n      /* DataTypeConversion: '<S72>/Data Type Conversion' */\r\n      SimpleFOC_B.DataTypeConversion_j = SimpleFOC_B.RelationalOperator_g;\r\n\r\n      /* If: '<S72>/If' incorporates:\r\n       *  Switch: '<S74>/Switch1'\r\n       */\r\n      if (SimpleFOC_B.DataTypeConversion_j != 0) {\r\n        /* Outputs for IfAction SubSystem: '<S72>/passThrough' incorporates:\r\n         *  ActionPort: '<S75>/Action Port'\r\n         */\r\n        /* Merge: '<S72>/Merge' incorporates:\r\n         *  SignalConversion generated from: '<S75>/ref2'\r\n         */\r\n        SimpleFOC_B.Merge_o = SimpleFOC_B.Switch_az[1];\r\n\r\n        /* End of Outputs for SubSystem: '<S72>/passThrough' */\r\n      } else {\r\n        /* Outputs for IfAction SubSystem: '<S72>/limitRef2' incorporates:\r\n         *  ActionPort: '<S74>/Action Port'\r\n         */\r\n        if (SimpleFOC_B.Sum_m > SimpleFOC_P.Switch1_Threshold) {\r\n          /* Switch: '<S74>/Switch1' */\r\n          SimpleFOC_B.Switch1_d = SimpleFOC_B.Sum_m;\r\n        } else {\r\n          /* Switch: '<S74>/Switch1' incorporates:\r\n           *  Constant: '<S74>/Constant'\r\n           */\r\n          SimpleFOC_B.Switch1_d = SimpleFOC_P.Constant_Value;\r\n        }\r\n\r\n        /* Sqrt: '<S74>/Sqrt' */\r\n        SimpleFOC_B.Sqrt = sqrt(SimpleFOC_B.Switch1_d);\r\n\r\n        /* Switch: '<S74>/Switch' */\r\n        if (SimpleFOC_B.Switch_az[1] >= SimpleFOC_P.Switch_Threshold) {\r\n          /* Merge: '<S72>/Merge' */\r\n          SimpleFOC_B.Merge_o = SimpleFOC_B.Sqrt;\r\n        } else {\r\n          /* Gain: '<S74>/Gain' */\r\n          SimpleFOC_B.Gain_m = SimpleFOC_P.Gain_Gain_p * SimpleFOC_B.Sqrt;\r\n\r\n          /* Merge: '<S72>/Merge' */\r\n          SimpleFOC_B.Merge_o = SimpleFOC_B.Gain_m;\r\n        }\r\n\r\n        /* End of Switch: '<S74>/Switch' */\r\n        /* End of Outputs for SubSystem: '<S72>/limitRef2' */\r\n      }\r\n\r\n      /* End of If: '<S72>/If' */\r\n\r\n      /* Switch: '<S63>/Switch1' */\r\n      if (SimpleFOC_B.Compare_c0) {\r\n        /* Merge: '<S52>/Merge' */\r\n        SimpleFOC_B.Merge_e[0] = SimpleFOC_B.Switch2_h;\r\n        SimpleFOC_B.Merge_e[1] = SimpleFOC_B.Merge_o;\r\n      } else {\r\n        /* Merge: '<S52>/Merge' */\r\n        SimpleFOC_B.Merge_e[0] = SimpleFOC_B.Merge_o;\r\n        SimpleFOC_B.Merge_e[1] = SimpleFOC_B.Switch2_h;\r\n      }\r\n\r\n      /* End of Switch: '<S63>/Switch1' */\r\n      /* End of Outputs for SubSystem: '<S52>/D//Q Axis Priority' */\r\n    } else {\r\n      /* Outputs for IfAction SubSystem: '<S52>/D-Q Equivalence' incorporates:\r\n       *  ActionPort: '<S62>/Action Port'\r\n       */\r\n      /* RelationalOperator: '<S62>/Relational Operator' */\r\n      SimpleFOC_B.RelationalOperator = (SimpleFOC_B.Sum1 >\r\n        SimpleFOC_B.Product_dk);\r\n\r\n      /* DataTypeConversion: '<S62>/Data Type Conversion' */\r\n      SimpleFOC_B.DataTypeConversion_d = SimpleFOC_B.RelationalOperator;\r\n\r\n      /* If: '<S62>/If' */\r\n      if (SimpleFOC_B.DataTypeConversion_d != 0) {\r\n        /* Outputs for IfAction SubSystem: '<S62>/Limiter' incorporates:\r\n         *  ActionPort: '<S66>/Action Port'\r\n         */\r\n        /* Product: '<S66>/Product' */\r\n        SimpleFOC_B.Product_b2[0] = SimpleFOC_B.Sum_d * SimpleFOC_B.Switch_i;\r\n        SimpleFOC_B.Product_b2[1] = SimpleFOC_B.Sum * SimpleFOC_B.Switch_i;\r\n\r\n        /* Sqrt: '<S66>/Square Root' */\r\n        SimpleFOC_B.SquareRoot = sqrt(SimpleFOC_B.Sum1);\r\n\r\n        /* Switch: '<S66>/Switch' */\r\n        if (SimpleFOC_B.SquareRoot != 0.0) {\r\n          /* Switch: '<S66>/Switch' */\r\n          SimpleFOC_B.Switch_h = SimpleFOC_B.SquareRoot;\r\n        } else {\r\n          /* Switch: '<S66>/Switch' incorporates:\r\n           *  Constant: '<S66>/Constant'\r\n           */\r\n          SimpleFOC_B.Switch_h = SimpleFOC_P.Constant_Value_o;\r\n        }\r\n\r\n        /* End of Switch: '<S66>/Switch' */\r\n\r\n        /* Product: '<S66>/Reciprocal' */\r\n        SimpleFOC_B.Reciprocal = 1.0 / SimpleFOC_B.Switch_h;\r\n\r\n        /* Merge: '<S52>/Merge' incorporates:\r\n         *  Product: '<S66>/Product1'\r\n         */\r\n        SimpleFOC_B.Merge_e[0] = SimpleFOC_B.Product_b2[0] *\r\n          SimpleFOC_B.Reciprocal;\r\n        SimpleFOC_B.Merge_e[1] = SimpleFOC_B.Product_b2[1] *\r\n          SimpleFOC_B.Reciprocal;\r\n\r\n        /* End of Outputs for SubSystem: '<S62>/Limiter' */\r\n      } else {\r\n        /* Outputs for IfAction SubSystem: '<S62>/Passthrough' incorporates:\r\n         *  ActionPort: '<S67>/Action Port'\r\n         */\r\n        /* Merge: '<S52>/Merge' incorporates:\r\n         *  SignalConversion generated from: '<S67>/dqRef'\r\n         */\r\n        SimpleFOC_B.Merge_e[0] = SimpleFOC_B.Sum_d;\r\n        SimpleFOC_B.Merge_e[1] = SimpleFOC_B.Sum;\r\n\r\n        /* End of Outputs for SubSystem: '<S62>/Passthrough' */\r\n      }\r\n\r\n      /* End of If: '<S62>/If' */\r\n      /* End of Outputs for SubSystem: '<S52>/D-Q Equivalence' */\r\n    }\r\n\r\n    /* End of If: '<S52>/If' */\r\n\r\n    /* Outputs for Atomic SubSystem: '<S2>/Inverse Park Transform' */\r\n    /* Product: '<S56>/qcos' */\r\n    SimpleFOC_B.qcos = SimpleFOC_B.Merge_e[1] * SimpleFOC_B.Sum6;\r\n\r\n    /* Product: '<S56>/dsin' */\r\n    SimpleFOC_B.dsin = SimpleFOC_B.Merge_e[0] * SimpleFOC_B.Sum4;\r\n\r\n    /* Sum: '<S56>/sum_beta' */\r\n    SimpleFOC_B.sum_beta = SimpleFOC_B.qcos + SimpleFOC_B.dsin;\r\n\r\n    /* Product: '<S56>/dcos' */\r\n    SimpleFOC_B.dcos = SimpleFOC_B.Merge_e[0] * SimpleFOC_B.Sum6;\r\n\r\n    /* Product: '<S56>/qsin' */\r\n    SimpleFOC_B.qsin = SimpleFOC_B.Merge_e[1] * SimpleFOC_B.Sum4;\r\n\r\n    /* Sum: '<S56>/sum_alpha' */\r\n    SimpleFOC_B.sum_alpha = SimpleFOC_B.dcos - SimpleFOC_B.qsin;\r\n\r\n    /* Switch: '<S172>/Switch' incorporates:\r\n     *  Constant: '<S172>/Offset'\r\n     */\r\n    if (SimpleFOC_P.Offset_Value > SimpleFOC_P.Switch_Threshold_c) {\r\n      /* UnaryMinus: '<S172>/Unary_Minus' */\r\n      SimpleFOC_B.Unary_Minus_a = -SimpleFOC_B.sum_alpha;\r\n\r\n      /* Switch: '<S172>/Switch' */\r\n      SimpleFOC_B.Switch_m[0] = SimpleFOC_B.sum_beta;\r\n      SimpleFOC_B.Switch_m[1] = SimpleFOC_B.Unary_Minus_a;\r\n    } else {\r\n      /* Switch: '<S172>/Switch' */\r\n      SimpleFOC_B.Switch_m[0] = SimpleFOC_B.sum_alpha;\r\n      SimpleFOC_B.Switch_m[1] = SimpleFOC_B.sum_beta;\r\n    }\r\n\r\n    /* End of Switch: '<S172>/Switch' */\r\n\r\n    /* AlgorithmDescriptorDelegate generated from: '<S56>/a16' */\r\n    SimpleFOC_B.algDD_o1_c = SimpleFOC_B.Switch_m[0];\r\n\r\n    /* AlgorithmDescriptorDelegate generated from: '<S56>/a16' */\r\n    SimpleFOC_B.algDD_o2_d = SimpleFOC_B.Switch_m[1];\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/Inverse Park Transform' */\r\n\r\n    /* Gain: '<S55>/one_by_two' */\r\n    SimpleFOC_B.one_by_two = SimpleFOC_P.one_by_two_Gain *\r\n      SimpleFOC_B.algDD_o1_c;\r\n\r\n    /* Gain: '<S55>/sqrt3_by_two' */\r\n    SimpleFOC_B.sqrt3_by_two = SimpleFOC_P.sqrt3_by_two_Gain *\r\n      SimpleFOC_B.algDD_o2_d;\r\n\r\n    /* Sum: '<S55>/add_b' */\r\n    SimpleFOC_B.add_b = SimpleFOC_B.sqrt3_by_two - SimpleFOC_B.one_by_two;\r\n\r\n    /* Sum: '<S55>/add_c' */\r\n    SimpleFOC_B.add_c = (0.0 - SimpleFOC_B.one_by_two) -\r\n      SimpleFOC_B.sqrt3_by_two;\r\n\r\n    /* MinMax: '<S177>/Max' */\r\n    Bias = fmax(SimpleFOC_B.algDD_o1_c, SimpleFOC_B.add_b);\r\n    Bias = fmax(Bias, SimpleFOC_B.add_c);\r\n\r\n    /* MinMax: '<S177>/Max' */\r\n    SimpleFOC_B.Max = Bias;\r\n\r\n    /* MinMax: '<S177>/Min' */\r\n    Bias = fmin(SimpleFOC_B.algDD_o1_c, SimpleFOC_B.add_b);\r\n    Bias = fmin(Bias, SimpleFOC_B.add_c);\r\n\r\n    /* MinMax: '<S177>/Min' */\r\n    SimpleFOC_B.Min = Bias;\r\n\r\n    /* Sum: '<S177>/Add' */\r\n    SimpleFOC_B.Add_k = SimpleFOC_B.Max + SimpleFOC_B.Min;\r\n\r\n    /* Gain: '<S177>/one_by_two' */\r\n    SimpleFOC_B.one_by_two_d = SimpleFOC_P.one_by_two_Gain_o * SimpleFOC_B.Add_k;\r\n\r\n    /* Sum: '<S176>/Add3' */\r\n    SimpleFOC_B.Add3 = SimpleFOC_B.algDD_o1_c + SimpleFOC_B.one_by_two_d;\r\n\r\n    /* Sum: '<S176>/Add1' */\r\n    SimpleFOC_B.Add1 = SimpleFOC_B.add_b + SimpleFOC_B.one_by_two_d;\r\n\r\n    /* Sum: '<S176>/Add2' */\r\n    SimpleFOC_B.Add2 = SimpleFOC_B.one_by_two_d + SimpleFOC_B.add_c;\r\n\r\n    /* Gain: '<S176>/Gain' */\r\n    SimpleFOC_B.Gain_a[0] = SimpleFOC_P.Gain_Gain_e * SimpleFOC_B.Add3;\r\n    SimpleFOC_B.Gain_a[1] = SimpleFOC_P.Gain_Gain_e * SimpleFOC_B.Add1;\r\n    SimpleFOC_B.Gain_a[2] = SimpleFOC_P.Gain_Gain_e * SimpleFOC_B.Add2;\r\n\r\n    /* Gain: '<S58>/Gain1' */\r\n    Bias = SimpleFOC_P.Gain1_Gain_e * SimpleFOC_B.Gain_a[0];\r\n    SimpleFOC_B.Gain1_d[0] = Bias;\r\n\r\n    /* Sum: '<S58>/Sum' incorporates:\r\n     *  Constant: '<S58>/Constant4'\r\n     */\r\n    Bias += SimpleFOC_P.Constant4_Value_lq;\r\n    SimpleFOC_B.PWM_Duty_Cycles[0] = Bias;\r\n\r\n    /* DataTypeConversion: '<S57>/Data Type Conversion1' */\r\n    SimpleFOC_B.DataTypeConversion1_h[0] = (real32_T)Bias;\r\n\r\n    /* Saturate: '<S173>/Saturation2' */\r\n    u0 = SimpleFOC_B.DataTypeConversion1_h[0];\r\n    if (u0 > SimpleFOC_P.Saturation2_UpperSat) {\r\n      u0 = SimpleFOC_P.Saturation2_UpperSat;\r\n    } else if (u0 < SimpleFOC_P.Saturation2_LowerSat) {\r\n      u0 = SimpleFOC_P.Saturation2_LowerSat;\r\n    }\r\n\r\n    /* Saturate: '<S173>/Saturation2' */\r\n    SimpleFOC_B.Saturation2[0] = u0;\r\n\r\n    /* Gain: '<S58>/Gain1' */\r\n    Bias = SimpleFOC_P.Gain1_Gain_e * SimpleFOC_B.Gain_a[1];\r\n    SimpleFOC_B.Gain1_d[1] = Bias;\r\n\r\n    /* Sum: '<S58>/Sum' incorporates:\r\n     *  Constant: '<S58>/Constant4'\r\n     */\r\n    Bias += SimpleFOC_P.Constant4_Value_lq;\r\n    SimpleFOC_B.PWM_Duty_Cycles[1] = Bias;\r\n\r\n    /* DataTypeConversion: '<S57>/Data Type Conversion1' */\r\n    SimpleFOC_B.DataTypeConversion1_h[1] = (real32_T)Bias;\r\n\r\n    /* Saturate: '<S173>/Saturation2' */\r\n    u0 = SimpleFOC_B.DataTypeConversion1_h[1];\r\n    if (u0 > SimpleFOC_P.Saturation2_UpperSat) {\r\n      u0 = SimpleFOC_P.Saturation2_UpperSat;\r\n    } else if (u0 < SimpleFOC_P.Saturation2_LowerSat) {\r\n      u0 = SimpleFOC_P.Saturation2_LowerSat;\r\n    }\r\n\r\n    /* Saturate: '<S173>/Saturation2' */\r\n    SimpleFOC_B.Saturation2[1] = u0;\r\n\r\n    /* Gain: '<S58>/Gain1' */\r\n    Bias = SimpleFOC_P.Gain1_Gain_e * SimpleFOC_B.Gain_a[2];\r\n    SimpleFOC_B.Gain1_d[2] = Bias;\r\n\r\n    /* Sum: '<S58>/Sum' incorporates:\r\n     *  Constant: '<S58>/Constant4'\r\n     */\r\n    Bias += SimpleFOC_P.Constant4_Value_lq;\r\n    SimpleFOC_B.PWM_Duty_Cycles[2] = Bias;\r\n\r\n    /* DataTypeConversion: '<S57>/Data Type Conversion1' */\r\n    SimpleFOC_B.DataTypeConversion1_h[2] = (real32_T)Bias;\r\n\r\n    /* Saturate: '<S173>/Saturation2' */\r\n    u0 = SimpleFOC_B.DataTypeConversion1_h[2];\r\n    if (u0 > SimpleFOC_P.Saturation2_UpperSat) {\r\n      u0 = SimpleFOC_P.Saturation2_UpperSat;\r\n    } else if (u0 < SimpleFOC_P.Saturation2_LowerSat) {\r\n      u0 = SimpleFOC_P.Saturation2_LowerSat;\r\n    }\r\n\r\n    /* Saturate: '<S173>/Saturation2' */\r\n    SimpleFOC_B.Saturation2[2] = u0;\r\n\r\n    /* Sum: '<S173>/Sum' */\r\n    SimpleFOC_B.Sum_f = (SimpleFOC_B.Saturation2[1] + SimpleFOC_B.Saturation2[2])\r\n      + SimpleFOC_B.Saturation2[0];\r\n\r\n    /* Gain: '<S173>/Gain' */\r\n    SimpleFOC_B.Gain_i = SimpleFOC_P.Gain_Gain_i * SimpleFOC_B.Sum_f;\r\n\r\n    /* Sum: '<S173>/Sum1' */\r\n    SimpleFOC_B.Sum1_l = SimpleFOC_B.Saturation2[0] - SimpleFOC_B.Gain_i;\r\n\r\n    /* Sum: '<S173>/Sum2' */\r\n    SimpleFOC_B.Sum2_f = SimpleFOC_B.Saturation2[1] - SimpleFOC_B.Gain_i;\r\n\r\n    /* Sum: '<S173>/Sum3' */\r\n    SimpleFOC_B.Sum3_c = SimpleFOC_B.Saturation2[2] - SimpleFOC_B.Gain_i;\r\n\r\n    /* Switch: '<S173>/Switch' incorporates:\r\n     *  Constant: '<S2>/12V'\r\n     */\r\n    if (SimpleFOC_P.Initial.InverterVoltage >= SimpleFOC_P.Switch_Threshold_j) {\r\n      /* Switch: '<S173>/Switch' */\r\n      SimpleFOC_B.Switch_k = SimpleFOC_P.Initial.InverterVoltage;\r\n    } else {\r\n      /* Switch: '<S173>/Switch' incorporates:\r\n       *  Constant: '<S173>/Constant'\r\n       */\r\n      SimpleFOC_B.Switch_k = SimpleFOC_P.Constant_Value_m;\r\n    }\r\n\r\n    /* End of Switch: '<S173>/Switch' */\r\n\r\n    /* Product: '<S173>/Product' */\r\n    SimpleFOC_B.Product_l[0] = SimpleFOC_B.Sum1_l * SimpleFOC_B.Switch_k;\r\n    SimpleFOC_B.Product_l[1] = SimpleFOC_B.Sum2_f * SimpleFOC_B.Switch_k;\r\n    SimpleFOC_B.Product_l[2] = SimpleFOC_B.Sum3_c * SimpleFOC_B.Switch_k;\r\n  }\r\n\r\n  /* Gain: '<S1>/Rs' */\r\n  Bias = SimpleFOC_P.BLDC_Rs * SimpleFOC_B.MatrixMultiply2[0];\r\n  SimpleFOC_B.Rs[0] = Bias;\r\n\r\n  /* Sum: '<S1>/Subtract' */\r\n  SimpleFOC_B.Subtract[0] = SimpleFOC_B.Product_l[0] - Bias;\r\n\r\n  /* Gain: '<S1>/Rs' */\r\n  Bias = SimpleFOC_P.BLDC_Rs * SimpleFOC_B.MatrixMultiply2[1];\r\n  SimpleFOC_B.Rs[1] = Bias;\r\n\r\n  /* Sum: '<S1>/Subtract' */\r\n  SimpleFOC_B.Subtract[1] = SimpleFOC_B.Product_l[1] - Bias;\r\n\r\n  /* Gain: '<S1>/Rs' */\r\n  Bias = SimpleFOC_P.BLDC_Rs * SimpleFOC_B.MatrixMultiply2[2];\r\n  SimpleFOC_B.Rs[2] = Bias;\r\n\r\n  /* Sum: '<S1>/Subtract' */\r\n  SimpleFOC_B.Subtract[2] = SimpleFOC_B.Product_l[2] - Bias;\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* Step: '<Root>/Torque Setpoint' */\r\n    Bias = (((SimpleFOC_M->Timing.clockTick1+SimpleFOC_M->Timing.clockTickH1*\r\n              4294967296.0)) * 2.5E-6);\r\n    if (Bias < SimpleFOC_P.TorqueSetpoint_Time) {\r\n      /* Step: '<Root>/Torque Setpoint' */\r\n      SimpleFOC_B.TorqueSetpoint = SimpleFOC_P.Initial.Torque;\r\n    } else {\r\n      /* Step: '<Root>/Torque Setpoint' */\r\n      SimpleFOC_B.TorqueSetpoint = SimpleFOC_P.TorqueSetpoint_YFinal;\r\n    }\r\n\r\n    /* End of Step: '<Root>/Torque Setpoint' */\r\n\r\n    /* DataTypeConversion: '<S3>/Data Type Conversion2' */\r\n    SimpleFOC_B.DataTypeConversion2 = (real32_T)SimpleFOC_B.TorqueSetpoint;\r\n\r\n    /* Product: '<S188>/Product' incorporates:\r\n     *  Constant: '<S188>/Filter_Constant'\r\n     */\r\n    SimpleFOC_B.Product_h = SimpleFOC_B.DataTypeConversion2 *\r\n      SimpleFOC_P.Filter_Constant_Value;\r\n\r\n    /* UnitDelay: '<S188>/Unit Delay' */\r\n    SimpleFOC_B.UnitDelay = SimpleFOC_DW.UnitDelay_DSTATE;\r\n\r\n    /* Product: '<S188>/Product1' incorporates:\r\n     *  Constant: '<S188>/One'\r\n     */\r\n    SimpleFOC_B.Product1_b = SimpleFOC_P.One_Value * SimpleFOC_B.UnitDelay;\r\n\r\n    /* Sum: '<S188>/Add1' */\r\n    SimpleFOC_B.Add1_n = SimpleFOC_B.Product_h + SimpleFOC_B.Product1_b;\r\n\r\n    /* Constant: '<S8>/Speed0' */\r\n    SimpleFOC_B.Speed0 = SimpleFOC_P.BLDC_Omega_init;\r\n  }\r\n\r\n  /* Integrator: '<S14>/Integrator' */\r\n  if (SimpleFOC_DW.Integrator_IWORK_a != 0) {\r\n    SimpleFOC_X.Integrator_CSTATE_c = SimpleFOC_B.Speed0;\r\n  }\r\n\r\n  /* Integrator: '<S14>/Integrator' */\r\n  SimpleFOC_B.Integrator_h = SimpleFOC_X.Integrator_CSTATE_c;\r\n\r\n  /* Switch: '<S8>/Trq_Or_Spd' incorporates:\r\n   *  Constant: '<S8>/Constant3'\r\n   */\r\n  if (SimpleFOC_P.BLDC_MechInput > SimpleFOC_P.Trq_Or_Spd_Threshold) {\r\n    /* Switch: '<S8>/Trq_Or_Spd' */\r\n    SimpleFOC_B.Trq_Or_Spd = SimpleFOC_B.Add1_n;\r\n  } else {\r\n    /* Switch: '<S8>/Trq_Or_Spd' */\r\n    SimpleFOC_B.Trq_Or_Spd = SimpleFOC_B.Integrator_h;\r\n  }\r\n\r\n  /* End of Switch: '<S8>/Trq_Or_Spd' */\r\n\r\n  /* Gain: '<S1>/pole-pair' */\r\n  SimpleFOC_B.polepair = SimpleFOC_P.BLDC_p * SimpleFOC_B.Trq_Or_Spd;\r\n\r\n  /* Product: '<S1>/Product' */\r\n  Bias = SimpleFOC_B.Max_Lampda_PM_rate[0] * SimpleFOC_B.polepair;\r\n  SimpleFOC_B.Product_m[0] = Bias;\r\n\r\n  /* Sum: '<S1>/Subtract1' */\r\n  SimpleFOC_B.Subtract1[0] = SimpleFOC_B.Subtract[0] - Bias;\r\n\r\n  /* Product: '<S1>/Product' */\r\n  Bias = SimpleFOC_B.Max_Lampda_PM_rate[1] * SimpleFOC_B.polepair;\r\n  SimpleFOC_B.Product_m[1] = Bias;\r\n\r\n  /* Sum: '<S1>/Subtract1' */\r\n  SimpleFOC_B.Subtract1[1] = SimpleFOC_B.Subtract[1] - Bias;\r\n\r\n  /* Product: '<S1>/Product' */\r\n  Bias = SimpleFOC_B.Max_Lampda_PM_rate[2] * SimpleFOC_B.polepair;\r\n  SimpleFOC_B.Product_m[2] = Bias;\r\n\r\n  /* Sum: '<S1>/Subtract1' */\r\n  SimpleFOC_B.Subtract1[2] = SimpleFOC_B.Subtract[2] - Bias;\r\n\r\n  /* Product: '<S1>/MatrixMultiply' incorporates:\r\n   *  Gain: '<S6>/Gain1'\r\n   *  Product: '<S4>/MatrixMultiply2'\r\n   */\r\n  tmp_5 = &SimpleFOC_B.Gain1_i[0];\r\n  cosOut = SimpleFOC_B.Subtract1[0];\r\n  tmp_3 = SimpleFOC_B.Subtract1[1];\r\n  tmp_1 = SimpleFOC_B.Subtract1[2];\r\n  for (i = 0; i < 3; i++) {\r\n    tmp = tmp_5[i] * cosOut;\r\n    tmp += tmp_5[i + 3] * tmp_3;\r\n    tmp += tmp_5[i + 6] * tmp_1;\r\n\r\n    /* Product: '<S1>/MatrixMultiply' */\r\n    SimpleFOC_B.MatrixMultiply_g[i] = tmp;\r\n  }\r\n\r\n  /* Product: '<S8>/Product' incorporates:\r\n   *  Constant: '<S8>/Viscous'\r\n   */\r\n  SimpleFOC_B.Product_j = SimpleFOC_P.BLDC_B * SimpleFOC_B.Trq_Or_Spd;\r\n\r\n  /* Sum: '<S8>/Subtract' incorporates:\r\n   *  Constant: '<S8>/FrictionT'\r\n   */\r\n  SimpleFOC_B.Subtract_k = ((SimpleFOC_B.Add_i - SimpleFOC_B.Add1_n) -\r\n    SimpleFOC_P.BLDC_F) - SimpleFOC_B.Product_j;\r\n\r\n  /* Gain: '<S8>/1//J' */\r\n  cosOut = 1.0 / SimpleFOC_P.BLDC_J;\r\n\r\n  /* Gain: '<S8>/1//J' */\r\n  SimpleFOC_B.uJ = cosOut * SimpleFOC_B.Subtract_k;\r\n\r\n  /* Product: '<S16>/Divide1' incorporates:\r\n   *  Constant: '<S16>/Ld'\r\n   */\r\n  SimpleFOC_B.Divide1 = SimpleFOC_B.MatrixMultiply_g[0] / SimpleFOC_P.BLDC_Ld;\r\n\r\n  /* Product: '<S16>/Divide2' incorporates:\r\n   *  Constant: '<S16>/Ld'\r\n   */\r\n  SimpleFOC_B.Divide2 = SimpleFOC_B.polepair / SimpleFOC_P.BLDC_Ld;\r\n\r\n  /* Product: '<S16>/Product1' incorporates:\r\n   *  Constant: '<S16>/Lq'\r\n   */\r\n  SimpleFOC_B.Product1_g = SimpleFOC_P.BLDC_Lq * SimpleFOC_B.Integrator_a;\r\n\r\n  /* Product: '<S16>/Product2' */\r\n  SimpleFOC_B.Product2_a = SimpleFOC_B.Divide2 * SimpleFOC_B.Product1_g;\r\n\r\n  /* Sum: '<S16>/Add' */\r\n  SimpleFOC_B.Add_j = SimpleFOC_B.Divide1 + SimpleFOC_B.Product2_a;\r\n\r\n  /* Product: '<S17>/Divide1' incorporates:\r\n   *  Constant: '<S17>/Lq'\r\n   */\r\n  SimpleFOC_B.Divide1_a = SimpleFOC_B.MatrixMultiply_g[1] / SimpleFOC_P.BLDC_Lq;\r\n\r\n  /* Product: '<S17>/Divide2' incorporates:\r\n   *  Constant: '<S17>/Lq'\r\n   */\r\n  SimpleFOC_B.Divide2_e = SimpleFOC_B.polepair / SimpleFOC_P.BLDC_Lq;\r\n\r\n  /* Product: '<S17>/Product1' incorporates:\r\n   *  Constant: '<S17>/Ld'\r\n   */\r\n  SimpleFOC_B.Product1_l = SimpleFOC_P.BLDC_Ld * SimpleFOC_B.Integrator_d;\r\n\r\n  /* Product: '<S17>/Product2' */\r\n  SimpleFOC_B.Product2_m = SimpleFOC_B.Divide2_e * SimpleFOC_B.Product1_l;\r\n\r\n  /* Sum: '<S17>/Add' */\r\n  SimpleFOC_B.Add_c = SimpleFOC_B.Divide1_a - SimpleFOC_B.Product2_m;\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* Gain: '<S104>/Integral Gain' */\r\n    SimpleFOC_B.IntegralGain = SimpleFOC_P.Ki_id * SimpleFOC_B.ErrorDC;\r\n\r\n    /* Gain: '<S152>/Integral Gain' */\r\n    SimpleFOC_B.IntegralGain_b = SimpleFOC_P.Ki_iq * SimpleFOC_B.ErrorQC;\r\n  }\r\n\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* Matfile logging */\r\n    rt_UpdateTXYLogVars(SimpleFOC_M->rtwLogInfo, (SimpleFOC_M->Timing.t));\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* Update for Integrator: '<S15>/Integrator' */\r\n    SimpleFOC_DW.Integrator_IWORK = 0;\r\n\r\n    /* Update for Integrator: '<S19>/Integrator' */\r\n    SimpleFOC_DW.Integrator_IWORK_n = 0;\r\n\r\n    /* Update for Integrator: '<S21>/Integrator' */\r\n    SimpleFOC_DW.Integrator_IWORK_o = 0;\r\n    if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n      /* Update for UnitDelay generated from: '<Root>/Unit Delay' */\r\n      SimpleFOC_DW.UnitDelay_1_DSTATE = SimpleFOC_B.MatrixMultiply2[0];\r\n\r\n      /* Update for UnitDelay generated from: '<Root>/Unit Delay' */\r\n      SimpleFOC_DW.UnitDelay_2_DSTATE = SimpleFOC_B.MatrixMultiply2[1];\r\n\r\n      /* Update for UnitDelay generated from: '<Root>/Unit Delay' */\r\n      SimpleFOC_DW.UnitDelay_9_DSTATE = SimpleFOC_B.Integrator;\r\n\r\n      /* Update for UnitDelay: '<S188>/Unit Delay' */\r\n      SimpleFOC_DW.UnitDelay_DSTATE = SimpleFOC_B.Add1_n;\r\n    }\r\n\r\n    /* Update for Integrator: '<S14>/Integrator' */\r\n    SimpleFOC_DW.Integrator_IWORK_a = 0;\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  if (rtmIsMajorTimeStep(SimpleFOC_M)) {\r\n    /* signal main to stop simulation */\r\n    {                                  /* Sample time: [0.0s, 0.0s] */\r\n      if ((rtmGetTFinal(SimpleFOC_M)!=-1) &&\r\n          !((rtmGetTFinal(SimpleFOC_M)-(((SimpleFOC_M->Timing.clockTick1+\r\n               SimpleFOC_M->Timing.clockTickH1* 4294967296.0)) * 2.5E-6)) >\r\n            (((SimpleFOC_M->Timing.clockTick1+SimpleFOC_M->Timing.clockTickH1*\r\n               4294967296.0)) * 2.5E-6) * (DBL_EPSILON))) {\r\n        rtmSetErrorStatus(SimpleFOC_M, \"Simulation finished\");\r\n      }\r\n    }\r\n\r\n    rt_ertODEUpdateContinuousStates(&SimpleFOC_M->solverInfo);\r\n\r\n    /* Update absolute time for base rate */\r\n    /* The \"clockTick0\" counts the number of times the code of this task has\r\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n     * overflow during the application lifespan selected.\r\n     * Timer of this task consists of two 32 bit unsigned integers.\r\n     * The two integers represent the low bits Timing.clockTick0 and the high bits\r\n     * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\r\n     */\r\n    if (!(++SimpleFOC_M->Timing.clockTick0)) {\r\n      ++SimpleFOC_M->Timing.clockTickH0;\r\n    }\r\n\r\n    SimpleFOC_M->Timing.t[0] = rtsiGetSolverStopTime(&SimpleFOC_M->solverInfo);\r\n\r\n    {\r\n      /* Update absolute timer for sample time: [2.5E-6s, 0.0s] */\r\n      /* The \"clockTick1\" counts the number of times the code of this task has\r\n       * been executed. The resolution of this integer timer is 2.5E-6, which is the step size\r\n       * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n       * application lifespan selected.\r\n       * Timer of this task consists of two 32 bit unsigned integers.\r\n       * The two integers represent the low bits Timing.clockTick1 and the high bits\r\n       * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\r\n       */\r\n      SimpleFOC_M->Timing.clockTick1++;\r\n      if (!SimpleFOC_M->Timing.clockTick1) {\r\n        SimpleFOC_M->Timing.clockTickH1++;\r\n      }\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n}\r\n\r\n/* Derivatives for root system: '<Root>' */\r\nvoid SimpleFOC_derivatives(void)\r\n{\r\n  XDot_SimpleFOC_T *_rtXdot;\r\n  _rtXdot = ((XDot_SimpleFOC_T *) SimpleFOC_M->derivs);\r\n\r\n  /* Derivatives for Integrator: '<S15>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE = SimpleFOC_B.Trq_Or_Spd;\r\n\r\n  /* Derivatives for Integrator: '<S19>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE_l = SimpleFOC_B.Add_j;\r\n\r\n  /* Derivatives for Integrator: '<S21>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE_g = SimpleFOC_B.Add_c;\r\n\r\n  /* Derivatives for Integrator: '<S155>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE_lo = SimpleFOC_B.IntegralGain_b;\r\n\r\n  /* Derivatives for Integrator: '<S107>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE_p = SimpleFOC_B.IntegralGain;\r\n\r\n  /* Derivatives for Integrator: '<S14>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE_c = SimpleFOC_B.uJ;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid SimpleFOC_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  /* initialize real-time model */\r\n  (void) memset((void *)SimpleFOC_M, 0,\r\n                sizeof(RT_MODEL_SimpleFOC_T));\r\n\r\n  {\r\n    /* Setup solver object */\r\n    rtsiSetSimTimeStepPtr(&SimpleFOC_M->solverInfo,\r\n                          &SimpleFOC_M->Timing.simTimeStep);\r\n    rtsiSetTPtr(&SimpleFOC_M->solverInfo, &rtmGetTPtr(SimpleFOC_M));\r\n    rtsiSetStepSizePtr(&SimpleFOC_M->solverInfo, &SimpleFOC_M->Timing.stepSize0);\r\n    rtsiSetdXPtr(&SimpleFOC_M->solverInfo, &SimpleFOC_M->derivs);\r\n    rtsiSetContStatesPtr(&SimpleFOC_M->solverInfo, (real_T **)\r\n                         &SimpleFOC_M->contStates);\r\n    rtsiSetNumContStatesPtr(&SimpleFOC_M->solverInfo,\r\n      &SimpleFOC_M->Sizes.numContStates);\r\n    rtsiSetNumPeriodicContStatesPtr(&SimpleFOC_M->solverInfo,\r\n      &SimpleFOC_M->Sizes.numPeriodicContStates);\r\n    rtsiSetPeriodicContStateIndicesPtr(&SimpleFOC_M->solverInfo,\r\n      &SimpleFOC_M->periodicContStateIndices);\r\n    rtsiSetPeriodicContStateRangesPtr(&SimpleFOC_M->solverInfo,\r\n      &SimpleFOC_M->periodicContStateRanges);\r\n    rtsiSetErrorStatusPtr(&SimpleFOC_M->solverInfo, (&rtmGetErrorStatus\r\n      (SimpleFOC_M)));\r\n    rtsiSetRTModelPtr(&SimpleFOC_M->solverInfo, SimpleFOC_M);\r\n  }\r\n\r\n  rtsiSetSimTimeStep(&SimpleFOC_M->solverInfo, MAJOR_TIME_STEP);\r\n  SimpleFOC_M->intgData.y = SimpleFOC_M->odeY;\r\n  SimpleFOC_M->intgData.f[0] = SimpleFOC_M->odeF[0];\r\n  SimpleFOC_M->intgData.f[1] = SimpleFOC_M->odeF[1];\r\n  SimpleFOC_M->intgData.f[2] = SimpleFOC_M->odeF[2];\r\n  SimpleFOC_M->contStates = ((X_SimpleFOC_T *) &SimpleFOC_X);\r\n  rtsiSetSolverData(&SimpleFOC_M->solverInfo, (void *)&SimpleFOC_M->intgData);\r\n  rtsiSetIsMinorTimeStepWithModeChange(&SimpleFOC_M->solverInfo, false);\r\n  rtsiSetSolverName(&SimpleFOC_M->solverInfo,\"ode3\");\r\n  rtmSetTPtr(SimpleFOC_M, &SimpleFOC_M->Timing.tArray[0]);\r\n  rtmSetTFinal(SimpleFOC_M, 3.0000000000000004);\r\n  SimpleFOC_M->Timing.stepSize0 = 2.5E-6;\r\n  rtmSetFirstInitCond(SimpleFOC_M, 1);\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    static RTWLogInfo rt_DataLoggingInfo;\r\n    rt_DataLoggingInfo.loggingInterval = (NULL);\r\n    SimpleFOC_M->rtwLogInfo = &rt_DataLoggingInfo;\r\n  }\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    rtliSetLogXSignalInfo(SimpleFOC_M->rtwLogInfo, (NULL));\r\n    rtliSetLogXSignalPtrs(SimpleFOC_M->rtwLogInfo, (NULL));\r\n    rtliSetLogT(SimpleFOC_M->rtwLogInfo, \"tout\");\r\n    rtliSetLogX(SimpleFOC_M->rtwLogInfo, \"\");\r\n    rtliSetLogXFinal(SimpleFOC_M->rtwLogInfo, \"\");\r\n    rtliSetLogVarNameModifier(SimpleFOC_M->rtwLogInfo, \"rt_\");\r\n    rtliSetLogFormat(SimpleFOC_M->rtwLogInfo, 4);\r\n    rtliSetLogMaxRows(SimpleFOC_M->rtwLogInfo, 0);\r\n    rtliSetLogDecimation(SimpleFOC_M->rtwLogInfo, 1);\r\n    rtliSetLogY(SimpleFOC_M->rtwLogInfo, \"\");\r\n    rtliSetLogYSignalInfo(SimpleFOC_M->rtwLogInfo, (NULL));\r\n    rtliSetLogYSignalPtrs(SimpleFOC_M->rtwLogInfo, (NULL));\r\n  }\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &SimpleFOC_B), 0,\r\n                sizeof(B_SimpleFOC_T));\r\n\r\n  /* states (continuous) */\r\n  {\r\n    (void) memset((void *)&SimpleFOC_X, 0,\r\n                  sizeof(X_SimpleFOC_T));\r\n  }\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&SimpleFOC_DW, 0,\r\n                sizeof(DW_SimpleFOC_T));\r\n\r\n  /* Matfile logging */\r\n  rt_StartDataLoggingWithStartTime(SimpleFOC_M->rtwLogInfo, 0.0, rtmGetTFinal\r\n    (SimpleFOC_M), SimpleFOC_M->Timing.stepSize0, (&rtmGetErrorStatus\r\n    (SimpleFOC_M)));\r\n\r\n  /* Start for Constant: '<S8>/Pos0' */\r\n  SimpleFOC_B.Pos0 = SimpleFOC_P.Initial.bldc.ITheta;\r\n\r\n  /* Start for Constant: '<S16>/Id_0' */\r\n  SimpleFOC_B.Id_0 = SimpleFOC_P.Initial.bldc.ILd;\r\n\r\n  /* Start for Constant: '<S17>/Id_0' */\r\n  SimpleFOC_B.Id_0_e = SimpleFOC_P.Initial.bldc.ILq;\r\n\r\n  /* Start for If: '<S181>/If' */\r\n  SimpleFOC_DW.If_ActiveSubsystem = -1;\r\n\r\n  /* Start for If: '<S52>/If' */\r\n  SimpleFOC_DW.If_ActiveSubsystem_p = -1;\r\n\r\n  /* Start for Constant: '<S8>/Speed0' */\r\n  SimpleFOC_B.Speed0 = SimpleFOC_P.BLDC_Omega_init;\r\n\r\n  /* InitializeConditions for Integrator: '<S15>/Integrator' incorporates:\r\n   *  Integrator: '<S19>/Integrator'\r\n   */\r\n  if (rtmIsFirstInitCond(SimpleFOC_M)) {\r\n    SimpleFOC_X.Integrator_CSTATE = 0.0;\r\n    SimpleFOC_X.Integrator_CSTATE_l = 0.0;\r\n  }\r\n\r\n  SimpleFOC_DW.Integrator_IWORK = 1;\r\n\r\n  /* End of InitializeConditions for Integrator: '<S15>/Integrator' */\r\n\r\n  /* InitializeConditions for Integrator: '<S19>/Integrator' */\r\n  SimpleFOC_DW.Integrator_IWORK_n = 1;\r\n\r\n  /* InitializeConditions for Integrator: '<S21>/Integrator' incorporates:\r\n   *  Integrator: '<S14>/Integrator'\r\n   */\r\n  if (rtmIsFirstInitCond(SimpleFOC_M)) {\r\n    SimpleFOC_X.Integrator_CSTATE_g = 0.0;\r\n    SimpleFOC_X.Integrator_CSTATE_c = 20.0;\r\n  }\r\n\r\n  SimpleFOC_DW.Integrator_IWORK_o = 1;\r\n\r\n  /* End of InitializeConditions for Integrator: '<S21>/Integrator' */\r\n\r\n  /* InitializeConditions for UnitDelay generated from: '<Root>/Unit Delay' */\r\n  SimpleFOC_DW.UnitDelay_1_DSTATE = SimpleFOC_P.UnitDelay_1_InitialCondition;\r\n\r\n  /* InitializeConditions for UnitDelay generated from: '<Root>/Unit Delay' */\r\n  SimpleFOC_DW.UnitDelay_2_DSTATE = SimpleFOC_P.UnitDelay_2_InitialCondition;\r\n\r\n  /* InitializeConditions for UnitDelay generated from: '<Root>/Unit Delay' */\r\n  SimpleFOC_DW.UnitDelay_9_DSTATE = SimpleFOC_P.UnitDelay_9_InitialCondition;\r\n\r\n  /* InitializeConditions for Integrator: '<S155>/Integrator' */\r\n  SimpleFOC_X.Integrator_CSTATE_lo = SimpleFOC_P.DiscreteQuadratureCurrentContro;\r\n\r\n  /* InitializeConditions for Integrator: '<S107>/Integrator' */\r\n  SimpleFOC_X.Integrator_CSTATE_p = SimpleFOC_P.DiscreteDirectCurrentController;\r\n\r\n  /* InitializeConditions for UnitDelay: '<S188>/Unit Delay' */\r\n  SimpleFOC_DW.UnitDelay_DSTATE = SimpleFOC_P.UnitDelay_InitialCondition;\r\n\r\n  /* InitializeConditions for Integrator: '<S14>/Integrator' */\r\n  SimpleFOC_DW.Integrator_IWORK_a = 1;\r\n\r\n  /* set \"at time zero\" to false */\r\n  if (rtmIsFirstInitCond(SimpleFOC_M)) {\r\n    rtmSetFirstInitCond(SimpleFOC_M, 0);\r\n  }\r\n}\r\n\r\n/* Model terminate function */\r\nvoid SimpleFOC_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n"},{"name":"SimpleFOC.h","type":"header","group":"model","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * SimpleFOC.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_SimpleFOC_h_\r\n#define RTW_HEADER_SimpleFOC_h_\r\n#ifndef SimpleFOC_COMMON_INCLUDES_\r\n#define SimpleFOC_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"rt_logging.h\"\r\n#endif                                 /* SimpleFOC_COMMON_INCLUDES_ */\r\n\r\n#include \"SimpleFOC_types.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <float.h>\r\n#include <string.h>\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetContStateDisabled\r\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\r\n#endif\r\n\r\n#ifndef rtmSetContStateDisabled\r\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContStates\r\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\r\n#endif\r\n\r\n#ifndef rtmSetContStates\r\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\r\n#endif\r\n\r\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\r\n#endif\r\n\r\n#ifndef rtmGetDerivCacheNeedsReset\r\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetDerivCacheNeedsReset\r\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetFinalTime\r\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetIntgData\r\n#define rtmGetIntgData(rtm)            ((rtm)->intgData)\r\n#endif\r\n\r\n#ifndef rtmSetIntgData\r\n#define rtmSetIntgData(rtm, val)       ((rtm)->intgData = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeF\r\n#define rtmGetOdeF(rtm)                ((rtm)->odeF)\r\n#endif\r\n\r\n#ifndef rtmSetOdeF\r\n#define rtmSetOdeF(rtm, val)           ((rtm)->odeF = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeY\r\n#define rtmGetOdeY(rtm)                ((rtm)->odeY)\r\n#endif\r\n\r\n#ifndef rtmSetOdeY\r\n#define rtmSetOdeY(rtm, val)           ((rtm)->odeY = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateIndices\r\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateIndices\r\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateRanges\r\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateRanges\r\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\r\n#endif\r\n\r\n#ifndef rtmGetRTWLogInfo\r\n#define rtmGetRTWLogInfo(rtm)          ((rtm)->rtwLogInfo)\r\n#endif\r\n\r\n#ifndef rtmGetZCCacheNeedsReset\r\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetZCCacheNeedsReset\r\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetdX\r\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\r\n#endif\r\n\r\n#ifndef rtmSetdX\r\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\r\n#endif\r\n\r\n#ifndef rtmGetTFinal\r\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T Pos0;                         /* '<S8>/Pos0' */\r\n  real_T Integrator;                   /* '<S15>/Integrator' */\r\n  real_T polepair1;                    /* '<S7>/pole-pair1' */\r\n  real_T Mod;                          /* '<S7>/Mod' */\r\n  real_T SinCos_o1;                    /* '<S5>/SinCos' */\r\n  real_T SinCos_o2;                    /* '<S5>/SinCos' */\r\n  real_T TmpSignalConversionAtMatrixMult[2];\r\n  real_T MatrixMultiply[2];            /* '<S5>/MatrixMultiply' */\r\n  real_T MatrixMultiply1[2];           /* '<S5>/MatrixMultiply1' */\r\n  real_T MatrixConcatenate1[9];        /* '<S5>/Matrix Concatenate1' */\r\n  real_T Id_0;                         /* '<S16>/Id_0' */\r\n  real_T Integrator_d;                 /* '<S19>/Integrator' */\r\n  real_T Id_0_e;                       /* '<S17>/Id_0' */\r\n  real_T Integrator_a;                 /* '<S21>/Integrator' */\r\n  real_T TmpSignalConversionAtMatrixMu_m[3];\r\n  real_T MatrixMultiply2[3];           /* '<S4>/MatrixMultiply2' */\r\n  real_T Bias3;                        /* '<S24>/Bias3' */\r\n  real_T Mod_i;                        /* '<S24>/Mod' */\r\n  real_T Switch;                       /* '<S24>/Switch' */\r\n  real_T Switch1;                      /* '<S24>/Switch1' */\r\n  real_T Switch2;                      /* '<S24>/Switch2' */\r\n  real_T Switch3;                      /* '<S24>/Switch3' */\r\n  real_T Switch4;                      /* '<S24>/Switch4' */\r\n  real_T Add;                          /* '<S24>/Add' */\r\n  real_T Bias3_c;                      /* '<S25>/Bias3' */\r\n  real_T Mod_f;                        /* '<S25>/Mod' */\r\n  real_T Switch_d;                     /* '<S25>/Switch' */\r\n  real_T Switch1_k;                    /* '<S25>/Switch1' */\r\n  real_T Switch2_j;                    /* '<S25>/Switch2' */\r\n  real_T Switch3_j;                    /* '<S25>/Switch3' */\r\n  real_T Switch4_g;                    /* '<S25>/Switch4' */\r\n  real_T Add_h;                        /* '<S25>/Add' */\r\n  real_T Bias3_n;                      /* '<S26>/Bias3' */\r\n  real_T Mod_a;                        /* '<S26>/Mod' */\r\n  real_T Switch_g;                     /* '<S26>/Switch' */\r\n  real_T Switch1_j;                    /* '<S26>/Switch1' */\r\n  real_T Switch2_g;                    /* '<S26>/Switch2' */\r\n  real_T Switch3_k;                    /* '<S26>/Switch3' */\r\n  real_T Switch4_h;                    /* '<S26>/Switch4' */\r\n  real_T Add_l;                        /* '<S26>/Add' */\r\n  real_T Max_Lampda_PM_rate[3];        /* '<S11>/Max_Lampda_PM_rate' */\r\n  real_T Product2[3];                  /* '<S4>/Product2' */\r\n  real_T SumofElements;                /* '<S4>/Sum of Elements' */\r\n  real_T Gain1;                        /* '<S4>/Gain1' */\r\n  real_T Product;                      /* '<S4>/Product' */\r\n  real_T Subtract2;                    /* '<S4>/Subtract2' */\r\n  real_T Product1;                     /* '<S4>/Product1' */\r\n  real_T Gain3;                        /* '<S4>/Gain3' */\r\n  real_T Add_i;                        /* '<S4>/Add' */\r\n  real_T SinCos_o1_p;                  /* '<S6>/SinCos' */\r\n  real_T SinCos_o2_j;                  /* '<S6>/SinCos' */\r\n  real_T Gain;                         /* '<S6>/Gain' */\r\n  real_T TmpSignalConversionAtMatrixMu_a[2];\r\n  real_T MatrixMultiply_c[2];          /* '<S6>/MatrixMultiply' */\r\n  real_T Gain2;                        /* '<S6>/Gain2' */\r\n  real_T MatrixMultiply1_c[2];         /* '<S6>/MatrixMultiply1' */\r\n  real_T Gain3_m;                      /* '<S6>/Gain3' */\r\n  real_T MatrixConcatenate1_h[9];      /* '<S6>/Matrix Concatenate1' */\r\n  real_T Gain1_i[9];                   /* '<S6>/Gain1' */\r\n  real_T IaStator;                     /* '<Root>/Unit Delay' */\r\n  real_T IbStator;                     /* '<Root>/Unit Delay' */\r\n  real_T MtrPos;                       /* '<Root>/Unit Delay' */\r\n  real_T convert_pu;                   /* '<S181>/convert_pu' */\r\n  real_T Merge;                        /* '<S181>/Merge' */\r\n  real_T indexing;                     /* '<S61>/indexing' */\r\n  real_T Lookup[4];                    /* '<S61>/Lookup' */\r\n  real_T Sum3;                         /* '<S180>/Sum3' */\r\n  real_T DataTypeConversion1;          /* '<S61>/Data Type Conversion1' */\r\n  real_T Sum2;                         /* '<S61>/Sum2' */\r\n  real_T Product_d;                    /* '<S180>/Product' */\r\n  real_T Sum4;                         /* '<S180>/Sum4' */\r\n  real_T Sum5;                         /* '<S180>/Sum5' */\r\n  real_T Product1_i;                   /* '<S180>/Product1' */\r\n  real_T Sum6;                         /* '<S180>/Sum6' */\r\n  real_T ErrorQC;                      /* '<S2>/Sum2' */\r\n  real_T ProportionalGain;             /* '<S160>/Proportional Gain' */\r\n  real_T Integrator_l;                 /* '<S155>/Integrator' */\r\n  real_T Sum;                          /* '<S164>/Sum' */\r\n  real_T ErrorDC;                      /* '<S2>/Sum1' */\r\n  real_T ProportionalGain_j;           /* '<S112>/Proportional Gain' */\r\n  real_T Integrator_g;                 /* '<S107>/Integrator' */\r\n  real_T Sum_d;                        /* '<S116>/Sum' */\r\n  real_T Switch_i;                     /* '<S64>/Switch' */\r\n  real_T Product_dk;                   /* '<S64>/Product' */\r\n  real_T Product_b;                    /* '<S65>/Product' */\r\n  real_T Product1_h;                   /* '<S65>/Product1' */\r\n  real_T Sum1;                         /* '<S65>/Sum1' */\r\n  real_T Merge_e[2];                   /* '<S52>/Merge' */\r\n  real_T one_by_two;                   /* '<S55>/one_by_two' */\r\n  real_T sqrt3_by_two;                 /* '<S55>/sqrt3_by_two' */\r\n  real_T add_b;                        /* '<S55>/add_b' */\r\n  real_T add_c;                        /* '<S55>/add_c' */\r\n  real_T Max;                          /* '<S177>/Max' */\r\n  real_T Min;                          /* '<S177>/Min' */\r\n  real_T Add_k;                        /* '<S177>/Add' */\r\n  real_T one_by_two_d;                 /* '<S177>/one_by_two' */\r\n  real_T Add3;                         /* '<S176>/Add3' */\r\n  real_T Add1;                         /* '<S176>/Add1' */\r\n  real_T Add2;                         /* '<S176>/Add2' */\r\n  real_T Gain_a[3];                    /* '<S176>/Gain' */\r\n  real_T Gain1_d[3];                   /* '<S58>/Gain1' */\r\n  real_T PWM_Duty_Cycles[3];           /* '<S58>/Sum' */\r\n  real_T Switch_k;                     /* '<S173>/Switch' */\r\n  real_T Product_l[3];                 /* '<S173>/Product' */\r\n  real_T Rs[3];                        /* '<S1>/Rs' */\r\n  real_T Subtract[3];                  /* '<S1>/Subtract' */\r\n  real_T TorqueSetpoint;               /* '<Root>/Torque Setpoint' */\r\n  real_T Speed0;                       /* '<S8>/Speed0' */\r\n  real_T Integrator_h;                 /* '<S14>/Integrator' */\r\n  real_T Trq_Or_Spd;                   /* '<S8>/Trq_Or_Spd' */\r\n  real_T polepair;                     /* '<S1>/pole-pair' */\r\n  real_T Product_m[3];                 /* '<S1>/Product' */\r\n  real_T Subtract1[3];                 /* '<S1>/Subtract1' */\r\n  real_T MatrixMultiply_g[3];          /* '<S1>/MatrixMultiply' */\r\n  real_T Product_j;                    /* '<S8>/Product' */\r\n  real_T Subtract_k;                   /* '<S8>/Subtract' */\r\n  real_T uJ;                           /* '<S8>/1//J' */\r\n  real_T Divide1;                      /* '<S16>/Divide1' */\r\n  real_T Divide2;                      /* '<S16>/Divide2' */\r\n  real_T Product1_g;                   /* '<S16>/Product1' */\r\n  real_T Product2_a;                   /* '<S16>/Product2' */\r\n  real_T Add_j;                        /* '<S16>/Add' */\r\n  real_T Divide1_a;                    /* '<S17>/Divide1' */\r\n  real_T Divide2_e;                    /* '<S17>/Divide2' */\r\n  real_T Product1_l;                   /* '<S17>/Product1' */\r\n  real_T Product2_m;                   /* '<S17>/Product2' */\r\n  real_T Add_c;                        /* '<S17>/Add' */\r\n  real_T IntegralGain;                 /* '<S104>/Integral Gain' */\r\n  real_T IntegralGain_b;               /* '<S152>/Integral Gain' */\r\n  real_T Convert_back;                 /* '<S184>/Convert_back' */\r\n  real_T Convert_back_k;               /* '<S183>/Convert_back' */\r\n  real_T bcos;                         /* '<S60>/bcos' */\r\n  real_T asin_d;                       /* '<S60>/asin' */\r\n  real_T sum_Qs;                       /* '<S60>/sum_Qs' */\r\n  real_T acos_f;                       /* '<S60>/acos' */\r\n  real_T bsin;                         /* '<S60>/bsin' */\r\n  real_T sum_Ds;                       /* '<S60>/sum_Ds' */\r\n  real_T Switch_a[2];                  /* '<S179>/Switch' */\r\n  real_T algDD_o1;\r\n  real_T algDD_o2;\r\n  real_T Unary_Minus;                  /* '<S179>/Unary_Minus' */\r\n  real_T qcos;                         /* '<S56>/qcos' */\r\n  real_T dsin;                         /* '<S56>/dsin' */\r\n  real_T sum_beta;                     /* '<S56>/sum_beta' */\r\n  real_T dcos;                         /* '<S56>/dcos' */\r\n  real_T qsin;                         /* '<S56>/qsin' */\r\n  real_T sum_alpha;                    /* '<S56>/sum_alpha' */\r\n  real_T Switch_m[2];                  /* '<S172>/Switch' */\r\n  real_T algDD_o1_c;\r\n  real_T algDD_o2_d;\r\n  real_T Unary_Minus_a;                /* '<S172>/Unary_Minus' */\r\n  real_T Product_b2[2];                /* '<S66>/Product' */\r\n  real_T SquareRoot;                   /* '<S66>/Square Root' */\r\n  real_T Switch_h;                     /* '<S66>/Switch' */\r\n  real_T Reciprocal;                   /* '<S66>/Reciprocal' */\r\n  real_T Switch_az[2];                 /* '<S63>/Switch' */\r\n  real_T Switch2_h;                    /* '<S73>/Switch2' */\r\n  real_T Product_p;                    /* '<S72>/Product' */\r\n  real_T Sum_m;                        /* '<S72>/Sum' */\r\n  real_T Product2_l;                   /* '<S72>/Product2' */\r\n  real_T Merge_o;                      /* '<S72>/Merge' */\r\n  real_T Gain_e;                       /* '<S72>/Gain' */\r\n  real_T Switch_l;                     /* '<S73>/Switch' */\r\n  real_T Switch1_d;                    /* '<S74>/Switch1' */\r\n  real_T Sqrt;                         /* '<S74>/Sqrt' */\r\n  real_T Gain_m;                       /* '<S74>/Gain' */\r\n  real_T a_plus_2b;                    /* '<S51>/a_plus_2b' */\r\n  real_T one_by_sqrt3;                 /* '<S51>/one_by_sqrt3' */\r\n  real_T algDD_o1_e;\r\n  real_T algDD_o2_h;\r\n  real_T Gain_g;                       /* '<S26>/Gain' */\r\n  real_T Bias1;                        /* '<S26>/Bias1' */\r\n  real_T Gain2_n;                      /* '<S26>/Gain2' */\r\n  real_T Bias2;                        /* '<S26>/Bias2' */\r\n  real_T Gain1_e;                      /* '<S26>/Gain1' */\r\n  real_T Bias;                         /* '<S26>/Bias' */\r\n  real_T Gain_h;                       /* '<S25>/Gain' */\r\n  real_T Bias1_p;                      /* '<S25>/Bias1' */\r\n  real_T Gain2_e;                      /* '<S25>/Gain2' */\r\n  real_T Bias2_k;                      /* '<S25>/Bias2' */\r\n  real_T Gain1_l;                      /* '<S25>/Gain1' */\r\n  real_T Bias_o;                       /* '<S25>/Bias' */\r\n  real_T Gain_n;                       /* '<S24>/Gain' */\r\n  real_T Bias1_m;                      /* '<S24>/Bias1' */\r\n  real_T Gain2_ng;                     /* '<S24>/Gain2' */\r\n  real_T Bias2_b;                      /* '<S24>/Bias2' */\r\n  real_T Gain1_k;                      /* '<S24>/Gain1' */\r\n  real_T Bias_k;                       /* '<S24>/Bias' */\r\n  uint32_T Sum_l[4];                   /* '<S61>/Sum' */\r\n  real32_T SPQC;                       /* '<S2>/Constant1' */\r\n  real32_T SPDC;                       /* '<S2>/Constant' */\r\n  real32_T DataTypeConversion1_h[3];   /* '<S57>/Data Type Conversion1' */\r\n  real32_T Saturation2[3];             /* '<S173>/Saturation2' */\r\n  real32_T Sum_f;                      /* '<S173>/Sum' */\r\n  real32_T Gain_i;                     /* '<S173>/Gain' */\r\n  real32_T Sum1_l;                     /* '<S173>/Sum1' */\r\n  real32_T Sum2_f;                     /* '<S173>/Sum2' */\r\n  real32_T Sum3_c;                     /* '<S173>/Sum3' */\r\n  real32_T DataTypeConversion2;        /* '<S3>/Data Type Conversion2' */\r\n  real32_T Product_h;                  /* '<S188>/Product' */\r\n  real32_T UnitDelay;                  /* '<S188>/Unit Delay' */\r\n  real32_T Product1_b;                 /* '<S188>/Product1' */\r\n  real32_T Add1_n;                     /* '<S188>/Add1' */\r\n  uint16_T Switch1_o;                  /* '<S64>/Switch1' */\r\n  uint16_T DataTypeConversion;         /* '<S181>/Data Type Conversion' */\r\n  uint16_T Get_Integer;                /* '<S61>/Get_Integer' */\r\n  uint16_T DataTypeConversion_d;       /* '<S62>/Data Type Conversion' */\r\n  uint16_T DataTypeConversion_j;       /* '<S72>/Data Type Conversion' */\r\n  int16_T Convert_uint16;              /* '<S184>/Convert_uint16' */\r\n  int16_T Convert_uint16_n;            /* '<S183>/Convert_uint16' */\r\n  boolean_T Compare;                   /* '<S27>/Compare' */\r\n  boolean_T Compare_n;                 /* '<S28>/Compare' */\r\n  boolean_T Compare_k;                 /* '<S29>/Compare' */\r\n  boolean_T AND;                       /* '<S24>/AND' */\r\n  boolean_T Compare_p;                 /* '<S30>/Compare' */\r\n  boolean_T Compare_c;                 /* '<S31>/Compare' */\r\n  boolean_T AND1;                      /* '<S24>/AND1' */\r\n  boolean_T Compare_m;                 /* '<S32>/Compare' */\r\n  boolean_T Compare_h;                 /* '<S33>/Compare' */\r\n  boolean_T AND3;                      /* '<S24>/AND3' */\r\n  boolean_T Compare_h4;                /* '<S34>/Compare' */\r\n  boolean_T Compare_cg;                /* '<S35>/Compare' */\r\n  boolean_T Compare_i;                 /* '<S36>/Compare' */\r\n  boolean_T Compare_nw;                /* '<S37>/Compare' */\r\n  boolean_T AND_n;                     /* '<S25>/AND' */\r\n  boolean_T Compare_hx;                /* '<S38>/Compare' */\r\n  boolean_T Compare_cy;                /* '<S39>/Compare' */\r\n  boolean_T AND1_j;                    /* '<S25>/AND1' */\r\n  boolean_T Compare_l;                 /* '<S40>/Compare' */\r\n  boolean_T Compare_b;                 /* '<S41>/Compare' */\r\n  boolean_T AND3_p;                    /* '<S25>/AND3' */\r\n  boolean_T Compare_hm;                /* '<S42>/Compare' */\r\n  boolean_T Compare_mi;                /* '<S43>/Compare' */\r\n  boolean_T Compare_he;                /* '<S44>/Compare' */\r\n  boolean_T Compare_hr;                /* '<S45>/Compare' */\r\n  boolean_T AND_nc;                    /* '<S26>/AND' */\r\n  boolean_T Compare_g;                 /* '<S46>/Compare' */\r\n  boolean_T Compare_pv;                /* '<S47>/Compare' */\r\n  boolean_T AND1_i;                    /* '<S26>/AND1' */\r\n  boolean_T Compare_bo;                /* '<S48>/Compare' */\r\n  boolean_T Compare_ka;                /* '<S49>/Compare' */\r\n  boolean_T AND3_a;                    /* '<S26>/AND3' */\r\n  boolean_T Compare_f;                 /* '<S50>/Compare' */\r\n  boolean_T Compare_pg;                /* '<S182>/Compare' */\r\n  boolean_T RelationalOperator;        /* '<S62>/Relational Operator' */\r\n  boolean_T Compare_o;                 /* '<S68>/Compare' */\r\n  boolean_T Compare_c0;                /* '<S69>/Compare' */\r\n  boolean_T LowerRelop1;               /* '<S73>/LowerRelop1' */\r\n  boolean_T RelationalOperator_g;      /* '<S72>/Relational Operator' */\r\n  boolean_T UpperRelop;                /* '<S73>/UpperRelop' */\r\n} B_SimpleFOC_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T UnitDelay_1_DSTATE;           /* '<Root>/Unit Delay' */\r\n  real_T UnitDelay_2_DSTATE;           /* '<Root>/Unit Delay' */\r\n  real_T UnitDelay_9_DSTATE;           /* '<Root>/Unit Delay' */\r\n  real_T Sum2_DWORK1;                  /* '<S2>/Sum2' */\r\n  real_T Subtract_DWORK1;              /* '<S8>/Subtract' */\r\n  real32_T UnitDelay_DSTATE;           /* '<S188>/Unit Delay' */\r\n  uint32_T Sum_DWORK1[4];              /* '<S61>/Sum' */\r\n  int_T Integrator_IWORK;              /* '<S15>/Integrator' */\r\n  int_T Integrator_IWORK_n;            /* '<S19>/Integrator' */\r\n  int_T Integrator_IWORK_o;            /* '<S21>/Integrator' */\r\n  int_T Integrator_IWORK_a;            /* '<S14>/Integrator' */\r\n  int8_T If_ActiveSubsystem;           /* '<S181>/If' */\r\n  int8_T If_ActiveSubsystem_p;         /* '<S52>/If' */\r\n} DW_SimpleFOC_T;\r\n\r\n/* Continuous states (default storage) */\r\ntypedef struct {\r\n  real_T Integrator_CSTATE;            /* '<S15>/Integrator' */\r\n  real_T Integrator_CSTATE_l;          /* '<S19>/Integrator' */\r\n  real_T Integrator_CSTATE_g;          /* '<S21>/Integrator' */\r\n  real_T Integrator_CSTATE_lo;         /* '<S155>/Integrator' */\r\n  real_T Integrator_CSTATE_p;          /* '<S107>/Integrator' */\r\n  real_T Integrator_CSTATE_c;          /* '<S14>/Integrator' */\r\n} X_SimpleFOC_T;\r\n\r\n/* State derivatives (default storage) */\r\ntypedef struct {\r\n  real_T Integrator_CSTATE;            /* '<S15>/Integrator' */\r\n  real_T Integrator_CSTATE_l;          /* '<S19>/Integrator' */\r\n  real_T Integrator_CSTATE_g;          /* '<S21>/Integrator' */\r\n  real_T Integrator_CSTATE_lo;         /* '<S155>/Integrator' */\r\n  real_T Integrator_CSTATE_p;          /* '<S107>/Integrator' */\r\n  real_T Integrator_CSTATE_c;          /* '<S14>/Integrator' */\r\n} XDot_SimpleFOC_T;\r\n\r\n/* State disabled  */\r\ntypedef struct {\r\n  boolean_T Integrator_CSTATE;         /* '<S15>/Integrator' */\r\n  boolean_T Integrator_CSTATE_l;       /* '<S19>/Integrator' */\r\n  boolean_T Integrator_CSTATE_g;       /* '<S21>/Integrator' */\r\n  boolean_T Integrator_CSTATE_lo;      /* '<S155>/Integrator' */\r\n  boolean_T Integrator_CSTATE_p;       /* '<S107>/Integrator' */\r\n  boolean_T Integrator_CSTATE_c;       /* '<S14>/Integrator' */\r\n} XDis_SimpleFOC_T;\r\n\r\n#ifndef ODE3_INTG\r\n#define ODE3_INTG\r\n\r\n/* ODE3 Integration Data */\r\ntypedef struct {\r\n  real_T *y;                           /* output */\r\n  real_T *f[3];                        /* derivatives */\r\n} ODE3_IntgData;\r\n\r\n#endif\r\n\r\n/* Parameters (default storage) */\r\nstruct P_SimpleFOC_T_ {\r\n  struct_maxBupWeQJ2AuQC08ctECC Initial;/* Variable: Initial\r\n                                         * Referenced by:\r\n                                         *   '<Root>/Torque Setpoint'\r\n                                         *   '<S2>/12V'\r\n                                         *   '<S8>/Pos0'\r\n                                         *   '<S16>/Id_0'\r\n                                         *   '<S17>/Id_0'\r\n                                         */\r\n  real_T Ki_id;                        /* Variable: Ki_id\r\n                                        * Referenced by: '<S104>/Integral Gain'\r\n                                        */\r\n  real_T Ki_iq;                        /* Variable: Ki_iq\r\n                                        * Referenced by: '<S152>/Integral Gain'\r\n                                        */\r\n  real_T Kp_id;                        /* Variable: Kp_id\r\n                                        * Referenced by: '<S112>/Proportional Gain'\r\n                                        */\r\n  real_T Kp_iq;                        /* Variable: Kp_iq\r\n                                        * Referenced by: '<S160>/Proportional Gain'\r\n                                        */\r\n  real_T BLDC_B;                       /* Mask Parameter: BLDC_B\r\n                                        * Referenced by: '<S8>/Viscous'\r\n                                        */\r\n  real_T BLDC_F;                       /* Mask Parameter: BLDC_F\r\n                                        * Referenced by: '<S8>/FrictionT'\r\n                                        */\r\n  real_T DiscreteQuadratureCurrentContro;\r\n                              /* Mask Parameter: DiscreteQuadratureCurrentContro\r\n                               * Referenced by: '<S155>/Integrator'\r\n                               */\r\n  real_T DiscreteDirectCurrentController;\r\n                              /* Mask Parameter: DiscreteDirectCurrentController\r\n                               * Referenced by: '<S107>/Integrator'\r\n                               */\r\n  real_T BLDC_J;                       /* Mask Parameter: BLDC_J\r\n                                        * Referenced by: '<S8>/1//J'\r\n                                        */\r\n  real_T BLDC_Lambda;                  /* Mask Parameter: BLDC_Lambda\r\n                                        * Referenced by: '<S11>/Max_Lampda_PM_rate'\r\n                                        */\r\n  real_T BLDC_Ld;                      /* Mask Parameter: BLDC_Ld\r\n                                        * Referenced by:\r\n                                        *   '<S4>/Ld'\r\n                                        *   '<S16>/Ld'\r\n                                        *   '<S17>/Ld'\r\n                                        */\r\n  real_T BLDC_Lq;                      /* Mask Parameter: BLDC_Lq\r\n                                        * Referenced by:\r\n                                        *   '<S4>/Lq'\r\n                                        *   '<S16>/Lq'\r\n                                        *   '<S17>/Lq'\r\n                                        */\r\n  real_T BLDC_MechInput;               /* Mask Parameter: BLDC_MechInput\r\n                                        * Referenced by: '<S8>/Constant3'\r\n                                        */\r\n  real_T BLDC_Omega_init;              /* Mask Parameter: BLDC_Omega_init\r\n                                        * Referenced by: '<S8>/Speed0'\r\n                                        */\r\n  real_T BLDC_Rs;                      /* Mask Parameter: BLDC_Rs\r\n                                        * Referenced by: '<S1>/Rs'\r\n                                        */\r\n  real_T CompareToConstant_const;     /* Mask Parameter: CompareToConstant_const\r\n                                       * Referenced by: '<S27>/Constant'\r\n                                       */\r\n  real_T CompareToConstant1_const;   /* Mask Parameter: CompareToConstant1_const\r\n                                      * Referenced by: '<S28>/Constant'\r\n                                      */\r\n  real_T CompareToConstant2_const;   /* Mask Parameter: CompareToConstant2_const\r\n                                      * Referenced by: '<S29>/Constant'\r\n                                      */\r\n  real_T CompareToConstant3_const;   /* Mask Parameter: CompareToConstant3_const\r\n                                      * Referenced by: '<S30>/Constant'\r\n                                      */\r\n  real_T CompareToConstant6_const;   /* Mask Parameter: CompareToConstant6_const\r\n                                      * Referenced by: '<S31>/Constant'\r\n                                      */\r\n  real_T CompareToConstant7_const;   /* Mask Parameter: CompareToConstant7_const\r\n                                      * Referenced by: '<S32>/Constant'\r\n                                      */\r\n  real_T CompareToConstant8_const;   /* Mask Parameter: CompareToConstant8_const\r\n                                      * Referenced by: '<S33>/Constant'\r\n                                      */\r\n  real_T CompareToConstant9_const;   /* Mask Parameter: CompareToConstant9_const\r\n                                      * Referenced by: '<S34>/Constant'\r\n                                      */\r\n  real_T CompareToConstant_const_f; /* Mask Parameter: CompareToConstant_const_f\r\n                                     * Referenced by: '<S35>/Constant'\r\n                                     */\r\n  real_T CompareToConstant1_const_l;\r\n                                   /* Mask Parameter: CompareToConstant1_const_l\r\n                                    * Referenced by: '<S36>/Constant'\r\n                                    */\r\n  real_T CompareToConstant2_const_f;\r\n                                   /* Mask Parameter: CompareToConstant2_const_f\r\n                                    * Referenced by: '<S37>/Constant'\r\n                                    */\r\n  real_T CompareToConstant3_const_b;\r\n                                   /* Mask Parameter: CompareToConstant3_const_b\r\n                                    * Referenced by: '<S38>/Constant'\r\n                                    */\r\n  real_T CompareToConstant6_const_k;\r\n                                   /* Mask Parameter: CompareToConstant6_const_k\r\n                                    * Referenced by: '<S39>/Constant'\r\n                                    */\r\n  real_T CompareToConstant7_const_o;\r\n                                   /* Mask Parameter: CompareToConstant7_const_o\r\n                                    * Referenced by: '<S40>/Constant'\r\n                                    */\r\n  real_T CompareToConstant8_const_l;\r\n                                   /* Mask Parameter: CompareToConstant8_const_l\r\n                                    * Referenced by: '<S41>/Constant'\r\n                                    */\r\n  real_T CompareToConstant9_const_c;\r\n                                   /* Mask Parameter: CompareToConstant9_const_c\r\n                                    * Referenced by: '<S42>/Constant'\r\n                                    */\r\n  real_T CompareToConstant_const_b; /* Mask Parameter: CompareToConstant_const_b\r\n                                     * Referenced by: '<S43>/Constant'\r\n                                     */\r\n  real_T CompareToConstant1_const_lf;\r\n                                  /* Mask Parameter: CompareToConstant1_const_lf\r\n                                   * Referenced by: '<S44>/Constant'\r\n                                   */\r\n  real_T CompareToConstant2_const_c;\r\n                                   /* Mask Parameter: CompareToConstant2_const_c\r\n                                    * Referenced by: '<S45>/Constant'\r\n                                    */\r\n  real_T CompareToConstant3_const_k;\r\n                                   /* Mask Parameter: CompareToConstant3_const_k\r\n                                    * Referenced by: '<S46>/Constant'\r\n                                    */\r\n  real_T CompareToConstant6_const_f;\r\n                                   /* Mask Parameter: CompareToConstant6_const_f\r\n                                    * Referenced by: '<S47>/Constant'\r\n                                    */\r\n  real_T CompareToConstant7_const_b;\r\n                                   /* Mask Parameter: CompareToConstant7_const_b\r\n                                    * Referenced by: '<S48>/Constant'\r\n                                    */\r\n  real_T CompareToConstant8_const_b;\r\n                                   /* Mask Parameter: CompareToConstant8_const_b\r\n                                    * Referenced by: '<S49>/Constant'\r\n                                    */\r\n  real_T CompareToConstant9_const_g;\r\n                                   /* Mask Parameter: CompareToConstant9_const_g\r\n                                    * Referenced by: '<S50>/Constant'\r\n                                    */\r\n  real_T BLDC_p;                       /* Mask Parameter: BLDC_p\r\n                                        * Referenced by:\r\n                                        *   '<S1>/pole-pair'\r\n                                        *   '<S4>/Gain1'\r\n                                        *   '<S4>/Gain3'\r\n                                        *   '<S7>/pole-pair1'\r\n                                        */\r\n  uint16_T CompareToConstant_const_j;\r\n                                    /* Mask Parameter: CompareToConstant_const_j\r\n                                     * Referenced by: '<S68>/Constant'\r\n                                     */\r\n  uint16_T CompareToConstant1_const_a;\r\n                                   /* Mask Parameter: CompareToConstant1_const_a\r\n                                    * Referenced by: '<S69>/Constant'\r\n                                    */\r\n  real_T Gain1_Gain;                   /* Expression: 1/(pi/6)\r\n                                        * Referenced by: '<S24>/Gain1'\r\n                                        */\r\n  real_T Bias_Bias;                 /* Expression: -((pi/6) + (2*pi/3))/(pi/6)-1\r\n                                     * Referenced by: '<S24>/Bias'\r\n                                     */\r\n  real_T Gain2_Gain;                   /* Expression: -1/(pi/6)\r\n                                        * Referenced by: '<S24>/Gain2'\r\n                                        */\r\n  real_T Bias2_Bias;            /* Expression: (pi + (pi/6) + (2*pi/3))/(pi/6)+1\r\n                                 * Referenced by: '<S24>/Bias2'\r\n                                 */\r\n  real_T Gain_Gain;                    /* Expression: -1/(pi/6)\r\n                                        * Referenced by: '<S24>/Gain'\r\n                                        */\r\n  real_T Bias1_Bias;                   /* Expression: -(0)/(pi/6)-0\r\n                                        * Referenced by: '<S24>/Bias1'\r\n                                        */\r\n  real_T Gain1_Gain_l;                 /* Expression: 1/(pi/6)\r\n                                        * Referenced by: '<S25>/Gain1'\r\n                                        */\r\n  real_T Bias_Bias_a;               /* Expression: -((pi/6) + (2*pi/3))/(pi/6)-1\r\n                                     * Referenced by: '<S25>/Bias'\r\n                                     */\r\n  real_T Gain2_Gain_b;                 /* Expression: -1/(pi/6)\r\n                                        * Referenced by: '<S25>/Gain2'\r\n                                        */\r\n  real_T Bias2_Bias_j;          /* Expression: (pi + (pi/6) + (2*pi/3))/(pi/6)+1\r\n                                 * Referenced by: '<S25>/Bias2'\r\n                                 */\r\n  real_T Gain_Gain_c;                  /* Expression: -1/(pi/6)\r\n                                        * Referenced by: '<S25>/Gain'\r\n                                        */\r\n  real_T Bias1_Bias_a;                 /* Expression: -(0)/(pi/6)-0\r\n                                        * Referenced by: '<S25>/Bias1'\r\n                                        */\r\n  real_T Gain1_Gain_f;                 /* Expression: 1/(pi/6)\r\n                                        * Referenced by: '<S26>/Gain1'\r\n                                        */\r\n  real_T Bias_Bias_h;               /* Expression: -((pi/6) + (2*pi/3))/(pi/6)-1\r\n                                     * Referenced by: '<S26>/Bias'\r\n                                     */\r\n  real_T Gain2_Gain_p;                 /* Expression: -1/(pi/6)\r\n                                        * Referenced by: '<S26>/Gain2'\r\n                                        */\r\n  real_T Bias2_Bias_c;          /* Expression: (pi + (pi/6) + (2*pi/3))/(pi/6)+1\r\n                                 * Referenced by: '<S26>/Bias2'\r\n                                 */\r\n  real_T Gain_Gain_o;                  /* Expression: -1/(pi/6)\r\n                                        * Referenced by: '<S26>/Gain'\r\n                                        */\r\n  real_T Bias1_Bias_h;                 /* Expression: -(0)/(pi/6)-0\r\n                                        * Referenced by: '<S26>/Bias1'\r\n                                        */\r\n  real_T one_by_sqrt3_Gain;            /* Expression: 1/sqrt(3)\r\n                                        * Referenced by: '<S51>/one_by_sqrt3'\r\n                                        */\r\n  real_T Constant_Value;               /* Expression: 0\r\n                                        * Referenced by: '<S74>/Constant'\r\n                                        */\r\n  real_T Gain_Gain_p;                  /* Expression: -1\r\n                                        * Referenced by: '<S74>/Gain'\r\n                                        */\r\n  real_T Switch1_Threshold;            /* Expression: 0\r\n                                        * Referenced by: '<S74>/Switch1'\r\n                                        */\r\n  real_T Switch_Threshold;             /* Expression: 0\r\n                                        * Referenced by: '<S74>/Switch'\r\n                                        */\r\n  real_T Gain_Gain_k;                  /* Expression: -1\r\n                                        * Referenced by: '<S72>/Gain'\r\n                                        */\r\n  real_T Constant_Value_o;             /* Expression: 1\r\n                                        * Referenced by: '<S66>/Constant'\r\n                                        */\r\n  real_T ReplaceInport_satLim_Value;   /* Expression: 0\r\n                                        * Referenced by: '<S52>/ReplaceInport_satLim'\r\n                                        */\r\n  real_T Constant3_Value;              /* Expression: Vmax\r\n                                        * Referenced by: '<S64>/Constant3'\r\n                                        */\r\n  real_T Constant_Value_m;             /* Expression: 0\r\n                                        * Referenced by: '<S173>/Constant'\r\n                                        */\r\n  real_T Constant_Value_h;             /* Expression: 0\r\n                                        * Referenced by: '<S182>/Constant'\r\n                                        */\r\n  real_T Constant_Value_k;             /* Expression: 2*pi\r\n                                        * Referenced by: '<S7>/Constant'\r\n                                        */\r\n  real_T Minus120_Value[4];\r\n               /* Expression: [cos(2*pi/3) -sin(2*pi/3);sin(2*pi/3) cos(2*pi/3)]\r\n                * Referenced by: '<S5>/Minus120'\r\n                */\r\n  real_T Plus120_Value[4];\r\n               /* Expression: [cos(2*pi/3) sin(2*pi/3);-sin(2*pi/3) cos(2*pi/3)]\r\n                * Referenced by: '<S5>/Plus120'\r\n                */\r\n  real_T Gain2_Gain_n;                 /* Expression: -1\r\n                                        * Referenced by: '<S5>/Gain2'\r\n                                        */\r\n  real_T Constant2_Value;              /* Expression: 1\r\n                                        * Referenced by: '<S5>/Constant2'\r\n                                        */\r\n  real_T Constant_Value_mp;            /* Expression: 0\r\n                                        * Referenced by: '<S9>/Constant'\r\n                                        */\r\n  real_T Bias3_Bias;                   /* Expression: 0\r\n                                        * Referenced by: '<S24>/Bias3'\r\n                                        */\r\n  real_T Constant7_Value;              /* Expression: 2*pi\r\n                                        * Referenced by: '<S24>/Constant7'\r\n                                        */\r\n  real_T Constant8_Value;              /* Expression: 0\r\n                                        * Referenced by: '<S24>/Constant8'\r\n                                        */\r\n  real_T Constant1_Value;              /* Expression: -1\r\n                                        * Referenced by: '<S24>/Constant1'\r\n                                        */\r\n  real_T Constant3_Value_l;            /* Expression: 0\r\n                                        * Referenced by: '<S24>/Constant3'\r\n                                        */\r\n  real_T Constant2_Value_i;            /* Expression: 0\r\n                                        * Referenced by: '<S24>/Constant2'\r\n                                        */\r\n  real_T Constant4_Value;              /* Expression: 1\r\n                                        * Referenced by: '<S24>/Constant4'\r\n                                        */\r\n  real_T Constant5_Value;              /* Expression: 0\r\n                                        * Referenced by: '<S24>/Constant5'\r\n                                        */\r\n  real_T Constant6_Value;              /* Expression: 0\r\n                                        * Referenced by: '<S24>/Constant6'\r\n                                        */\r\n  real_T Bias3_Bias_g;                 /* Expression: -2*pi/3\r\n                                        * Referenced by: '<S25>/Bias3'\r\n                                        */\r\n  real_T Constant7_Value_n;            /* Expression: 2*pi\r\n                                        * Referenced by: '<S25>/Constant7'\r\n                                        */\r\n  real_T Constant8_Value_h;            /* Expression: 0\r\n                                        * Referenced by: '<S25>/Constant8'\r\n                                        */\r\n  real_T Constant1_Value_d;            /* Expression: -1\r\n                                        * Referenced by: '<S25>/Constant1'\r\n                                        */\r\n  real_T Constant3_Value_l3;           /* Expression: 0\r\n                                        * Referenced by: '<S25>/Constant3'\r\n                                        */\r\n  real_T Constant2_Value_l;            /* Expression: 0\r\n                                        * Referenced by: '<S25>/Constant2'\r\n                                        */\r\n  real_T Constant4_Value_k;            /* Expression: 1\r\n                                        * Referenced by: '<S25>/Constant4'\r\n                                        */\r\n  real_T Constant5_Value_a;            /* Expression: 0\r\n                                        * Referenced by: '<S25>/Constant5'\r\n                                        */\r\n  real_T Constant6_Value_h;            /* Expression: 0\r\n                                        * Referenced by: '<S25>/Constant6'\r\n                                        */\r\n  real_T Bias3_Bias_f;                 /* Expression: -4*pi/3\r\n                                        * Referenced by: '<S26>/Bias3'\r\n                                        */\r\n  real_T Constant7_Value_k;            /* Expression: 2*pi\r\n                                        * Referenced by: '<S26>/Constant7'\r\n                                        */\r\n  real_T Constant8_Value_g;            /* Expression: 0\r\n                                        * Referenced by: '<S26>/Constant8'\r\n                                        */\r\n  real_T Constant1_Value_j;            /* Expression: -1\r\n                                        * Referenced by: '<S26>/Constant1'\r\n                                        */\r\n  real_T Constant3_Value_o;            /* Expression: 0\r\n                                        * Referenced by: '<S26>/Constant3'\r\n                                        */\r\n  real_T Constant2_Value_c;            /* Expression: 0\r\n                                        * Referenced by: '<S26>/Constant2'\r\n                                        */\r\n  real_T Constant4_Value_l;            /* Expression: 1\r\n                                        * Referenced by: '<S26>/Constant4'\r\n                                        */\r\n  real_T Constant5_Value_ay;           /* Expression: 0\r\n                                        * Referenced by: '<S26>/Constant5'\r\n                                        */\r\n  real_T Constant6_Value_b;            /* Expression: 0\r\n                                        * Referenced by: '<S26>/Constant6'\r\n                                        */\r\n  real_T Gain_Gain_pp;                 /* Expression: -1\r\n                                        * Referenced by: '<S6>/Gain'\r\n                                        */\r\n  real_T Constant2_Value_h;            /* Expression: 0.5\r\n                                        * Referenced by: '<S6>/Constant2'\r\n                                        */\r\n  real_T Minus120_Value_i[4];\r\n               /* Expression: [cos(2*pi/3) -sin(2*pi/3);sin(2*pi/3) cos(2*pi/3)]\r\n                * Referenced by: '<S6>/Minus120'\r\n                */\r\n  real_T Gain2_Gain_bt;                /* Expression: -1\r\n                                        * Referenced by: '<S6>/Gain2'\r\n                                        */\r\n  real_T Plus120_Value_j[4];\r\n               /* Expression: [cos(2*pi/3) sin(2*pi/3);-sin(2*pi/3) cos(2*pi/3)]\r\n                * Referenced by: '<S6>/Plus120'\r\n                */\r\n  real_T Gain3_Gain;                   /* Expression: -1\r\n                                        * Referenced by: '<S6>/Gain3'\r\n                                        */\r\n  real_T Gain1_Gain_o;                 /* Expression: 2/3\r\n                                        * Referenced by: '<S6>/Gain1'\r\n                                        */\r\n  real_T UnitDelay_1_InitialCondition; /* Expression: 0\r\n                                        * Referenced by: '<Root>/Unit Delay'\r\n                                        */\r\n  real_T UnitDelay_2_InitialCondition; /* Expression: 0\r\n                                        * Referenced by: '<Root>/Unit Delay'\r\n                                        */\r\n  real_T sine_table_values_Value[1002];/* Expression: dlgSett.sin_table\r\n                                        * Referenced by: '<S61>/sine_table_values'\r\n                                        */\r\n  real_T UnitDelay_9_InitialCondition; /* Expression: 0\r\n                                        * Referenced by: '<Root>/Unit Delay'\r\n                                        */\r\n  real_T convert_pu_Gain;              /* Expression: 1/(dlgSett.UpperSatLimit)\r\n                                        * Referenced by: '<S181>/convert_pu'\r\n                                        */\r\n  real_T indexing_Gain;                /* Expression: dlgSett.index_gain\r\n                                        * Referenced by: '<S61>/indexing'\r\n                                        */\r\n  real_T one_by_two_Gain;              /* Expression: 1/2\r\n                                        * Referenced by: '<S55>/one_by_two'\r\n                                        */\r\n  real_T sqrt3_by_two_Gain;            /* Expression: sqrt(3)/2\r\n                                        * Referenced by: '<S55>/sqrt3_by_two'\r\n                                        */\r\n  real_T one_by_two_Gain_o;            /* Expression: -0.5\r\n                                        * Referenced by: '<S177>/one_by_two'\r\n                                        */\r\n  real_T Gain_Gain_e;                  /* Expression: 2/sqrt(3)\r\n                                        * Referenced by: '<S176>/Gain'\r\n                                        */\r\n  real_T Gain1_Gain_e;                 /* Expression: 0.5\r\n                                        * Referenced by: '<S58>/Gain1'\r\n                                        */\r\n  real_T Constant4_Value_lq;           /* Expression: 0.5\r\n                                        * Referenced by: '<S58>/Constant4'\r\n                                        */\r\n  real_T Switch_Threshold_j;           /* Expression: 0\r\n                                        * Referenced by: '<S173>/Switch'\r\n                                        */\r\n  real_T TorqueSetpoint_Time;          /* Expression: 5\r\n                                        * Referenced by: '<Root>/Torque Setpoint'\r\n                                        */\r\n  real_T TorqueSetpoint_YFinal;        /* Expression: 0*bldc.T_rated\r\n                                        * Referenced by: '<Root>/Torque Setpoint'\r\n                                        */\r\n  real_T Trq_Or_Spd_Threshold;         /* Expression: 1\r\n                                        * Referenced by: '<S8>/Trq_Or_Spd'\r\n                                        */\r\n  real32_T Constant1_Value_c;          /* Expression: Initial.Iq\r\n                                        * Referenced by: '<S2>/Constant1'\r\n                                        */\r\n  real32_T Constant_Value_j;           /* Expression: Initial.Id\r\n                                        * Referenced by: '<S2>/Constant'\r\n                                        */\r\n  real32_T Saturation2_UpperSat;     /* Computed Parameter: Saturation2_UpperSat\r\n                                      * Referenced by: '<S173>/Saturation2'\r\n                                      */\r\n  real32_T Saturation2_LowerSat;     /* Computed Parameter: Saturation2_LowerSat\r\n                                      * Referenced by: '<S173>/Saturation2'\r\n                                      */\r\n  real32_T Gain_Gain_i;                /* Computed Parameter: Gain_Gain_i\r\n                                        * Referenced by: '<S173>/Gain'\r\n                                        */\r\n  real32_T Filter_Constant_Value;   /* Computed Parameter: Filter_Constant_Value\r\n                                     * Referenced by: '<S188>/Filter_Constant'\r\n                                     */\r\n  real32_T One_Value;                  /* Computed Parameter: One_Value\r\n                                        * Referenced by: '<S188>/One'\r\n                                        */\r\n  real32_T UnitDelay_InitialCondition;\r\n                               /* Computed Parameter: UnitDelay_InitialCondition\r\n                                * Referenced by: '<S188>/Unit Delay'\r\n                                */\r\n  int16_T offset_Value[4];             /* Computed Parameter: offset_Value\r\n                                        * Referenced by: '<S61>/offset'\r\n                                        */\r\n  uint16_T ReplaceInport_satMethod_Value;\r\n                            /* Computed Parameter: ReplaceInport_satMethod_Value\r\n                             * Referenced by: '<S52>/ReplaceInport_satMethod'\r\n                             */\r\n  uint16_T ChosenMethod_Value;         /* Computed Parameter: ChosenMethod_Value\r\n                                        * Referenced by: '<S64>/ChosenMethod'\r\n                                        */\r\n  uint16_T Offset_Value;               /* Computed Parameter: Offset_Value\r\n                                        * Referenced by: '<S172>/Offset'\r\n                                        */\r\n  uint16_T Switch_Threshold_c;         /* Computed Parameter: Switch_Threshold_c\r\n                                        * Referenced by: '<S172>/Switch'\r\n                                        */\r\n  uint16_T Offset_Value_h;             /* Computed Parameter: Offset_Value_h\r\n                                        * Referenced by: '<S179>/Offset'\r\n                                        */\r\n  uint16_T Switch_Threshold_b;         /* Computed Parameter: Switch_Threshold_b\r\n                                        * Referenced by: '<S179>/Switch'\r\n                                        */\r\n  uint16_T enableInportSatMethod_Value;\r\n                              /* Computed Parameter: enableInportSatMethod_Value\r\n                               * Referenced by: '<S64>/enableInportSatMethod'\r\n                               */\r\n  uint16_T enableInportSatLim_Value;\r\n                                 /* Computed Parameter: enableInportSatLim_Value\r\n                                  * Referenced by: '<S64>/enableInportSatLim'\r\n                                  */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_SimpleFOC_T {\r\n  const char_T *errorStatus;\r\n  RTWLogInfo *rtwLogInfo;\r\n  RTWSolverInfo solverInfo;\r\n  X_SimpleFOC_T *contStates;\r\n  int_T *periodicContStateIndices;\r\n  real_T *periodicContStateRanges;\r\n  real_T *derivs;\r\n  XDis_SimpleFOC_T *contStateDisabled;\r\n  boolean_T zCCacheNeedsReset;\r\n  boolean_T derivCacheNeedsReset;\r\n  boolean_T CTOutputIncnstWithState;\r\n  real_T odeY[6];\r\n  real_T odeF[3][6];\r\n  ODE3_IntgData intgData;\r\n\r\n  /*\r\n   * Sizes:\r\n   * The following substructure contains sizes information\r\n   * for many of the model attributes such as inputs, outputs,\r\n   * dwork, sample times, etc.\r\n   */\r\n  struct {\r\n    int_T numContStates;\r\n    int_T numPeriodicContStates;\r\n    int_T numSampTimes;\r\n  } Sizes;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n    uint32_T clockTickH0;\r\n    time_T stepSize0;\r\n    uint32_T clockTick1;\r\n    uint32_T clockTickH1;\r\n    boolean_T firstInitCondFlag;\r\n    time_T tFinal;\r\n    SimTimeStep simTimeStep;\r\n    boolean_T stopRequestedFlag;\r\n    time_T *t;\r\n    time_T tArray[2];\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_SimpleFOC_T SimpleFOC_P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_SimpleFOC_T SimpleFOC_B;\r\n\r\n/* Continuous states (default storage) */\r\nextern X_SimpleFOC_T SimpleFOC_X;\r\n\r\n/* Block states (default storage) */\r\nextern DW_SimpleFOC_T SimpleFOC_DW;\r\n\r\n/* Model entry point functions */\r\nextern void SimpleFOC_initialize(void);\r\nextern void SimpleFOC_step(void);\r\nextern void SimpleFOC_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_SimpleFOC_T *const SimpleFOC_M;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S1>/Constant3' : Unused code path elimination\r\n * Block '<S10>/Data Type Conversion' : Unused code path elimination\r\n * Block '<S22>/Constant' : Unused code path elimination\r\n * Block '<S22>/Constant1' : Unused code path elimination\r\n * Block '<S22>/Constant2' : Unused code path elimination\r\n * Block '<S22>/Constant3' : Unused code path elimination\r\n * Block '<S22>/Constant4' : Unused code path elimination\r\n * Block '<S22>/Constant5' : Unused code path elimination\r\n * Block '<S22>/Logical Operator' : Unused code path elimination\r\n * Block '<S22>/Logical Operator1' : Unused code path elimination\r\n * Block '<S22>/Logical Operator2' : Unused code path elimination\r\n * Block '<S22>/Relational Operator1' : Unused code path elimination\r\n * Block '<S22>/Relational Operator2' : Unused code path elimination\r\n * Block '<S22>/Relational Operator3' : Unused code path elimination\r\n * Block '<S22>/Relational Operator4' : Unused code path elimination\r\n * Block '<S22>/Relational Operator5' : Unused code path elimination\r\n * Block '<S22>/Relational Operator6' : Unused code path elimination\r\n * Block '<S23>/Trigonometric Function' : Unused code path elimination\r\n * Block '<S23>/Trigonometric Function2' : Unused code path elimination\r\n * Block '<S23>/mech->elec' : Unused code path elimination\r\n * Block '<S23>/rad->deg' : Unused code path elimination\r\n * Block '<S1>/Trq_Or_Spd' : Unused code path elimination\r\n * Block '<S51>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S66>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S73>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S73>/Data Type Propagation' : Unused code path elimination\r\n * Block '<S74>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S52>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S64>/Data Type Duplicate1' : Unused code path elimination\r\n * Block '<S64>/Data Type Duplicate2' : Unused code path elimination\r\n * Block '<S65>/Sqrt' : Unused code path elimination\r\n * Block '<S55>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S56>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S56>/Data Type Duplicate1' : Unused code path elimination\r\n * Block '<S59>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S60>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S60>/Data Type Duplicate1' : Unused code path elimination\r\n * Block '<S61>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S61>/Data Type Propagation' : Unused code path elimination\r\n * Block '<S183>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S184>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S188>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S57>/Rate Transition5' : Eliminated since input and output rates are identical\r\n * Block '<S2>/Rate Transition1' : Eliminated since input and output rates are identical\r\n * Block '<S2>/Rate Transition2' : Eliminated since input and output rates are identical\r\n * Block '<S2>/Rate Transition3' : Eliminated since input and output rates are identical\r\n * Block '<S2>/Rate Transition4' : Eliminated since input and output rates are identical\r\n * Block '<S2>/Rate Transition6' : Eliminated since input and output rates are identical\r\n * Block '<S2>/Rate Transition7' : Eliminated since input and output rates are identical\r\n * Block '<S61>/Get_FractionVal' : Eliminate redundant data type conversion\r\n * Block '<Root>/Rate Transition1' : Eliminated since input and output rates are identical\r\n * Block '<Root>/Rate Transition2' : Eliminated since input and output rates are identical\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'SimpleFOC'\r\n * '<S1>'   : 'SimpleFOC/BLDC'\r\n * '<S2>'   : 'SimpleFOC/FOC'\r\n * '<S3>'   : 'SimpleFOC/Filter'\r\n * '<S4>'   : 'SimpleFOC/BLDC/ElecTorque'\r\n * '<S5>'   : 'SimpleFOC/BLDC/Matrix_InvP'\r\n * '<S6>'   : 'SimpleFOC/BLDC/Matrix_P'\r\n * '<S7>'   : 'SimpleFOC/BLDC/MechToElec'\r\n * '<S8>'   : 'SimpleFOC/BLDC/Mechanical Equation'\r\n * '<S9>'   : 'SimpleFOC/BLDC/Motor Equation'\r\n * '<S10>'  : 'SimpleFOC/BLDC/MotorInfo'\r\n * '<S11>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta'\r\n * '<S12>'  : 'SimpleFOC/BLDC/Mechanical Equation/Integration1'\r\n * '<S13>'  : 'SimpleFOC/BLDC/Mechanical Equation/Integration2'\r\n * '<S14>'  : 'SimpleFOC/BLDC/Mechanical Equation/Integration1/Continuous Integration'\r\n * '<S15>'  : 'SimpleFOC/BLDC/Mechanical Equation/Integration2/Continuous Integration'\r\n * '<S16>'  : 'SimpleFOC/BLDC/Motor Equation/D-axis'\r\n * '<S17>'  : 'SimpleFOC/BLDC/Motor Equation/Q-axis'\r\n * '<S18>'  : 'SimpleFOC/BLDC/Motor Equation/D-axis/Integration'\r\n * '<S19>'  : 'SimpleFOC/BLDC/Motor Equation/D-axis/Integration/Continuous Integration'\r\n * '<S20>'  : 'SimpleFOC/BLDC/Motor Equation/Q-axis/Integration'\r\n * '<S21>'  : 'SimpleFOC/BLDC/Motor Equation/Q-axis/Integration/Continuous Integration'\r\n * '<S22>'  : 'SimpleFOC/BLDC/MotorInfo/Hall sensor'\r\n * '<S23>'  : 'SimpleFOC/BLDC/MotorInfo/Hall sensor/Subsystem'\r\n * '<S24>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-a'\r\n * '<S25>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-b'\r\n * '<S26>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-c'\r\n * '<S27>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-a/Compare To Constant'\r\n * '<S28>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-a/Compare To Constant1'\r\n * '<S29>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-a/Compare To Constant2'\r\n * '<S30>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-a/Compare To Constant3'\r\n * '<S31>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-a/Compare To Constant6'\r\n * '<S32>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-a/Compare To Constant7'\r\n * '<S33>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-a/Compare To Constant8'\r\n * '<S34>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-a/Compare To Constant9'\r\n * '<S35>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-b/Compare To Constant'\r\n * '<S36>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-b/Compare To Constant1'\r\n * '<S37>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-b/Compare To Constant2'\r\n * '<S38>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-b/Compare To Constant3'\r\n * '<S39>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-b/Compare To Constant6'\r\n * '<S40>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-b/Compare To Constant7'\r\n * '<S41>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-b/Compare To Constant8'\r\n * '<S42>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-b/Compare To Constant9'\r\n * '<S43>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-c/Compare To Constant'\r\n * '<S44>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-c/Compare To Constant1'\r\n * '<S45>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-c/Compare To Constant2'\r\n * '<S46>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-c/Compare To Constant3'\r\n * '<S47>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-c/Compare To Constant6'\r\n * '<S48>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-c/Compare To Constant7'\r\n * '<S49>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-c/Compare To Constant8'\r\n * '<S50>'  : 'SimpleFOC/BLDC/d_Psi_d_Theta/Phase-c/Compare To Constant9'\r\n * '<S51>'  : 'SimpleFOC/FOC/Clarke Transform'\r\n * '<S52>'  : 'SimpleFOC/FOC/DQ Limiter'\r\n * '<S53>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller'\r\n * '<S54>'  : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller'\r\n * '<S55>'  : 'SimpleFOC/FOC/Inverse Clarke Transform'\r\n * '<S56>'  : 'SimpleFOC/FOC/Inverse Park Transform'\r\n * '<S57>'  : 'SimpleFOC/FOC/Inverter'\r\n * '<S58>'  : 'SimpleFOC/FOC/Output Scaling'\r\n * '<S59>'  : 'SimpleFOC/FOC/PWM Reference Generator'\r\n * '<S60>'  : 'SimpleFOC/FOC/Park Transform'\r\n * '<S61>'  : 'SimpleFOC/FOC/Sine-Cosine Lookup'\r\n * '<S62>'  : 'SimpleFOC/FOC/DQ Limiter/D-Q Equivalence'\r\n * '<S63>'  : 'SimpleFOC/FOC/DQ Limiter/D//Q Axis Priority'\r\n * '<S64>'  : 'SimpleFOC/FOC/DQ Limiter/Inport//Dialog Selection'\r\n * '<S65>'  : 'SimpleFOC/FOC/DQ Limiter/Magnitude_calc'\r\n * '<S66>'  : 'SimpleFOC/FOC/DQ Limiter/D-Q Equivalence/Limiter'\r\n * '<S67>'  : 'SimpleFOC/FOC/DQ Limiter/D-Q Equivalence/Passthrough'\r\n * '<S68>'  : 'SimpleFOC/FOC/DQ Limiter/D//Q Axis Priority/Compare To Constant'\r\n * '<S69>'  : 'SimpleFOC/FOC/DQ Limiter/D//Q Axis Priority/Compare To Constant1'\r\n * '<S70>'  : 'SimpleFOC/FOC/DQ Limiter/D//Q Axis Priority/flipInputs'\r\n * '<S71>'  : 'SimpleFOC/FOC/DQ Limiter/D//Q Axis Priority/flipInputs1'\r\n * '<S72>'  : 'SimpleFOC/FOC/DQ Limiter/D//Q Axis Priority/limiter'\r\n * '<S73>'  : 'SimpleFOC/FOC/DQ Limiter/D//Q Axis Priority/limiter/limitRef1'\r\n * '<S74>'  : 'SimpleFOC/FOC/DQ Limiter/D//Q Axis Priority/limiter/limitRef2'\r\n * '<S75>'  : 'SimpleFOC/FOC/DQ Limiter/D//Q Axis Priority/limiter/passThrough'\r\n * '<S76>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Anti-windup'\r\n * '<S77>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/D Gain'\r\n * '<S78>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Filter'\r\n * '<S79>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Filter ICs'\r\n * '<S80>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/I Gain'\r\n * '<S81>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Ideal P Gain'\r\n * '<S82>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Ideal P Gain Fdbk'\r\n * '<S83>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Integrator'\r\n * '<S84>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Integrator ICs'\r\n * '<S85>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/N Copy'\r\n * '<S86>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/N Gain'\r\n * '<S87>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/P Copy'\r\n * '<S88>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Parallel P Gain'\r\n * '<S89>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Reset Signal'\r\n * '<S90>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Saturation'\r\n * '<S91>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Saturation Fdbk'\r\n * '<S92>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Sum'\r\n * '<S93>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Sum Fdbk'\r\n * '<S94>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Tracking Mode'\r\n * '<S95>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Tracking Mode Sum'\r\n * '<S96>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Tsamp - Integral'\r\n * '<S97>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Tsamp - Ngain'\r\n * '<S98>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/postSat Signal'\r\n * '<S99>'  : 'SimpleFOC/FOC/Discrete Direct-Current Controller/preSat Signal'\r\n * '<S100>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Anti-windup/Passthrough'\r\n * '<S101>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/D Gain/Disabled'\r\n * '<S102>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Filter/Disabled'\r\n * '<S103>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Filter ICs/Disabled'\r\n * '<S104>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/I Gain/Internal Parameters'\r\n * '<S105>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Ideal P Gain/Passthrough'\r\n * '<S106>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Ideal P Gain Fdbk/Disabled'\r\n * '<S107>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Integrator/Continuous'\r\n * '<S108>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Integrator ICs/Internal IC'\r\n * '<S109>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/N Copy/Disabled wSignal Specification'\r\n * '<S110>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/N Gain/Disabled'\r\n * '<S111>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/P Copy/Disabled'\r\n * '<S112>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Parallel P Gain/Internal Parameters'\r\n * '<S113>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Reset Signal/Disabled'\r\n * '<S114>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Saturation/Passthrough'\r\n * '<S115>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Saturation Fdbk/Disabled'\r\n * '<S116>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Sum/Sum_PI'\r\n * '<S117>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Sum Fdbk/Disabled'\r\n * '<S118>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Tracking Mode/Disabled'\r\n * '<S119>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Tracking Mode Sum/Passthrough'\r\n * '<S120>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Tsamp - Integral/TsSignalSpecification'\r\n * '<S121>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/Tsamp - Ngain/Passthrough'\r\n * '<S122>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/postSat Signal/Forward_Path'\r\n * '<S123>' : 'SimpleFOC/FOC/Discrete Direct-Current Controller/preSat Signal/Forward_Path'\r\n * '<S124>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Anti-windup'\r\n * '<S125>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/D Gain'\r\n * '<S126>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Filter'\r\n * '<S127>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Filter ICs'\r\n * '<S128>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/I Gain'\r\n * '<S129>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Ideal P Gain'\r\n * '<S130>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Ideal P Gain Fdbk'\r\n * '<S131>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Integrator'\r\n * '<S132>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Integrator ICs'\r\n * '<S133>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/N Copy'\r\n * '<S134>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/N Gain'\r\n * '<S135>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/P Copy'\r\n * '<S136>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Parallel P Gain'\r\n * '<S137>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Reset Signal'\r\n * '<S138>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Saturation'\r\n * '<S139>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Saturation Fdbk'\r\n * '<S140>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Sum'\r\n * '<S141>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Sum Fdbk'\r\n * '<S142>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Tracking Mode'\r\n * '<S143>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Tracking Mode Sum'\r\n * '<S144>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Tsamp - Integral'\r\n * '<S145>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Tsamp - Ngain'\r\n * '<S146>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/postSat Signal'\r\n * '<S147>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/preSat Signal'\r\n * '<S148>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Anti-windup/Passthrough'\r\n * '<S149>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/D Gain/Disabled'\r\n * '<S150>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Filter/Disabled'\r\n * '<S151>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Filter ICs/Disabled'\r\n * '<S152>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/I Gain/Internal Parameters'\r\n * '<S153>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Ideal P Gain/Passthrough'\r\n * '<S154>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Ideal P Gain Fdbk/Disabled'\r\n * '<S155>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Integrator/Continuous'\r\n * '<S156>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Integrator ICs/Internal IC'\r\n * '<S157>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/N Copy/Disabled wSignal Specification'\r\n * '<S158>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/N Gain/Disabled'\r\n * '<S159>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/P Copy/Disabled'\r\n * '<S160>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Parallel P Gain/Internal Parameters'\r\n * '<S161>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Reset Signal/Disabled'\r\n * '<S162>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Saturation/Passthrough'\r\n * '<S163>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Saturation Fdbk/Disabled'\r\n * '<S164>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Sum/Sum_PI'\r\n * '<S165>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Sum Fdbk/Disabled'\r\n * '<S166>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Tracking Mode/Disabled'\r\n * '<S167>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Tracking Mode Sum/Passthrough'\r\n * '<S168>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Tsamp - Integral/TsSignalSpecification'\r\n * '<S169>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/Tsamp - Ngain/Passthrough'\r\n * '<S170>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/postSat Signal/Forward_Path'\r\n * '<S171>' : 'SimpleFOC/FOC/Discrete Quadrature-Current Controller/preSat Signal/Forward_Path'\r\n * '<S172>' : 'SimpleFOC/FOC/Inverse Park Transform/Switch_Axis'\r\n * '<S173>' : 'SimpleFOC/FOC/Inverter/Average-Value Inverter'\r\n * '<S174>' : 'SimpleFOC/FOC/PWM Reference Generator/Modulation method'\r\n * '<S175>' : 'SimpleFOC/FOC/PWM Reference Generator/Voltage Input'\r\n * '<S176>' : 'SimpleFOC/FOC/PWM Reference Generator/Modulation method/SVPWM'\r\n * '<S177>' : 'SimpleFOC/FOC/PWM Reference Generator/Modulation method/SVPWM/Half(Vmin+Vmax)'\r\n * '<S178>' : 'SimpleFOC/FOC/PWM Reference Generator/Voltage Input/Vabc'\r\n * '<S179>' : 'SimpleFOC/FOC/Park Transform/Switch_Axis'\r\n * '<S180>' : 'SimpleFOC/FOC/Sine-Cosine Lookup/Interpolation'\r\n * '<S181>' : 'SimpleFOC/FOC/Sine-Cosine Lookup/WrapUp'\r\n * '<S182>' : 'SimpleFOC/FOC/Sine-Cosine Lookup/WrapUp/Compare To Zero'\r\n * '<S183>' : 'SimpleFOC/FOC/Sine-Cosine Lookup/WrapUp/If Action Subsystem'\r\n * '<S184>' : 'SimpleFOC/FOC/Sine-Cosine Lookup/WrapUp/If Action Subsystem1'\r\n * '<S185>' : 'SimpleFOC/Filter/IIR Filter2'\r\n * '<S186>' : 'SimpleFOC/Filter/IIR Filter2/IIR Filter'\r\n * '<S187>' : 'SimpleFOC/Filter/IIR Filter2/IIR Filter/Low-pass'\r\n * '<S188>' : 'SimpleFOC/Filter/IIR Filter2/IIR Filter/Low-pass/IIR Low Pass Filter'\r\n */\r\n#endif                                 /* RTW_HEADER_SimpleFOC_h_ */\r\n"},{"name":"SimpleFOC_private.h","type":"header","group":"model","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * SimpleFOC_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_SimpleFOC_private_h_\r\n#define RTW_HEADER_SimpleFOC_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"builtin_typeid_types.h\"\r\n#include \"multiword_types.h\"\r\n#include \"SimpleFOC_types.h\"\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmSetFirstInitCond\r\n#define rtmSetFirstInitCond(rtm, val)  ((rtm)->Timing.firstInitCondFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmIsFirstInitCond\r\n#define rtmIsFirstInitCond(rtm)        ((rtm)->Timing.firstInitCondFlag)\r\n#endif\r\n\r\n#ifndef rtmIsMajorTimeStep\r\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmIsMinorTimeStep\r\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmSetTFinal\r\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\r\n#endif\r\n\r\n#ifndef rtmSetTPtr\r\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\r\n#endif\r\n\r\nextern real_T rt_modd_snf(real_T u0, real_T u1);\r\n\r\n/* private model entry point functions */\r\nextern void SimpleFOC_derivatives(void);\r\n\r\n#endif                                 /* RTW_HEADER_SimpleFOC_private_h_ */\r\n"},{"name":"SimpleFOC_types.h","type":"header","group":"model","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * SimpleFOC_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_SimpleFOC_types_h_\r\n#define RTW_HEADER_SimpleFOC_types_h_\r\n#include \"rtwtypes.h\"\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_J7t6RGObaCo2oYnr7cGuTF_\r\n#define DEFINED_TYPEDEF_FOR_struct_J7t6RGObaCo2oYnr7cGuTF_\r\n\r\ntypedef struct {\r\n  real_T ILd;\r\n  real_T ILq;\r\n  real_T ITheta;\r\n} struct_J7t6RGObaCo2oYnr7cGuTF;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_maxBupWeQJ2AuQC08ctECC_\r\n#define DEFINED_TYPEDEF_FOR_struct_maxBupWeQJ2AuQC08ctECC_\r\n\r\ntypedef struct {\r\n  struct_J7t6RGObaCo2oYnr7cGuTF bldc;\r\n  real_T Speed;\r\n  real_T Torque;\r\n  real_T Id;\r\n  real_T Iq;\r\n  real_T InverterVoltage;\r\n} struct_maxBupWeQJ2AuQC08ctECC;\r\n\r\n#endif\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_SimpleFOC_T_ P_SimpleFOC_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_SimpleFOC_T RT_MODEL_SimpleFOC_T;\r\n\r\n#endif                                 /* RTW_HEADER_SimpleFOC_types_h_ */\r\n"},{"name":"SimpleFOC_data.c","type":"source","group":"data","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * SimpleFOC_data.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"SimpleFOC.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_SimpleFOC_T SimpleFOC_P = {\r\n  /* Variable: Initial\r\n   * Referenced by:\r\n   *   '<Root>/Torque Setpoint'\r\n   *   '<S2>/12V'\r\n   *   '<S8>/Pos0'\r\n   *   '<S16>/Id_0'\r\n   *   '<S17>/Id_0'\r\n   */\r\n  {\r\n    {\r\n      0.0,\r\n      0.0,\r\n      0.0\r\n    },\r\n    1000.0,\r\n    0.0,\r\n    0.0,\r\n    5.0,\r\n    12.0\r\n  },\r\n\r\n  /* Variable: Ki_id\r\n   * Referenced by: '<S104>/Integral Gain'\r\n   */\r\n  0.33929200658769765,\r\n\r\n  /* Variable: Ki_iq\r\n   * Referenced by: '<S152>/Integral Gain'\r\n   */\r\n  0.33929200658769765,\r\n\r\n  /* Variable: Kp_id\r\n   * Referenced by: '<S112>/Proportional Gain'\r\n   */\r\n  3.7699111843077517,\r\n\r\n  /* Variable: Kp_iq\r\n   * Referenced by: '<S160>/Proportional Gain'\r\n   */\r\n  7.5398223686155035,\r\n\r\n  /* Mask Parameter: BLDC_B\r\n   * Referenced by: '<S8>/Viscous'\r\n   */\r\n  2.636875217824E-6,\r\n\r\n  /* Mask Parameter: BLDC_F\r\n   * Referenced by: '<S8>/FrictionT'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: DiscreteQuadratureCurrentContro\r\n   * Referenced by: '<S155>/Integrator'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: DiscreteDirectCurrentController\r\n   * Referenced by: '<S107>/Integrator'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: BLDC_J\r\n   * Referenced by: '<S8>/1//J'\r\n   */\r\n  0.0010061551833333,\r\n\r\n  /* Mask Parameter: BLDC_Lambda\r\n   * Referenced by: '<S11>/Max_Lampda_PM_rate'\r\n   */\r\n  0.0042636101245951919,\r\n\r\n  /* Mask Parameter: BLDC_Ld\r\n   * Referenced by:\r\n   *   '<S4>/Ld'\r\n   *   '<S16>/Ld'\r\n   *   '<S17>/Ld'\r\n   */\r\n  0.0002,\r\n\r\n  /* Mask Parameter: BLDC_Lq\r\n   * Referenced by:\r\n   *   '<S4>/Lq'\r\n   *   '<S16>/Lq'\r\n   *   '<S17>/Lq'\r\n   */\r\n  0.0004,\r\n\r\n  /* Mask Parameter: BLDC_MechInput\r\n   * Referenced by: '<S8>/Constant3'\r\n   */\r\n  1.0,\r\n\r\n  /* Mask Parameter: BLDC_Omega_init\r\n   * Referenced by: '<S8>/Speed0'\r\n   */\r\n  20.0,\r\n\r\n  /* Mask Parameter: BLDC_Rs\r\n   * Referenced by: '<S1>/Rs'\r\n   */\r\n  0.36,\r\n\r\n  /* Mask Parameter: CompareToConstant_const\r\n   * Referenced by: '<S27>/Constant'\r\n   */\r\n  0.52359877559829882,\r\n\r\n  /* Mask Parameter: CompareToConstant1_const\r\n   * Referenced by: '<S28>/Constant'\r\n   */\r\n  0.52359877559829882,\r\n\r\n  /* Mask Parameter: CompareToConstant2_const\r\n   * Referenced by: '<S29>/Constant'\r\n   */\r\n  2.617993877991494,\r\n\r\n  /* Mask Parameter: CompareToConstant3_const\r\n   * Referenced by: '<S30>/Constant'\r\n   */\r\n  2.617993877991494,\r\n\r\n  /* Mask Parameter: CompareToConstant6_const\r\n   * Referenced by: '<S31>/Constant'\r\n   */\r\n  3.6651914291880918,\r\n\r\n  /* Mask Parameter: CompareToConstant7_const\r\n   * Referenced by: '<S32>/Constant'\r\n   */\r\n  3.6651914291880918,\r\n\r\n  /* Mask Parameter: CompareToConstant8_const\r\n   * Referenced by: '<S33>/Constant'\r\n   */\r\n  5.7595865315812871,\r\n\r\n  /* Mask Parameter: CompareToConstant9_const\r\n   * Referenced by: '<S34>/Constant'\r\n   */\r\n  5.7595865315812871,\r\n\r\n  /* Mask Parameter: CompareToConstant_const_f\r\n   * Referenced by: '<S35>/Constant'\r\n   */\r\n  0.52359877559829882,\r\n\r\n  /* Mask Parameter: CompareToConstant1_const_l\r\n   * Referenced by: '<S36>/Constant'\r\n   */\r\n  0.52359877559829882,\r\n\r\n  /* Mask Parameter: CompareToConstant2_const_f\r\n   * Referenced by: '<S37>/Constant'\r\n   */\r\n  2.617993877991494,\r\n\r\n  /* Mask Parameter: CompareToConstant3_const_b\r\n   * Referenced by: '<S38>/Constant'\r\n   */\r\n  2.617993877991494,\r\n\r\n  /* Mask Parameter: CompareToConstant6_const_k\r\n   * Referenced by: '<S39>/Constant'\r\n   */\r\n  3.6651914291880918,\r\n\r\n  /* Mask Parameter: CompareToConstant7_const_o\r\n   * Referenced by: '<S40>/Constant'\r\n   */\r\n  3.6651914291880918,\r\n\r\n  /* Mask Parameter: CompareToConstant8_const_l\r\n   * Referenced by: '<S41>/Constant'\r\n   */\r\n  5.7595865315812871,\r\n\r\n  /* Mask Parameter: CompareToConstant9_const_c\r\n   * Referenced by: '<S42>/Constant'\r\n   */\r\n  5.7595865315812871,\r\n\r\n  /* Mask Parameter: CompareToConstant_const_b\r\n   * Referenced by: '<S43>/Constant'\r\n   */\r\n  0.52359877559829882,\r\n\r\n  /* Mask Parameter: CompareToConstant1_const_lf\r\n   * Referenced by: '<S44>/Constant'\r\n   */\r\n  0.52359877559829882,\r\n\r\n  /* Mask Parameter: CompareToConstant2_const_c\r\n   * Referenced by: '<S45>/Constant'\r\n   */\r\n  2.617993877991494,\r\n\r\n  /* Mask Parameter: CompareToConstant3_const_k\r\n   * Referenced by: '<S46>/Constant'\r\n   */\r\n  2.617993877991494,\r\n\r\n  /* Mask Parameter: CompareToConstant6_const_f\r\n   * Referenced by: '<S47>/Constant'\r\n   */\r\n  3.6651914291880918,\r\n\r\n  /* Mask Parameter: CompareToConstant7_const_b\r\n   * Referenced by: '<S48>/Constant'\r\n   */\r\n  3.6651914291880918,\r\n\r\n  /* Mask Parameter: CompareToConstant8_const_b\r\n   * Referenced by: '<S49>/Constant'\r\n   */\r\n  5.7595865315812871,\r\n\r\n  /* Mask Parameter: CompareToConstant9_const_g\r\n   * Referenced by: '<S50>/Constant'\r\n   */\r\n  5.7595865315812871,\r\n\r\n  /* Mask Parameter: BLDC_p\r\n   * Referenced by:\r\n   *   '<S1>/pole-pair'\r\n   *   '<S4>/Gain1'\r\n   *   '<S4>/Gain3'\r\n   *   '<S7>/pole-pair1'\r\n   */\r\n  6.0,\r\n\r\n  /* Mask Parameter: CompareToConstant_const_j\r\n   * Referenced by: '<S68>/Constant'\r\n   */\r\n  1U,\r\n\r\n  /* Mask Parameter: CompareToConstant1_const_a\r\n   * Referenced by: '<S69>/Constant'\r\n   */\r\n  1U,\r\n\r\n  /* Expression: 1/(pi/6)\r\n   * Referenced by: '<S24>/Gain1'\r\n   */\r\n  1.9098593171027443,\r\n\r\n  /* Expression: -((pi/6) + (2*pi/3))/(pi/6)-1\r\n   * Referenced by: '<S24>/Bias'\r\n   */\r\n  -6.0,\r\n\r\n  /* Expression: -1/(pi/6)\r\n   * Referenced by: '<S24>/Gain2'\r\n   */\r\n  -1.9098593171027443,\r\n\r\n  /* Expression: (pi + (pi/6) + (2*pi/3))/(pi/6)+1\r\n   * Referenced by: '<S24>/Bias2'\r\n   */\r\n  12.0,\r\n\r\n  /* Expression: -1/(pi/6)\r\n   * Referenced by: '<S24>/Gain'\r\n   */\r\n  -1.9098593171027443,\r\n\r\n  /* Expression: -(0)/(pi/6)-0\r\n   * Referenced by: '<S24>/Bias1'\r\n   */\r\n  -0.0,\r\n\r\n  /* Expression: 1/(pi/6)\r\n   * Referenced by: '<S25>/Gain1'\r\n   */\r\n  1.9098593171027443,\r\n\r\n  /* Expression: -((pi/6) + (2*pi/3))/(pi/6)-1\r\n   * Referenced by: '<S25>/Bias'\r\n   */\r\n  -6.0,\r\n\r\n  /* Expression: -1/(pi/6)\r\n   * Referenced by: '<S25>/Gain2'\r\n   */\r\n  -1.9098593171027443,\r\n\r\n  /* Expression: (pi + (pi/6) + (2*pi/3))/(pi/6)+1\r\n   * Referenced by: '<S25>/Bias2'\r\n   */\r\n  12.0,\r\n\r\n  /* Expression: -1/(pi/6)\r\n   * Referenced by: '<S25>/Gain'\r\n   */\r\n  -1.9098593171027443,\r\n\r\n  /* Expression: -(0)/(pi/6)-0\r\n   * Referenced by: '<S25>/Bias1'\r\n   */\r\n  -0.0,\r\n\r\n  /* Expression: 1/(pi/6)\r\n   * Referenced by: '<S26>/Gain1'\r\n   */\r\n  1.9098593171027443,\r\n\r\n  /* Expression: -((pi/6) + (2*pi/3))/(pi/6)-1\r\n   * Referenced by: '<S26>/Bias'\r\n   */\r\n  -6.0,\r\n\r\n  /* Expression: -1/(pi/6)\r\n   * Referenced by: '<S26>/Gain2'\r\n   */\r\n  -1.9098593171027443,\r\n\r\n  /* Expression: (pi + (pi/6) + (2*pi/3))/(pi/6)+1\r\n   * Referenced by: '<S26>/Bias2'\r\n   */\r\n  12.0,\r\n\r\n  /* Expression: -1/(pi/6)\r\n   * Referenced by: '<S26>/Gain'\r\n   */\r\n  -1.9098593171027443,\r\n\r\n  /* Expression: -(0)/(pi/6)-0\r\n   * Referenced by: '<S26>/Bias1'\r\n   */\r\n  -0.0,\r\n\r\n  /* Expression: 1/sqrt(3)\r\n   * Referenced by: '<S51>/one_by_sqrt3'\r\n   */\r\n  0.57735026918962584,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S74>/Constant'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: -1\r\n   * Referenced by: '<S74>/Gain'\r\n   */\r\n  -1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S74>/Switch1'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S74>/Switch'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: -1\r\n   * Referenced by: '<S72>/Gain'\r\n   */\r\n  -1.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S66>/Constant'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S52>/ReplaceInport_satLim'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: Vmax\r\n   * Referenced by: '<S64>/Constant3'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S173>/Constant'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S182>/Constant'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 2*pi\r\n   * Referenced by: '<S7>/Constant'\r\n   */\r\n  6.2831853071795862,\r\n\r\n  /* Expression: [cos(2*pi/3) -sin(2*pi/3);sin(2*pi/3) cos(2*pi/3)]\r\n   * Referenced by: '<S5>/Minus120'\r\n   */\r\n  { -0.49999999999999978, 0.86602540378443871, -0.86602540378443871,\r\n    -0.49999999999999978 },\r\n\r\n  /* Expression: [cos(2*pi/3) sin(2*pi/3);-sin(2*pi/3) cos(2*pi/3)]\r\n   * Referenced by: '<S5>/Plus120'\r\n   */\r\n  { -0.49999999999999978, -0.86602540378443871, 0.86602540378443871,\r\n    -0.49999999999999978 },\r\n\r\n  /* Expression: -1\r\n   * Referenced by: '<S5>/Gain2'\r\n   */\r\n  -1.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S5>/Constant2'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S9>/Constant'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S24>/Bias3'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 2*pi\r\n   * Referenced by: '<S24>/Constant7'\r\n   */\r\n  6.2831853071795862,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S24>/Constant8'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: -1\r\n   * Referenced by: '<S24>/Constant1'\r\n   */\r\n  -1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S24>/Constant3'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S24>/Constant2'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S24>/Constant4'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S24>/Constant5'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S24>/Constant6'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: -2*pi/3\r\n   * Referenced by: '<S25>/Bias3'\r\n   */\r\n  -2.0943951023931953,\r\n\r\n  /* Expression: 2*pi\r\n   * Referenced by: '<S25>/Constant7'\r\n   */\r\n  6.2831853071795862,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S25>/Constant8'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: -1\r\n   * Referenced by: '<S25>/Constant1'\r\n   */\r\n  -1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S25>/Constant3'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S25>/Constant2'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S25>/Constant4'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S25>/Constant5'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S25>/Constant6'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: -4*pi/3\r\n   * Referenced by: '<S26>/Bias3'\r\n   */\r\n  -4.1887902047863905,\r\n\r\n  /* Expression: 2*pi\r\n   * Referenced by: '<S26>/Constant7'\r\n   */\r\n  6.2831853071795862,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S26>/Constant8'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: -1\r\n   * Referenced by: '<S26>/Constant1'\r\n   */\r\n  -1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S26>/Constant3'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S26>/Constant2'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S26>/Constant4'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S26>/Constant5'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S26>/Constant6'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: -1\r\n   * Referenced by: '<S6>/Gain'\r\n   */\r\n  -1.0,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<S6>/Constant2'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: [cos(2*pi/3) -sin(2*pi/3);sin(2*pi/3) cos(2*pi/3)]\r\n   * Referenced by: '<S6>/Minus120'\r\n   */\r\n  { -0.49999999999999978, 0.86602540378443871, -0.86602540378443871,\r\n    -0.49999999999999978 },\r\n\r\n  /* Expression: -1\r\n   * Referenced by: '<S6>/Gain2'\r\n   */\r\n  -1.0,\r\n\r\n  /* Expression: [cos(2*pi/3) sin(2*pi/3);-sin(2*pi/3) cos(2*pi/3)]\r\n   * Referenced by: '<S6>/Plus120'\r\n   */\r\n  { -0.49999999999999978, -0.86602540378443871, 0.86602540378443871,\r\n    -0.49999999999999978 },\r\n\r\n  /* Expression: -1\r\n   * Referenced by: '<S6>/Gain3'\r\n   */\r\n  -1.0,\r\n\r\n  /* Expression: 2/3\r\n   * Referenced by: '<S6>/Gain1'\r\n   */\r\n  0.66666666666666663,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Unit Delay'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Unit Delay'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: dlgSett.sin_table\r\n   * Referenced by: '<S61>/sine_table_values'\r\n   */\r\n  { 0.0, 0.0078539008887113342, 0.015707317311820675, 0.02355976483361015,\r\n    0.031410759078128292, 0.03925981575906861, 0.047106450709642658,\r\n    0.054950179912445746, 0.062790519529313374, 0.070626985931166689,\r\n    0.078459095727844944, 0.08628636579792337, 0.094108313318514311,\r\n    0.10192445579505004, 0.10973431109104527, 0.11753739745783763,\r\n    0.12533323356430426, 0.13312133852655236, 0.14090123193758267,\r\n    0.14867243389692297, 0.15643446504023087, 0.16418684656886295,\r\n    0.17192910027940952, 0.17966074859319253, 0.1873813145857246,\r\n    0.19509032201612825, 0.20278729535651249, 0.21047175982130564,\r\n    0.21814324139654254, 0.22580126686910371, 0.23344536385590536,\r\n    0.24107506083303862, 0.24868988716485479, 0.25628937313299666,\r\n    0.26387304996537292, 0.27144044986507426, 0.27899110603922928,\r\n    0.28652455272779831, 0.29404032523230395, 0.30153795994449567,\r\n    0.3090169943749474, 0.31647696718158608, 0.3239174181981494,\r\n    0.33133788846257095, 0.33873792024529137, 0.34611705707749296,\r\n    0.35347484377925709, 0.36081082648764179, 0.36812455268467792,\r\n    0.375415571225283, 0.38268343236508978, 0.38992768778818826,\r\n    0.39714789063478062, 0.404343595528745, 0.41151435860510877,\r\n    0.41865973753742808, 0.42577929156507266, 0.43287258152041391,\r\n    0.43993916985591514, 0.4469786206711211, 0.45399049973954675,\r\n    0.46097437453546236, 0.46792981426057334, 0.47485638987059459,\r\n    0.48175367410171532, 0.48862124149695491, 0.4954586684324076,\r\n    0.50226553314337252, 0.50904141575037132, 0.51578589828504751,\r\n    0.5224985647159488, 0.52917900097419068, 0.53582679497899666,\r\n    0.54244153666311867, 0.5490228179981318, 0.55557023301960218,\r\n    0.56208337785213058, 0.56856185073426391, 0.57500525204327857,\r\n    0.58141318431983058, 0.58778525229247314, 0.59412106290203848,\r\n    0.60042022532588391, 0.60668235100199974, 0.61290705365297649,\r\n    0.619093949309834, 0.62524265633570508, 0.63135279544937761,\r\n    0.63742398974868963, 0.64345586473377892, 0.64944804833018366,\r\n    0.65540017091179381, 0.66131186532365183, 0.66718276690459966,\r\n    0.67301251350977331, 0.67880074553294167, 0.68454710592868862,\r\n    0.69025124023443718, 0.69591279659231431, 0.7015314257708557,\r\n    0.70710678118654746, 0.71263851892520536, 0.71812629776318881,\r\n    0.72356977918844934, 0.72896862742141155, 0.73432250943568556,\r\n    0.73963109497860968, 0.744894056591622, 0.75011106963045948,\r\n    0.75528181228518354, 0.76040596560003093, 0.76548321349308812,\r\n    0.77051324277578925, 0.77549574317223446, 0.78043040733832969,\r\n    0.785316930880745, 0.79015501237569041, 0.79494435338751,\r\n    0.79968465848709047, 0.80437563527008438, 0.80901699437494734,\r\n    0.813608449500787, 0.8181497174250234, 0.8226405180208598,\r\n    0.82708057427456183, 0.83146961230254512, 0.83580736136827027,\r\n    0.84009355389894191, 0.84432792550201508, 0.8485102149815037,\r\n    0.85264016435409218, 0.85671751886504954, 0.86074202700394364,\r\n    0.86471344052015509, 0.86863151443819131, 0.87249600707279706,\r\n    0.87630668004386369, 0.880063298291132, 0.88376563008869347,\r\n    0.88741344705928327, 0.89100652418836779, 0.894544639838025,\r\n    0.89802757576061565, 0.90145511711224569, 0.90482705246601958,\r\n    0.90814317382508125, 0.91140327663544518, 0.91460715979861362,\r\n    0.91775462568398114, 0.9208454801410263, 0.92387953251128674,\r\n    0.9268565956401208, 0.92977648588825135, 0.9326390231430941,\r\n    0.93544403082986727, 0.93819133592248416, 0.94088076895422545,\r\n    0.94351216402819349, 0.9460853588275453, 0.9486001946255046,\r\n    0.95105651629515353, 0.9534541723190012, 0.95579301479833012,\r\n    0.95807289946231911, 0.960293685676943, 0.96245523645364717,\r\n    0.96455741845779808, 0.96660010201690738, 0.96858316112863108,\r\n    0.97050647346854246, 0.97236992039767656, 0.97417338696984934,\r\n    0.97591676193874732, 0.97759993776479059, 0.97922281062176575,\r\n    0.98078528040323043, 0.98228725072868861, 0.98372862894953594,\r\n    0.98510932615477387, 0.98642925717649543, 0.98768834059513777,\r\n    0.98888649874450452, 0.99002365771655754, 0.99109974736597473,\r\n    0.99211470131447776, 0.99306845695492629, 0.99396095545517971,\r\n    0.99479214176172648, 0.99556196460308, 0.99627037649294126,\r\n    0.996917333733128, 0.99750279641627, 0.99802672842827156,\r\n    0.99848909745053793, 0.99888987496197, 0.9992290362407229,\r\n    0.9995065603657316, 0.99972243021800056, 0.99987663248166059,\r\n    0.99996915764478966, 1.0, 0.99996915764478966, 0.99987663248166059,\r\n    0.99972243021800056, 0.9995065603657316, 0.9992290362407229,\r\n    0.99888987496197, 0.99848909745053793, 0.99802672842827156, 0.99750279641627,\r\n    0.996917333733128, 0.99627037649294126, 0.99556196460308,\r\n    0.99479214176172648, 0.99396095545517971, 0.99306845695492629,\r\n    0.99211470131447788, 0.99109974736597484, 0.99002365771655765,\r\n    0.98888649874450463, 0.98768834059513777, 0.98642925717649543,\r\n    0.98510932615477387, 0.98372862894953594, 0.98228725072868872,\r\n    0.98078528040323043, 0.97922281062176575, 0.97759993776479071,\r\n    0.97591676193874743, 0.97417338696984934, 0.97236992039767656,\r\n    0.97050647346854246, 0.96858316112863108, 0.96660010201690727,\r\n    0.96455741845779808, 0.96245523645364728, 0.96029368567694307,\r\n    0.95807289946231922, 0.95579301479833023, 0.95345417231900131,\r\n    0.95105651629515364, 0.9486001946255046, 0.9460853588275453,\r\n    0.9435121640281936, 0.94088076895422545, 0.93819133592248416,\r\n    0.93544403082986738, 0.93263902314309421, 0.92977648588825146,\r\n    0.92685659564012091, 0.92387953251128685, 0.92084548014102618,\r\n    0.91775462568398114, 0.91460715979861362, 0.91140327663544529,\r\n    0.90814317382508125, 0.90482705246601947, 0.90145511711224569,\r\n    0.89802757576061565, 0.89454463983802512, 0.8910065241883679,\r\n    0.88741344705928327, 0.88376563008869347, 0.88006329829113183,\r\n    0.87630668004386347, 0.87249600707279706, 0.8686315144381912,\r\n    0.86471344052015509, 0.86074202700394364, 0.85671751886504965,\r\n    0.85264016435409229, 0.8485102149815037, 0.844327925502015,\r\n    0.8400935538989418, 0.83580736136827016, 0.83146961230254512,\r\n    0.82708057427456172, 0.8226405180208598, 0.8181497174250234,\r\n    0.813608449500787, 0.80901699437494745, 0.8043756352700846,\r\n    0.79968465848709058, 0.79494435338750991, 0.7901550123756903,\r\n    0.78531693088074483, 0.78043040733832969, 0.77549574317223446,\r\n    0.77051324277578925, 0.76548321349308812, 0.760405965600031,\r\n    0.75528181228518365, 0.75011106963045959, 0.74489405659162222,\r\n    0.73963109497860957, 0.73432250943568544, 0.72896862742141144,\r\n    0.72356977918844934, 0.71812629776318881, 0.71263851892520547,\r\n    0.70710678118654757, 0.70153142577085581, 0.69591279659231442,\r\n    0.69025124023443729, 0.68454710592868884, 0.67880074553294167,\r\n    0.67301251350977331, 0.66718276690459966, 0.66131186532365183,\r\n    0.65540017091179392, 0.64944804833018377, 0.643455864733779,\r\n    0.63742398974868986, 0.63135279544937783, 0.62524265633570542,\r\n    0.61909394930983386, 0.61290705365297637, 0.60668235100199963,\r\n    0.600420225325884, 0.59412106290203859, 0.58778525229247325,\r\n    0.58141318431983069, 0.57500525204327868, 0.56856185073426413,\r\n    0.56208337785213081, 0.55557023301960251, 0.549022817998132,\r\n    0.54244153666311878, 0.535826794978997, 0.52917900097419068,\r\n    0.52249856471594935, 0.51578589828504762, 0.5090414157503711,\r\n    0.50226553314337274, 0.49545866843240738, 0.48862124149695524,\r\n    0.48175367410171521, 0.474856389870595, 0.4679298142605734,\r\n    0.46097437453546281, 0.45399049973954686, 0.44697862067112165,\r\n    0.4399391698559153, 0.43287258152041375, 0.42577929156507288,\r\n    0.41865973753742797, 0.4115143586051091, 0.404343595528745,\r\n    0.39714789063478106, 0.38992768778818832, 0.38268343236509028,\r\n    0.37541557122528318, 0.36812455268467814, 0.360810826487642,\r\n    0.353474843779257, 0.3461170570774933, 0.33873792024529131,\r\n    0.33133788846257139, 0.32391741819814945, 0.31647696718158658,\r\n    0.30901699437494751, 0.30153795994449584, 0.29404032523230417,\r\n    0.28652455272779809, 0.27899110603922955, 0.27144044986507415,\r\n    0.26387304996537325, 0.2562893731329966, 0.24868988716485524,\r\n    0.24107506083303873, 0.23344536385590553, 0.22580126686910384,\r\n    0.21814324139654276, 0.21047175982130589, 0.20278729535651233,\r\n    0.19509032201612861, 0.18738131458572457, 0.17966074859319298,\r\n    0.17192910027940958, 0.164186846568863, 0.15643446504023098,\r\n    0.14867243389692314, 0.14090123193758286, 0.13312133852655261,\r\n    0.12533323356430454, 0.11753739745783755, 0.10973431109104564,\r\n    0.10192445579505002, 0.094108313318514353, 0.086286365797923453,\r\n    0.078459095727845068, 0.070626985931166841, 0.062790519529313582,\r\n    0.054950179912446, 0.047106450709642957, 0.03925981575906895,\r\n    0.031410759078128236, 0.023559764833610143, 0.01570731731182071,\r\n    0.0078539008887114122, 1.2246467991473532E-16, -0.0078539008887111659,\r\n    -0.015707317311820464, -0.023559764833609897, -0.031410759078127994,\r\n    -0.039259815759068263, -0.047106450709642714, -0.054950179912445753,\r\n    -0.062790519529313346, -0.0706269859311666, -0.078459095727844819,\r\n    -0.0862863657979232, -0.0941083133185141, -0.10192445579504979,\r\n    -0.10973431109104496, -0.11753739745783774, -0.12533323356430429,\r\n    -0.13312133852655236, -0.14090123193758261, -0.14867243389692292,\r\n    -0.15643446504023073, -0.16418684656886276, -0.17192910027940933,\r\n    -0.17966074859319228, -0.18738131458572477, -0.19509032201612792,\r\n    -0.20278729535651252, -0.21047175982130567, -0.21814324139654251,\r\n    -0.2258012668691036, -0.23344536385590528, -0.24107506083303848,\r\n    -0.24868988716485457, -0.25628937313299682, -0.26387304996537259,\r\n    -0.27144044986507432, -0.27899110603922889, -0.28652455272779831,\r\n    -0.29404032523230389, -0.30153795994449561, -0.30901699437494728,\r\n    -0.31647696718158591, -0.32391741819814962, -0.33133788846257073,\r\n    -0.33873792024529148, -0.34611705707749263, -0.35347484377925714,\r\n    -0.3608108264876414, -0.36812455268467792, -0.37541557122528296,\r\n    -0.38268343236508967, -0.38992768778818854, -0.3971478906347804,\r\n    -0.40434359552874516, -0.41151435860510849, -0.41865973753742819,\r\n    -0.42577929156507227, -0.43287258152041391, -0.43993916985591469,\r\n    -0.44697862067112104, -0.45399049973954708, -0.46097437453546219,\r\n    -0.46792981426057356, -0.47485638987059436, -0.48175367410171538,\r\n    -0.48862124149695463, -0.4954586684324076, -0.50226553314337208,\r\n    -0.50904141575037121, -0.515785898285047, -0.52249856471594869,\r\n    -0.52917900097419079, -0.53582679497899643, -0.5424415366631189,\r\n    -0.54902281799813146, -0.55557023301960229, -0.56208337785213025,\r\n    -0.56856185073426391, -0.57500525204327813, -0.58141318431983047,\r\n    -0.58778525229247269, -0.59412106290203837, -0.60042022532588424,\r\n    -0.60668235100199941, -0.6129070536529766, -0.61909394930983375,\r\n    -0.62524265633570519, -0.63135279544937739, -0.63742398974868963,\r\n    -0.64345586473377847, -0.64944804833018355, -0.65540017091179414,\r\n    -0.66131186532365172, -0.66718276690459977, -0.67301251350977309,\r\n    -0.67880074553294178, -0.68454710592868839, -0.69025124023443718,\r\n    -0.695912796592314, -0.7015314257708557, -0.70710678118654713,\r\n    -0.71263851892520524, -0.71812629776318893, -0.72356977918844911,\r\n    -0.72896862742141155, -0.73432250943568533, -0.73963109497860968,\r\n    -0.74489405659162178, -0.75011106963045948, -0.75528181228518321,\r\n    -0.76040596560003115, -0.765483213493088, -0.77051324277578936,\r\n    -0.77549574317223424, -0.7804304073383298, -0.78531693088074472,\r\n    -0.79015501237569041, -0.79494435338751024, -0.79968465848709047,\r\n    -0.80437563527008471, -0.80901699437494734, -0.81360844950078715,\r\n    -0.81814971742502329, -0.82264051802085991, -0.82708057427456161,\r\n    -0.83146961230254524, -0.8358073613682705, -0.84009355389894191,\r\n    -0.8443279255020153, -0.84851021498150359, -0.8526401643540924,\r\n    -0.85671751886504954, -0.86074202700394375, -0.86471344052015486,\r\n    -0.86863151443819131, -0.8724960070727974, -0.87630668004386358,\r\n    -0.88006329829113217, -0.88376563008869335, -0.88741344705928338,\r\n    -0.89100652418836779, -0.89454463983802524, -0.89802757576061554,\r\n    -0.9014551171122458, -0.9048270524660198, -0.90814317382508136,\r\n    -0.9114032766354454, -0.91460715979861351, -0.91775462568398125,\r\n    -0.92084548014102618, -0.92387953251128685, -0.92685659564012068,\r\n    -0.92977648588825146, -0.932639023143094, -0.93544403082986738,\r\n    -0.93819133592248427, -0.94088076895422545, -0.94351216402819371,\r\n    -0.9460853588275453, -0.94860019462550471, -0.95105651629515353,\r\n    -0.95345417231900131, -0.95579301479833, -0.95807289946231922,\r\n    -0.960293685676943, -0.96245523645364728, -0.96455741845779819,\r\n    -0.96660010201690727, -0.96858316112863119, -0.97050647346854246,\r\n    -0.97236992039767667, -0.97417338696984923, -0.97591676193874743,\r\n    -0.97759993776479059, -0.97922281062176575, -0.98078528040323032,\r\n    -0.98228725072868872, -0.98372862894953594, -0.98510932615477387,\r\n    -0.98642925717649554, -0.98768834059513766, -0.98888649874450463,\r\n    -0.99002365771655754, -0.99109974736597484, -0.99211470131447776,\r\n    -0.99306845695492629, -0.9939609554551796, -0.99479214176172648,\r\n    -0.99556196460308, -0.99627037649294126, -0.996917333733128,\r\n    -0.99750279641627, -0.99802672842827156, -0.99848909745053793,\r\n    -0.99888987496197, -0.9992290362407229, -0.9995065603657316,\r\n    -0.99972243021800056, -0.99987663248166059, -0.99996915764478966, -1.0,\r\n    -0.99996915764478966, -0.99987663248166059, -0.99972243021800056,\r\n    -0.9995065603657316, -0.9992290362407229, -0.99888987496197,\r\n    -0.99848909745053793, -0.99802672842827156, -0.99750279641627015,\r\n    -0.996917333733128, -0.99627037649294126, -0.99556196460308,\r\n    -0.99479214176172648, -0.99396095545517971, -0.99306845695492629,\r\n    -0.99211470131447788, -0.99109974736597484, -0.99002365771655754,\r\n    -0.98888649874450452, -0.98768834059513777, -0.98642925717649543,\r\n    -0.985109326154774, -0.98372862894953583, -0.98228725072868872,\r\n    -0.98078528040323043, -0.97922281062176586, -0.97759993776479071,\r\n    -0.97591676193874755, -0.97417338696984934, -0.97236992039767656,\r\n    -0.97050647346854246, -0.96858316112863108, -0.96660010201690738,\r\n    -0.96455741845779808, -0.96245523645364739, -0.96029368567694307,\r\n    -0.95807289946231933, -0.95579301479833012, -0.95345417231900143,\r\n    -0.95105651629515364, -0.9486001946255046, -0.94608535882754541,\r\n    -0.9435121640281936, -0.94088076895422557, -0.93819133592248416,\r\n    -0.93544403082986749, -0.9326390231430941, -0.92977648588825157,\r\n    -0.92685659564012091, -0.923879532511287, -0.9208454801410263,\r\n    -0.91775462568398147, -0.9146071597986134, -0.91140327663544518,\r\n    -0.90814317382508147, -0.90482705246601991, -0.90145511711224557,\r\n    -0.89802757576061565, -0.89454463983802535, -0.89100652418836834,\r\n    -0.88741344705928316, -0.88376563008869358, -0.88006329829113228,\r\n    -0.87630668004386336, -0.87249600707279706, -0.86863151443819153,\r\n    -0.86471344052015553, -0.86074202700394342, -0.85671751886504977,\r\n    -0.85264016435409251, -0.84851021498150425, -0.844327925502015,\r\n    -0.840093553898942, -0.83580736136827072, -0.831469612302545,\r\n    -0.82708057427456183, -0.82264051802086013, -0.818149717425024,\r\n    -0.81360844950078692, -0.80901699437494756, -0.80437563527008493,\r\n    -0.79968465848709125, -0.79494435338751, -0.79015501237569064,\r\n    -0.7853169308807455, -0.78043040733832947, -0.77549574317223446,\r\n    -0.77051324277578959, -0.76548321349308879, -0.76040596560003082,\r\n    -0.75528181228518376, -0.75011106963046, -0.74489405659162233,\r\n    -0.73963109497860968, -0.73432250943568578, -0.72896862742141211,\r\n    -0.72356977918844911, -0.71812629776318893, -0.7126385189252058,\r\n    -0.70710678118654835, -0.70153142577085559, -0.69591279659231453,\r\n    -0.69025124023443774, -0.684547105928689, -0.67880074553294167,\r\n    -0.67301251350977376, -0.66718276690460043, -0.6613118653236516,\r\n    -0.655400170911794, -0.6494480483301841, -0.64345586473377914,\r\n    -0.63742398974868963, -0.631352795449378, -0.62524265633570586,\r\n    -0.61909394930983364, -0.61290705365297649, -0.60668235100200008,\r\n    -0.6004202253258849, -0.59412106290203825, -0.58778525229247336,\r\n    -0.58141318431983113, -0.57500525204327879, -0.56856185073426391,\r\n    -0.56208337785213092, -0.555570233019603, -0.54902281799813135,\r\n    -0.54244153666311878, -0.5358267949789971, -0.52917900097419079,\r\n    -0.52249856471594869, -0.51578589828504773, -0.509041415750372,\r\n    -0.50226553314337286, -0.49545866843240749, -0.48862124149695535,\r\n    -0.4817536741017161, -0.47485638987059431, -0.46792981426057351,\r\n    -0.46097437453546292, -0.45399049973954697, -0.44697862067112093,\r\n    -0.43993916985591541, -0.43287258152041469, -0.425779291565073,\r\n    -0.41865973753742808, -0.41151435860510921, -0.4043435955287451,\r\n    -0.39714789063478034, -0.38992768778818843, -0.38268343236509039,\r\n    -0.37541557122528335, -0.36812455268467786, -0.36081082648764212,\r\n    -0.35347484377925792, -0.34611705707749341, -0.33873792024529142,\r\n    -0.33133788846257151, -0.32391741819814956, -0.31647696718158586,\r\n    -0.30901699437494762, -0.30153795994449639, -0.29404032523230428,\r\n    -0.28652455272779825, -0.27899110603922966, -0.27144044986507426,\r\n    -0.26387304996537336, -0.25628937313299671, -0.24868988716485535,\r\n    -0.24107506083303884, -0.2334453638559052, -0.22580126686910396,\r\n    -0.21814324139654331, -0.21047175982130603, -0.20278729535651246,\r\n    -0.19509032201612872, -0.18738131458572468, -0.17966074859319309,\r\n    -0.17192910027940969, -0.16418684656886356, -0.15643446504023112,\r\n    -0.14867243389692283, -0.140901231937583, -0.13312133852655228,\r\n    -0.12533323356430465, -0.11753739745783766, -0.10973431109104577,\r\n    -0.10192445579505015, -0.094108313318514908, -0.086286365797923578,\r\n    -0.078459095727845624, -0.070626985931166966, -0.062790519529313263,\r\n    -0.05495017991244612, -0.047106450709642637, -0.039259815759069075,\r\n    -0.031410759078128361, -0.023559764833610709, -0.015707317311820831,\r\n    -0.0078539008887119777, -2.4492935982947064E-16, 0.0078539008887113342,\r\n    0.015707317311820675, 0.02355976483361015, 0.031410759078128292,\r\n    0.03925981575906861, 0.047106450709642658, 0.054950179912445746,\r\n    0.062790519529313374, 0.070626985931166689, 0.078459095727844944,\r\n    0.08628636579792337, 0.094108313318514311, 0.10192445579505004,\r\n    0.10973431109104527, 0.11753739745783763, 0.12533323356430426,\r\n    0.13312133852655236, 0.14090123193758267, 0.14867243389692297,\r\n    0.15643446504023087, 0.16418684656886295, 0.17192910027940952,\r\n    0.17966074859319253, 0.1873813145857246, 0.19509032201612825,\r\n    0.20278729535651249, 0.21047175982130564, 0.21814324139654254,\r\n    0.22580126686910371, 0.23344536385590536, 0.24107506083303862,\r\n    0.24868988716485479, 0.25628937313299666, 0.26387304996537292,\r\n    0.27144044986507426, 0.27899110603922928, 0.28652455272779831,\r\n    0.29404032523230395, 0.30153795994449567, 0.3090169943749474,\r\n    0.31647696718158608, 0.3239174181981494, 0.33133788846257095,\r\n    0.33873792024529137, 0.34611705707749296, 0.35347484377925709,\r\n    0.36081082648764179, 0.36812455268467792, 0.375415571225283,\r\n    0.38268343236508978, 0.38992768778818826, 0.39714789063478062,\r\n    0.404343595528745, 0.41151435860510877, 0.41865973753742808,\r\n    0.42577929156507266, 0.43287258152041391, 0.43993916985591514,\r\n    0.4469786206711211, 0.45399049973954675, 0.46097437453546236,\r\n    0.46792981426057334, 0.47485638987059459, 0.48175367410171532,\r\n    0.48862124149695491, 0.4954586684324076, 0.50226553314337252,\r\n    0.50904141575037132, 0.51578589828504751, 0.5224985647159488,\r\n    0.52917900097419068, 0.53582679497899666, 0.54244153666311867,\r\n    0.5490228179981318, 0.55557023301960218, 0.56208337785213058,\r\n    0.56856185073426391, 0.57500525204327857, 0.58141318431983058,\r\n    0.58778525229247314, 0.59412106290203848, 0.60042022532588391,\r\n    0.60668235100199974, 0.61290705365297649, 0.619093949309834,\r\n    0.62524265633570508, 0.63135279544937761, 0.63742398974868963,\r\n    0.64345586473377892, 0.64944804833018366, 0.65540017091179381,\r\n    0.66131186532365183, 0.66718276690459966, 0.67301251350977331,\r\n    0.67880074553294167, 0.68454710592868862, 0.69025124023443718,\r\n    0.69591279659231431, 0.7015314257708557, 0.70710678118654746,\r\n    0.71263851892520536, 0.71812629776318881, 0.72356977918844934,\r\n    0.72896862742141155, 0.73432250943568556, 0.73963109497860968,\r\n    0.744894056591622, 0.75011106963045948, 0.75528181228518354,\r\n    0.76040596560003093, 0.76548321349308812, 0.77051324277578925,\r\n    0.77549574317223446, 0.78043040733832969, 0.785316930880745,\r\n    0.79015501237569041, 0.79494435338751, 0.79968465848709047,\r\n    0.80437563527008438, 0.80901699437494734, 0.813608449500787,\r\n    0.8181497174250234, 0.8226405180208598, 0.82708057427456183,\r\n    0.83146961230254512, 0.83580736136827027, 0.84009355389894191,\r\n    0.84432792550201508, 0.8485102149815037, 0.85264016435409218,\r\n    0.85671751886504954, 0.86074202700394364, 0.86471344052015509,\r\n    0.86863151443819131, 0.87249600707279706, 0.87630668004386369,\r\n    0.880063298291132, 0.88376563008869347, 0.88741344705928327,\r\n    0.89100652418836779, 0.894544639838025, 0.89802757576061565,\r\n    0.90145511711224569, 0.90482705246601958, 0.90814317382508125,\r\n    0.91140327663544518, 0.91460715979861362, 0.91775462568398114,\r\n    0.9208454801410263, 0.92387953251128674, 0.9268565956401208,\r\n    0.92977648588825135, 0.9326390231430941, 0.93544403082986727,\r\n    0.93819133592248416, 0.94088076895422545, 0.94351216402819349,\r\n    0.9460853588275453, 0.9486001946255046, 0.95105651629515353,\r\n    0.9534541723190012, 0.95579301479833012, 0.95807289946231911,\r\n    0.960293685676943, 0.96245523645364717, 0.96455741845779808,\r\n    0.96660010201690738, 0.96858316112863108, 0.97050647346854246,\r\n    0.97236992039767656, 0.97417338696984934, 0.97591676193874732,\r\n    0.97759993776479059, 0.97922281062176575, 0.98078528040323043,\r\n    0.98228725072868861, 0.98372862894953594, 0.98510932615477387,\r\n    0.98642925717649543, 0.98768834059513777, 0.98888649874450452,\r\n    0.99002365771655754, 0.99109974736597473, 0.99211470131447776,\r\n    0.99306845695492629, 0.99396095545517971, 0.99479214176172648,\r\n    0.99556196460308, 0.99627037649294126, 0.996917333733128, 0.99750279641627,\r\n    0.99802672842827156, 0.99848909745053793, 0.99888987496197,\r\n    0.9992290362407229, 0.9995065603657316, 0.99972243021800056,\r\n    0.99987663248166059, 0.99996915764478966, 1.0, 0.99996915764478966 },\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Unit Delay'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1/(dlgSett.UpperSatLimit)\r\n   * Referenced by: '<S181>/convert_pu'\r\n   */\r\n  0.15915494309189535,\r\n\r\n  /* Expression: dlgSett.index_gain\r\n   * Referenced by: '<S61>/indexing'\r\n   */\r\n  800.0,\r\n\r\n  /* Expression: 1/2\r\n   * Referenced by: '<S55>/one_by_two'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: sqrt(3)/2\r\n   * Referenced by: '<S55>/sqrt3_by_two'\r\n   */\r\n  0.8660254037844386,\r\n\r\n  /* Expression: -0.5\r\n   * Referenced by: '<S177>/one_by_two'\r\n   */\r\n  -0.5,\r\n\r\n  /* Expression: 2/sqrt(3)\r\n   * Referenced by: '<S176>/Gain'\r\n   */\r\n  1.1547005383792517,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<S58>/Gain1'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<S58>/Constant4'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S173>/Switch'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 5\r\n   * Referenced by: '<Root>/Torque Setpoint'\r\n   */\r\n  5.0,\r\n\r\n  /* Expression: 0*bldc.T_rated\r\n   * Referenced by: '<Root>/Torque Setpoint'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S8>/Trq_Or_Spd'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: Initial.Iq\r\n   * Referenced by: '<S2>/Constant1'\r\n   */\r\n  5.0F,\r\n\r\n  /* Expression: Initial.Id\r\n   * Referenced by: '<S2>/Constant'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: Saturation2_UpperSat\r\n   * Referenced by: '<S173>/Saturation2'\r\n   */\r\n  1.0F,\r\n\r\n  /* Computed Parameter: Saturation2_LowerSat\r\n   * Referenced by: '<S173>/Saturation2'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: Gain_Gain_i\r\n   * Referenced by: '<S173>/Gain'\r\n   */\r\n  0.333333343F,\r\n\r\n  /* Computed Parameter: Filter_Constant_Value\r\n   * Referenced by: '<S188>/Filter_Constant'\r\n   */\r\n  0.01F,\r\n\r\n  /* Computed Parameter: One_Value\r\n   * Referenced by: '<S188>/One'\r\n   */\r\n  0.99F,\r\n\r\n  /* Computed Parameter: UnitDelay_InitialCondition\r\n   * Referenced by: '<S188>/Unit Delay'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: offset_Value\r\n   * Referenced by: '<S61>/offset'\r\n   */\r\n  { 1, 0, 201, 200 },\r\n\r\n  /* Computed Parameter: ReplaceInport_satMethod_Value\r\n   * Referenced by: '<S52>/ReplaceInport_satMethod'\r\n   */\r\n  0U,\r\n\r\n  /* Computed Parameter: ChosenMethod_Value\r\n   * Referenced by: '<S64>/ChosenMethod'\r\n   */\r\n  3U,\r\n\r\n  /* Computed Parameter: Offset_Value\r\n   * Referenced by: '<S172>/Offset'\r\n   */\r\n  0U,\r\n\r\n  /* Computed Parameter: Switch_Threshold_c\r\n   * Referenced by: '<S172>/Switch'\r\n   */\r\n  1U,\r\n\r\n  /* Computed Parameter: Offset_Value_h\r\n   * Referenced by: '<S179>/Offset'\r\n   */\r\n  0U,\r\n\r\n  /* Computed Parameter: Switch_Threshold_b\r\n   * Referenced by: '<S179>/Switch'\r\n   */\r\n  1U,\r\n\r\n  /* Computed Parameter: enableInportSatMethod_Value\r\n   * Referenced by: '<S64>/enableInportSatMethod'\r\n   */\r\n  0U,\r\n\r\n  /* Computed Parameter: enableInportSatLim_Value\r\n   * Referenced by: '<S64>/enableInportSatLim'\r\n   */\r\n  0U\r\n};\r\n"},{"name":"builtin_typeid_types.h","type":"header","group":"utility","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * builtin_typeid_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef BUILTIN_TYPEID_TYPES_H\r\n#define BUILTIN_TYPEID_TYPES_H\r\n#ifndef BUILTIN_TYPEID_TYPES\r\n#define BUILTIN_TYPEID_TYPES\r\n\r\n/* Enumeration of built-in data types */\r\ntypedef enum {\r\n  SS_DOUBLE = 0,\r\n  SS_SINGLE = 1,\r\n  SS_INT8 = 2,\r\n  SS_UINT8 = 3,\r\n  SS_INT16 = 4,\r\n  SS_UINT16 = 5,\r\n  SS_INT32 = 6,\r\n  SS_UINT32 = 7,\r\n  SS_BOOLEAN = 8\r\n} BuiltInDTypeId;\r\n\r\n#define SS_NUM_BUILT_IN_DTYPE          ((int)SS_BOOLEAN+1)\r\n\r\n/* Enumeration for MAT-file logging code */\r\ntypedef int DTypeId;\r\n\r\n/* Enumeration of pre-defined data types */\r\ntypedef enum {\r\n  SS_FCN_CALL = 9,\r\n  SS_INTEGER = 10,\r\n  SS_POINTER = 11,\r\n  SS_INTERNAL_DTYPE2 = 12,\r\n  SS_TIMER_UINT32_PAIR = 13,\r\n  SS_CONNECTION_TYPE = 14\r\n} PreDefinedDTypeId;\r\n\r\n#endif                                 /* BUILTIN_TYPEID_TYPES */\r\n#endif                                 /* BUILTIN_TYPEID_TYPES_H */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int32_T chunk_T;\r\ntypedef uint32_T uchunk_T;\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long int long_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} int64m_T;\r\n\r\ntypedef struct {\r\n  int64m_T re;\r\n  int64m_T im;\r\n} cint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} uint64m_T;\r\n\r\ntypedef struct {\r\n  uint64m_T re;\r\n  uint64m_T im;\r\n} cuint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} int96m_T;\r\n\r\ntypedef struct {\r\n  int96m_T re;\r\n  int96m_T im;\r\n} cint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} uint96m_T;\r\n\r\ntypedef struct {\r\n  uint96m_T re;\r\n  uint96m_T im;\r\n} cuint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} int160m_T;\r\n\r\ntypedef struct {\r\n  int160m_T re;\r\n  int160m_T im;\r\n} cint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} uint160m_T;\r\n\r\ntypedef struct {\r\n  uint160m_T re;\r\n  uint160m_T im;\r\n} cuint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} int224m_T;\r\n\r\ntypedef struct {\r\n  int224m_T re;\r\n  int224m_T im;\r\n} cint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} uint224m_T;\r\n\r\ntypedef struct {\r\n  uint224m_T re;\r\n  uint224m_T im;\r\n} cuint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[9];\r\n} int288m_T;\r\n\r\ntypedef struct {\r\n  int288m_T re;\r\n  int288m_T im;\r\n} cint288m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[9];\r\n} uint288m_T;\r\n\r\ntypedef struct {\r\n  uint288m_T re;\r\n  uint288m_T im;\r\n} cuint288m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[10];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[10];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[11];\r\n} int352m_T;\r\n\r\ntypedef struct {\r\n  int352m_T re;\r\n  int352m_T im;\r\n} cint352m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[11];\r\n} uint352m_T;\r\n\r\ntypedef struct {\r\n  uint352m_T re;\r\n  uint352m_T im;\r\n} cuint352m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[12];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[12];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[13];\r\n} int416m_T;\r\n\r\ntypedef struct {\r\n  int416m_T re;\r\n  int416m_T im;\r\n} cint416m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[13];\r\n} uint416m_T;\r\n\r\ntypedef struct {\r\n  uint416m_T re;\r\n  uint416m_T im;\r\n} cuint416m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[14];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[14];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[15];\r\n} int480m_T;\r\n\r\ntypedef struct {\r\n  int480m_T re;\r\n  int480m_T im;\r\n} cint480m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[15];\r\n} uint480m_T;\r\n\r\ntypedef struct {\r\n  uint480m_T re;\r\n  uint480m_T im;\r\n} cuint480m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[16];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[16];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[17];\r\n} int544m_T;\r\n\r\ntypedef struct {\r\n  int544m_T re;\r\n  int544m_T im;\r\n} cint544m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[17];\r\n} uint544m_T;\r\n\r\ntypedef struct {\r\n  uint544m_T re;\r\n  uint544m_T im;\r\n} cuint544m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[18];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[18];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[19];\r\n} int608m_T;\r\n\r\ntypedef struct {\r\n  int608m_T re;\r\n  int608m_T im;\r\n} cint608m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[19];\r\n} uint608m_T;\r\n\r\ntypedef struct {\r\n  uint608m_T re;\r\n  uint608m_T im;\r\n} cuint608m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[20];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[20];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[21];\r\n} int672m_T;\r\n\r\ntypedef struct {\r\n  int672m_T re;\r\n  int672m_T im;\r\n} cint672m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[21];\r\n} uint672m_T;\r\n\r\ntypedef struct {\r\n  uint672m_T re;\r\n  uint672m_T im;\r\n} cuint672m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[22];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[22];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[23];\r\n} int736m_T;\r\n\r\ntypedef struct {\r\n  int736m_T re;\r\n  int736m_T im;\r\n} cint736m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[23];\r\n} uint736m_T;\r\n\r\ntypedef struct {\r\n  uint736m_T re;\r\n  uint736m_T im;\r\n} cuint736m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[24];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[24];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[25];\r\n} int800m_T;\r\n\r\ntypedef struct {\r\n  int800m_T re;\r\n  int800m_T im;\r\n} cint800m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[25];\r\n} uint800m_T;\r\n\r\ntypedef struct {\r\n  uint800m_T re;\r\n  uint800m_T im;\r\n} cuint800m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[26];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[26];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[27];\r\n} int864m_T;\r\n\r\ntypedef struct {\r\n  int864m_T re;\r\n  int864m_T im;\r\n} cint864m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[27];\r\n} uint864m_T;\r\n\r\ntypedef struct {\r\n  uint864m_T re;\r\n  uint864m_T im;\r\n} cuint864m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[28];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[28];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[29];\r\n} int928m_T;\r\n\r\ntypedef struct {\r\n  int928m_T re;\r\n  int928m_T im;\r\n} cint928m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[29];\r\n} uint928m_T;\r\n\r\ntypedef struct {\r\n  uint928m_T re;\r\n  uint928m_T im;\r\n} cuint928m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[30];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[30];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[31];\r\n} int992m_T;\r\n\r\ntypedef struct {\r\n  int992m_T re;\r\n  int992m_T im;\r\n} cint992m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[31];\r\n} uint992m_T;\r\n\r\ntypedef struct {\r\n  uint992m_T re;\r\n  uint992m_T im;\r\n} cuint992m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[32];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[32];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[33];\r\n} int1056m_T;\r\n\r\ntypedef struct {\r\n  int1056m_T re;\r\n  int1056m_T im;\r\n} cint1056m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[33];\r\n} uint1056m_T;\r\n\r\ntypedef struct {\r\n  uint1056m_T re;\r\n  uint1056m_T im;\r\n} cuint1056m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[34];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[34];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[35];\r\n} int1120m_T;\r\n\r\ntypedef struct {\r\n  int1120m_T re;\r\n  int1120m_T im;\r\n} cint1120m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[35];\r\n} uint1120m_T;\r\n\r\ntypedef struct {\r\n  uint1120m_T re;\r\n  uint1120m_T im;\r\n} cuint1120m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[36];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[36];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[37];\r\n} int1184m_T;\r\n\r\ntypedef struct {\r\n  int1184m_T re;\r\n  int1184m_T im;\r\n} cint1184m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[37];\r\n} uint1184m_T;\r\n\r\ntypedef struct {\r\n  uint1184m_T re;\r\n  uint1184m_T im;\r\n} cuint1184m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[38];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[38];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[39];\r\n} int1248m_T;\r\n\r\ntypedef struct {\r\n  int1248m_T re;\r\n  int1248m_T im;\r\n} cint1248m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[39];\r\n} uint1248m_T;\r\n\r\ntypedef struct {\r\n  uint1248m_T re;\r\n  uint1248m_T im;\r\n} cuint1248m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[40];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[40];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[41];\r\n} int1312m_T;\r\n\r\ntypedef struct {\r\n  int1312m_T re;\r\n  int1312m_T im;\r\n} cint1312m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[41];\r\n} uint1312m_T;\r\n\r\ntypedef struct {\r\n  uint1312m_T re;\r\n  uint1312m_T im;\r\n} cuint1312m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[42];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[42];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[43];\r\n} int1376m_T;\r\n\r\ntypedef struct {\r\n  int1376m_T re;\r\n  int1376m_T im;\r\n} cint1376m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[43];\r\n} uint1376m_T;\r\n\r\ntypedef struct {\r\n  uint1376m_T re;\r\n  uint1376m_T im;\r\n} cuint1376m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[44];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[44];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[45];\r\n} int1440m_T;\r\n\r\ntypedef struct {\r\n  int1440m_T re;\r\n  int1440m_T im;\r\n} cint1440m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[45];\r\n} uint1440m_T;\r\n\r\ntypedef struct {\r\n  uint1440m_T re;\r\n  uint1440m_T im;\r\n} cuint1440m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[46];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[46];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[47];\r\n} int1504m_T;\r\n\r\ntypedef struct {\r\n  int1504m_T re;\r\n  int1504m_T im;\r\n} cint1504m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[47];\r\n} uint1504m_T;\r\n\r\ntypedef struct {\r\n  uint1504m_T re;\r\n  uint1504m_T im;\r\n} cuint1504m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[48];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[48];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[49];\r\n} int1568m_T;\r\n\r\ntypedef struct {\r\n  int1568m_T re;\r\n  int1568m_T im;\r\n} cint1568m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[49];\r\n} uint1568m_T;\r\n\r\ntypedef struct {\r\n  uint1568m_T re;\r\n  uint1568m_T im;\r\n} cuint1568m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[50];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[50];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[51];\r\n} int1632m_T;\r\n\r\ntypedef struct {\r\n  int1632m_T re;\r\n  int1632m_T im;\r\n} cint1632m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[51];\r\n} uint1632m_T;\r\n\r\ntypedef struct {\r\n  uint1632m_T re;\r\n  uint1632m_T im;\r\n} cuint1632m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[52];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[52];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[53];\r\n} int1696m_T;\r\n\r\ntypedef struct {\r\n  int1696m_T re;\r\n  int1696m_T im;\r\n} cint1696m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[53];\r\n} uint1696m_T;\r\n\r\ntypedef struct {\r\n  uint1696m_T re;\r\n  uint1696m_T im;\r\n} cuint1696m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[54];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[54];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[55];\r\n} int1760m_T;\r\n\r\ntypedef struct {\r\n  int1760m_T re;\r\n  int1760m_T im;\r\n} cint1760m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[55];\r\n} uint1760m_T;\r\n\r\ntypedef struct {\r\n  uint1760m_T re;\r\n  uint1760m_T im;\r\n} cuint1760m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[56];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[56];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[57];\r\n} int1824m_T;\r\n\r\ntypedef struct {\r\n  int1824m_T re;\r\n  int1824m_T im;\r\n} cint1824m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[57];\r\n} uint1824m_T;\r\n\r\ntypedef struct {\r\n  uint1824m_T re;\r\n  uint1824m_T im;\r\n} cuint1824m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[58];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[58];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[59];\r\n} int1888m_T;\r\n\r\ntypedef struct {\r\n  int1888m_T re;\r\n  int1888m_T im;\r\n} cint1888m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[59];\r\n} uint1888m_T;\r\n\r\ntypedef struct {\r\n  uint1888m_T re;\r\n  uint1888m_T im;\r\n} cuint1888m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[60];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[60];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[61];\r\n} int1952m_T;\r\n\r\ntypedef struct {\r\n  int1952m_T re;\r\n  int1952m_T im;\r\n} cint1952m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[61];\r\n} uint1952m_T;\r\n\r\ntypedef struct {\r\n  uint1952m_T re;\r\n  uint1952m_T im;\r\n} cuint1952m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[62];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[62];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[63];\r\n} int2016m_T;\r\n\r\ntypedef struct {\r\n  int2016m_T re;\r\n  int2016m_T im;\r\n} cint2016m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[63];\r\n} uint2016m_T;\r\n\r\ntypedef struct {\r\n  uint2016m_T re;\r\n  uint2016m_T im;\r\n} cuint2016m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[64];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[64];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\r\n        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  uint16_T one = 1U;\r\n  enum {\r\n    LittleEndian,\r\n    BigEndian\r\n  } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n  switch (machByteOrder) {\r\n   case LittleEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0xFFC00000U;\r\n      break;\r\n    }\r\n\r\n   case BigEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0x7FFFFFFFU;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return nanF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\evant\\MATLAB\\Projects\\aman-model\\SimpleFOC_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n *  rtmodel.h:\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleFOC\".\r\n *\r\n * Model version              : 1.19\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Fri Jun 30 17:30:08 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"SimpleFOC.h\"\r\n#define GRTINTERFACE                   0\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n"},{"name":"rt_logging.c","type":"source","group":"other","path":"C:\\Program Files\\MATLAB\\R2023a\\rtw\\c\\src","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2022 The MathWorks, Inc.\n *\n * File: rt_logging.c\n *\n * Abstract:\n *\tReal-Time Workshop data logging routines using circular buffers of\n *      fixed size.  The buffers are allocated at start, filled in at each\n *      major time step and finally written to a MAT-file at the end of the\n *      simulation.\n *\n *      This file handles redefining the following standard MathWorks types\n *      (see tmwtypes.h):\n *         [u]int8_T     to be int32_T (logged as Matlab [u]int32)\n *         [u]int16_T    to be int32_T (logged as Matlab [u]int32)\n *         real_T        to be real32_T (logged as Matlab single)\n *\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\n\n#if !defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)\n\n#include <stddef.h>                     /* size_t */\n#include \"rt_logging.h\"\n#ifndef IS_RAPID_ACCEL\n#include \"rt_mxclassid.h\"\n#endif\n#include \"rtw_matlogging.h\"\n\n#include \"rtwtypes.h\"\n\n#ifndef TMW_NAME_LENGTH_MAX\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n#define matUNKNOWN                  0\n#define\tmatINT8                     1\n#define\tmatUINT8                    2\n#define\tmatINT16                    3\n#define\tmatUINT16                   4\n#define\tmatINT32                    5\n#define\tmatUINT32                   6\n#define\tmatFLOAT                    7\n#define\tmatDOUBLE                   9\n#define matINT64                   12\n#define matUINT64                  13\n#define\tmatMATRIX                  14\n\n#define matLOGICAL_BIT          0x200\n#define matCOMPLEX_BIT          0x800\n\n#define matKEY                 0x4D49\n#define matVERSION             0x0100\n#define matVERSION_INFO_OFFSET   124L\n\n#define matINT64_ALIGN(e)      ( ( ((unsigned)(e))+7 ) & (~7) )\n#define matTAG_SIZE            (sizeof(int32_T) << 1)\n\n#ifndef DEFAULT_BUFFER_SIZE\n#define DEFAULT_BUFFER_SIZE      1024  /* used if maxRows=0 and Tfinal=0.0    */\n#endif\n\n#define FREE(m) if (m != NULL) free(m)\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/*==========*\n * typedefs *\n *==========*/\n\ntypedef struct LogInfo_Tag {\n    LogVar       *t;                   /* Time log variable                   */\n    void         *x;                   /* State log variable                  */\n    int_T        ny;                   /* Length of \"y\" log variables         */\n    void         **y;                  /* Output log vars                     */\n    void         *xFinal;              /* Final state log variable            */\n\n    LogVar       *logVarsList;         /* Linked list of all LogVars          */\n    StructLogVar *structLogVarsList;   /* Linked list of all StructLogVars    */\n\n    boolean_T   haveLogVars;           /* Are logging one or more vars?       */\n} LogInfo;\n\ntypedef struct MatItem_tag {\n  int32_T    type;\n  uint32_T    nbytes;\n  const void *data;\n} MatItem;\n\ntypedef enum {\n    DATA_ITEM,\n    MATRIX_ITEM,\n    STRUCT_LOG_VAR_ITEM,\n    SIGNALS_STRUCT_ITEM\n} ItemDataKind;\n\n/*===========*\n * Constants *\n *===========*/\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n\n#define ZEROS32 \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\n#if mxMAXNAM==32\n\n#define ZERO_PAD\n\n#elif mxMAXNAM==64\n\n#define ZERO_PAD ZEROS32\n\n#elif mxMAXNAM==128\n\n#define ZERO_PAD   ZEROS32  ZEROS32  ZEROS32\n\n#else\n\n#error \"Cannot Handle mxMAXNAM other than 32,64, and 128\"\n\n#endif\n/* field names: for variable-size signal logging */\nstatic const char_T rtStructLogVarFieldNames[] =\n                  \"time\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"signals\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtLocalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n                  \n\n#define TIME_FIELD_NAME      (rtStructLogVarFieldNames[0*mxMAXNAM])\n#define SIGNALS_FIELD_NAME   (rtStructLogVarFieldNames[1*mxMAXNAM])\n#define BLOCKNAME_FIELD_NAME (rtStructLogVarFieldNames[2*mxMAXNAM])\n\n#define VALUES_FIELD_NAME    (rtLocalLoggingSignalsStructFieldNames[0*mxMAXNAM])\n#define VALUEDIMENSIONS_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[1*mxMAXNAM])\n#define DIMENSION_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[2*mxMAXNAM])\n#define LABEL_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[3*mxMAXNAM])\n#define TITLE_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[4*mxMAXNAM])\n#define PLOTSTYLE_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n\n#define STATENAME_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n#define CROSS_MDL_REF_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[6*mxMAXNAM])\n\n/* field names: for fixed-size signal logging */\nstatic const char_T rtLocalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nextern real_T rtInf; /* declared by rt_nonfinite.c */\nextern real_T rtNaN;\nextern real32_T rtNaNF;\n\n/*================*\n * Local routines *\n *================*/\n\n/* Function: rt_GetSizeofDataType ==============================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofDataType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 0; /* unknown */\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        elSz = sizeof(real_T);\n        break;\n      case SS_SINGLE:\n        elSz = sizeof(real32_T);\n        break;\n      case SS_INT8:\n        elSz = sizeof(int8_T);\n        break;\n      case SS_UINT8:\n        elSz = sizeof(uint8_T);\n        break;\n      case SS_INT16:\n        elSz = sizeof(int16_T);\n        break;\n      case SS_UINT16:\n        elSz = sizeof(uint16_T);\n        break;\n      case SS_INT32:\n        elSz = sizeof(int32_T);\n        break;\n      case SS_UINT32:\n        elSz = sizeof(uint32_T);\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n    return(elSz);\n\n} /* end rt_GetSizeofDataType */\n\n\n/* Function: rt_GetSizeofComplexType ===========================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofComplexType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 2*rt_GetSizeofDataType(dTypeID);\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal_T);\n      #endif\n        break;\n      case SS_SINGLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal32_T);\n      #endif\n        break;\n      case SS_INT8:\n      #ifdef CINT8_T\n        elSz = sizeof(cint8_T);\n      #endif\n        break;\n      case SS_UINT8:\n      #ifdef CUINT8_T\n        elSz = sizeof(cuint8_T);\n      #endif\n        break;\n      case SS_INT16:\n      #ifdef CINT16_T\n        elSz = sizeof(cint16_T);\n      #endif\n        break;\n      case SS_UINT16:\n      #ifdef CUINT16_T\n        elSz = sizeof(cuint16_T);\n      #endif\n        break;\n      case SS_INT32:\n      #ifdef CINT32_T\n        elSz = sizeof(cint32_T);\n      #endif\n        break;\n      case SS_UINT32:\n      #ifdef CUINT32_T\n        elSz = sizeof(cuint32_T);\n      #endif\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n\n    return(elSz);\n\n} /* end rt_GetSizeofComplexType */\n\n\n/* Function: rt_GetDataTypeConvertInfo =========================================\n * Abstract:\n *      Directly copy if pointer to structure is non-NULL, otherwise set to\n *      default.\n */\nstatic RTWLogDataTypeConvert rt_GetDataTypeConvertInfo(\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    BuiltInDTypeId dTypeID\n    )\n{\n    RTWLogDataTypeConvert dataTypeConvertInfoCopy;\n\n    if (pDataTypeConvertInfo == NULL) {\n        dataTypeConvertInfoCopy.conversionNeeded = 0;\n        dataTypeConvertInfoCopy.dataTypeIdLoggingTo = dTypeID;\n        dataTypeConvertInfoCopy.dataTypeIdOriginal  = (DTypeId)dTypeID;\n        dataTypeConvertInfoCopy.bitsPerChunk = 0;\n        dataTypeConvertInfoCopy.numOfChunk = 0;\n        dataTypeConvertInfoCopy.isSigned = 0;\n        dataTypeConvertInfoCopy.fracSlope = 1.0;\n        dataTypeConvertInfoCopy.fixedExp = 0;\n        dataTypeConvertInfoCopy.bias = 0.0;\n    } else {\n        dataTypeConvertInfoCopy = *pDataTypeConvertInfo;\n    }\n\n    return dataTypeConvertInfoCopy;\n\n} /* end rt_GetDataTypeConvertInfo */\n\n\n/* Function: rt_GetDblValueFromOverSizedData ===================================\n * Abstract:\n */\nstatic double rt_GetDblValueFromOverSizedData(\n    const void *pVoid, \n    int bitsPerChunk, \n    int numOfChunk,\n    unsigned int isSigned, \n    double fracSlope, \n    int fixedExp, \n    double bias)\n{\n    double retValue = 0;\n\n    double *dblValue = (double *) calloc(numOfChunk, sizeof(double));\n\n    int i;    \n    double isSignedNeg;\n\n    if(isSigned) {\n        const chunk_T *pData = (const chunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    } else  {\n        const uchunk_T *pData = (const uchunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    }\n\n    /* \n       Assuming multi chunks b_n ... b_2 b_1 b_0, and the length of each chunk is N.\n       Suppose b_i is the i-th chunk's value.\n       Then for unsigned data or data with one chunk: we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0;\n       But for signed data, we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0+ (b_0<0) * 2^N + \n       ... (b_(n-1) <0) * 2^(n*N) \n       = (b_n + (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + (b_0<0)) * 2^N + b_0 * 2^0;\n       Together:\n       retValue = \n       (b_n + isSigned * (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + isSigned * (b_0<0)) * 2^N + b_0 * 2^0;\n    */\n\n    retValue = dblValue[numOfChunk - 1];\n    \n    for(i = numOfChunk - 1; i > 0; i--) {\n        isSignedNeg = dblValue[i - 1] < 0 ? (double)isSigned : 0;\n        retValue = retValue + isSignedNeg;\n\n        retValue = ldexp(retValue, bitsPerChunk)+ dblValue[i-1];\n    }\n    retValue = ldexp( fracSlope * retValue, fixedExp ) + bias;\n\n    FREE(dblValue);\n    return (retValue);\n\n} /* end rt_GetDblValueFromOverSizedData */\n\n\n/* Function: rt_GetNonBoolMxIdFromDTypeId ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nstatic mxClassID rt_GetNonBoolMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        mxID = (sizeof(real_T)==4? mxSINGLE_CLASS: mxDOUBLE_CLASS);\n        break;\n      case SS_SINGLE:\n        mxID = mxSINGLE_CLASS;\n        break;\n      case SS_INT8:\n        switch (sizeof(int8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 32-bits\" */\n            mxID = mxINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 16-bits\" */\n            mxID = mxINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_UINT8:\n        switch (sizeof(uint8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxUINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_INT16:\n        mxID = (sizeof(int16_T)==4? mxINT32_CLASS: mxINT16_CLASS);\n        break;\n      case SS_UINT16:\n        mxID = (sizeof(uint16_T)==4? mxUINT32_CLASS: mxUINT16_CLASS);\n        break;\n      case SS_INT32:\n        mxID = mxINT32_CLASS;\n        break;\n      case SS_UINT32:\n        mxID = mxUINT32_CLASS;\n        break;\n        /*case SS_BOOLEAN:\n          mxID = (sizeof(boolean_T)==4? mxUINT32_CLASS: mxLOGICAL_CLASS);\n          break;*/\n      default:\n        mxID = mxUNKNOWN_CLASS;\n        break;\n    }\n\n    return(mxID);\n\n} /* end rt_GetNonBoolMxIdFromDTypeId */\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeIdForRSim ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeIdForRSim(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxLOGICAL_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeIdForRSim */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeId =============================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxUINT8_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeId */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n/* Function: rt_GetMatIdFromMxId ===============================================\n * Abstract:\n *      Get the MatId given the mxClassID.\n */\nstatic int_T rt_GetMatIdFromMxId(mxClassID mxID)\n{\n    int_T matID;\n\n    switch (mxID) {\n      case mxCELL_CLASS:\n      case mxSTRUCT_CLASS:\n      case mxOBJECT_CLASS:\n        matID = -1;\n        break;\n      case mxCHAR_CLASS:\n        matID = matUINT16;\n        break;\n      case mxDOUBLE_CLASS:\n        matID = matDOUBLE;\n        break;\n      case mxSINGLE_CLASS:\n        matID = matFLOAT;\n        break;\n      case mxINT8_CLASS:\n        matID = matINT8;\n        break;\n      case mxUINT8_CLASS:\n        matID = matUINT8;\n        break;\n      case mxINT16_CLASS:\n        matID = matINT16;\n        break;\n      case mxUINT16_CLASS:\n        matID = matUINT16;\n        break;\n      case mxINT32_CLASS:\n        matID = matINT32;\n        break;\n      case mxUINT32_CLASS:\n        matID = matUINT32;\n        break;\n      case mxINT64_CLASS:\n        matID = matINT64;\n        break;\n      case mxUINT64_CLASS:\n        matID = matUINT64;\n        break;\n      default:\n        matID = matUNKNOWN;\n        break;\n    }\n    return(matID);\n\n} /* end rt_GetMatIdFromMxId */\n\n\n/* Forward declaration */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind dataKind);\n\n\n/* Function: rt_ProcessMatItem =================================================\n * Abstract:\n *      This routine along with rt_WriteItemToMatFile() write out a specified\n *      mat-item the .mat file. Note that if the input argument\n *          cmd == 0, then this function just calculates the size of the item.\n *          cmd <> 0, this function writes the mat-item to the file.\n *      Return values is\n *           -1 : coding/logic error\n *            0 : upon success\n *          > 0 : upon write failure (1)\n */\nstatic int_T rt_ProcessMatItem(FILE         *fp,\n                               MatItem      *pItem,\n                               ItemDataKind itemKind,\n                               int_T        cmd)\n{\n    mxClassID    mxID          = mxUNKNOWN_CLASS;\n    uint32_T     arrayFlags[2] = {0, 0};\n    int32_T      *dims         = NULL;\n    int32_T      _dims[3]      = {0, 0, 0};\n    int32_T      nDims         = 2;\n    int32_T      nBytesInItem  = 0;\n    const char_T *itemName;\n    MatItem      item;\n    int_T        retStat       = 0;\n\n    switch (itemKind) {\n      case DATA_ITEM: {\n          (void)fprintf(stderr,\"Unexpected itemKind = DATA_ITEM in \"\n                               \"rt_ProcessMatItem @A\\n\");\n          retStat = -1;\n          goto EXIT_POINT;\n      }\n      case MATRIX_ITEM: {\n          const MatrixData *var = (const MatrixData *) pItem->data;\n\n          mxID           = var->mxID;\n          arrayFlags[0]  = mxID;\n          arrayFlags[0] |= var->logical;\n          arrayFlags[0] |= var->complex;\n          if (var->nDims < 2) {\n              dims         = _dims;\n              dims[0]      = var->nRows;\n              dims[1]      = var->nCols;\n              nDims        = 2;\n          } else {\n              int32_T k;\n              dims = (int32_T*)malloc(sizeof(int32_T)*(var->nDims+1));\n              for (k = 0; k < var->nDims; k++) {\n                  dims[k] = var->dims[k];\n              }\n              dims[var->nDims] = var->nRows;\n              nDims = var->nDims + 1;\n          }\n          itemName = var->name;\n          break;\n      }\n      case STRUCT_LOG_VAR_ITEM: {\n          const StructLogVar *var = (const StructLogVar *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = 1;\n          itemName      = var->name;\n          break;\n      }\n      case SIGNALS_STRUCT_ITEM: {\n          const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = var->numSignals;\n          itemName      = &SIGNALS_FIELD_NAME;\n          break;\n      }\n      default:\n        (void)fprintf(stderr,\"Unexpected itemKind=%d in rt_ProcessMatItem @B\\n\",\n                      itemKind);\n        retStat = -1;\n        goto EXIT_POINT;\n    }\n\n    /* array flags */\n    item.nbytes = 2*sizeof(uint32_T);\n    if (cmd) {\n        item.type = matUINT32;\n        item.data = arrayFlags;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* dimensions */\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    item.nbytes = nDims*sizeof(int32_T);\n    if (cmd) {\n        item.type = matINT32;\n        item.data = dims;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;            \n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* name */\n    item.nbytes = (int32_T)strlen(itemName);\n    if (cmd) {\n        item.type = matINT8;\n        item.data = (const char_T*) itemName;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        nBytesInItem += (item.nbytes <= 4) ? /*LINTED E_CAST_INT_TO_SMALL_INT*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n\n    if (itemKind == MATRIX_ITEM) {\n        const MatrixData *var   = (const MatrixData*) pItem->data;\n        int_T            matID  = rt_GetMatIdFromMxId(mxID);\n        size_t           elSize = var->elSize;\n\n        /* data */\n        item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n        if (cmd) {\n            item.type = matID;\n            item.data = var->re;\n            if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n        }\n        /* imaginary part */\n        if (var->complex) {\n            item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n            if (cmd) {\n                item.type = matID;\n                item.data = var->im;\n                if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                    retStat = 1;\n                    goto EXIT_POINT;\n                }\n            } else {\n                nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n            }\n        }\n    } else {  /* some type of structure item */\n        const char_T *fieldNames;\n        int_T        sizeofFieldNames;\n\n        /* field names */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = (const StructLogVar *) pItem->data;\n              fieldNames        = rtStructLogVarFieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n              fieldNames        = var->fieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @C\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n\n        /* write field names */\n        if (cmd) {\n            int32_T tmpInt = mxMAXNAM;\n\n            item.nbytes = sizeof(int32_T);\n            item.type   = matINT32;\n            item.data   = &tmpInt;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n\n            item.nbytes = sizeofFieldNames;\n            item.type   = matINT8;\n            item.data   = (const char_T*) fieldNames;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            /*LINTED E_CAST_INT_TO_SMALL_INT*/\n            nBytesInItem += matINT64_ALIGN( matTAG_SIZE + matTAG_SIZE +\n                                            sizeofFieldNames );\n        }\n\n        /* process each field of the structure */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = pItem->data;\n\n              /* time */\n              {\n                  const void *data = var->time;\n\n                  if (var->logTime) { /* time is a LogVar, get the MatrixData */\n                      data = &(((const LogVar*) (var->time))->data);\n                  }\n\n                  item.type = matMATRIX;\n                  item.data = data;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp,&item,MATRIX_ITEM)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM,0)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n\n              /* signals */\n              item.type = matMATRIX;\n              item.data = &(var->signals);\n              if (cmd) {\n                  if (rt_WriteItemToMatFile(fp,&item,SIGNALS_STRUCT_ITEM)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n              } else {\n                  if (rt_ProcessMatItem(fp, &item, SIGNALS_STRUCT_ITEM,0)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n                  nBytesInItem += item.nbytes + matTAG_SIZE;\n              }\n\n              /* block name */\n              if (var->blockName != NULL) {\n                  item.type = matMATRIX;\n                  item.data = var->blockName;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var        = pItem->data;\n              const LogVar        *values     = var->values;\n              const MatrixData    *dimensions = var->dimensions;\n              const MatrixData    *labels     = var->labels;\n              const MatrixData    *plotStyles = var->plotStyles;\n              const MatrixData    *titles     = var->titles;\n              const MatrixData    *blockNames = var->blockNames;\n              const MatrixData    *stateNames = var->stateNames;\n              const MatrixData    *crossMdlRef = var->crossMdlRef;\n              const boolean_T logValueDimensions = var->logValueDimensions;\n              int_T               i;\n\n              for (i = 0; i < var->numSignals; i++) {\n                  /* values */\n                  item.type = matMATRIX;\n                  item.data = &(values->data);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n\n                  if(logValueDimensions)\n                  {\n                      /* valueDimensions */\n                      /* Since the functions rt_WriteItemToMatFile and \n                         rt_ProcessMatItem deal with MatrixData, \n                         convert valDims to tempData, and fill up the\n                         necessary fields.\n                      */\n                      MatrixData  tempData;\n                      (void)memcpy(tempData.name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n                      tempData.nRows = values->valDims->nRows;\n                      tempData.nCols = values->valDims->nCols;\n                      tempData.nDims = 1;\n                      tempData._dims[0] = values->valDims->nCols;\n                      tempData.re = values->valDims->dimsData;\n                      tempData.im = NULL;\n                      tempData.dTypeID = SS_DOUBLE;\n                      tempData.elSize =  sizeof(real_T);\n                      tempData.mxID = mxDOUBLE_CLASS;\n                      tempData.logical = 0;\n                      tempData.complex = 0;\n                      tempData.frameData = 0;\n                      tempData.frameSize = 1;\n\n                      item.type = matMATRIX;                    \n                      item.data = &tempData; /*values->valDims;*/\n\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  values = values->next;\n\n                  /* dimensions */\n                  if (dimensions != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(dimensions[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n\n                  /* label */\n                  item.type = matMATRIX;\n                  item.data = &(labels[i]);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n                  /* title */\n                  if (titles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(titles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* plot style */\n                  if (plotStyles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(plotStyles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* block name */\n                  if (blockNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(blockNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* state name */\n                  if (stateNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(stateNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* crossMdlRef */\n                  if (crossMdlRef != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(crossMdlRef[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n              } /* for i=1:numSignals */\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @D\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n    } /* end struct item */\n\n    if (!cmd) {\n        pItem->nbytes = nBytesInItem;\n    }\n\n  EXIT_POINT:\n    if (dims != _dims) {\n        FREE(dims);\n    }\n    return(retStat);\n\n} /* end rt_ProcessMatItem */\n\n\n/* Function: rt_WriteItemToMatFile =============================================\n * Abstract:\n *      Entry function for writing out a mat item to the mat file.\n *\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind itemKind)\n{\n    /* Determine the item size */\n    if (pItem->type == matMATRIX) {\n        if (rt_ProcessMatItem(fp, pItem, itemKind, 0)) return(1);\n    }\n\n    /* Write the item tag and data */\n    if (pItem->nbytes > 4) {\n        int32_T nAlignBytes;\n\n        if (fwrite(pItem, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n\n        if (pItem->type == matMATRIX) {\n            if (rt_ProcessMatItem(fp, pItem, itemKind, 1)) return(1);\n        } else {\n            if ( fwrite(pItem->data, 1, pItem->nbytes, fp) !=\n                                                    ((size_t) pItem->nbytes) ) {\n                return(1);\n            }\n        }\n\n        /* Add offset for 8-byte alignment */\n        nAlignBytes = matINT64_ALIGN(pItem->nbytes) - pItem->nbytes;\n        if (nAlignBytes > 0) {\n            int pad[2] = {0, 0};\n            if ( fwrite(pad,1,nAlignBytes,fp) != ((size_t) nAlignBytes) ) {\n                return(1);\n            }\n        }\n    } else {\n        MatItem item = {0, 0, NULL};\n        item.type = ((uint32_T)(pItem->type))|(((uint32_T)(pItem->nbytes))<<16);\n        (void)memcpy(&item.nbytes, pItem->data, pItem->nbytes);\n        if (fwrite(&item, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n    }\n\n    return(0);\n\n} /* end rt_WriteItemToMatFile */\n\n\n/* Function: rt_WriteMat5FileHeader ============================================\n * Abstract:\n *      Function to write the mat file header.\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteMat5FileHeader(FILE *fp)\n{\n    int_T        nbytes;\n    int_T        nspaces;\n    int_T        i, n;\n    unsigned short ver[2];\n    char_T       spaces[16];\n    const char_T *matversion = \"MATLAB 5.0 MAT-file\";\n\n    (void)memset(spaces, ' ', sizeof(spaces));\n\n    n = (int_T)strlen(matversion);\n    nbytes = (int_T)fwrite(matversion, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    nspaces = matVERSION_INFO_OFFSET - nbytes;\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces % sizeof(spaces);\n    nbytes += (int_T)fwrite(spaces, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces / sizeof(spaces);\n    for (i = 0; i < n; ++i) {\n        nbytes += (int_T)fwrite(spaces, 1, sizeof(spaces), fp);\n    }\n    if (nbytes == matVERSION_INFO_OFFSET) {\n        ver[0] = matVERSION;\n        ver[1] = matKEY;\n        nbytes += (int_T)fwrite(ver, 1, sizeof(ver), fp);\n    }\n    return(nbytes != matVERSION_INFO_OFFSET + sizeof(ver));\n\n} /* end rt_WriteMat5FileHeader */\n\n\n/* Function: rt_FixupLogVar ====================================================\n * Abstract:\n *\tMake the logged variable suitable for MATLAB.\n */\nstatic const char_T *rt_FixupLogVar(LogVar *var,int verbose)\n{\n    int_T  nCols   = var->data.nCols;\n    int_T  maxRows = var->data.nRows;\n    int_T  nDims   = var->data.nDims;\n    size_t elSize  = var->data.elSize;\n    int_T  nRows   = (var->wrapped ?  maxRows : var->rowIdx);\n\n    var->nDataPoints = var->rowIdx + var->wrapped * maxRows;\n\n    if (var->wrapped > 1 || (var->wrapped == 1 && var->rowIdx != 0)) {\n        /*\n         * Warn the user the circular buffer has wrapped, implying that\n         * some data has been lost.\n         */\n        if( verbose) {\n            (void)fprintf(stdout,\n                          \"*** Log variable %s has wrapped %d times\\n\"\n                          \"    using a circular buffer of size %d\\n\",\n                          var->data.name, var->wrapped, var->data.nRows);\n        }\n        if (var->usingDefaultBufSize) {\n            /*\n             * If wrapping occurred using the default buffer size,\n             * let the user know what size buffer to use in the\n             * future to avoid wrapping.  If the default buffer\n             * size was not used, the user has no control to specify\n             * the correct value.  Wrapping may occur when not using\n             * the default buffer if we allocated too small a buffer\n             * size for this logvar.  One common case is a toWorkspace\n             * block inside of an iterative subsystem - we can not take\n             * the number of iterations into account (they may be\n             * variable) when allocating the buffer.  In this case,\n             * just warn the buffer wrapped and don't tell user they\n             * can override the buffer size.\n             */\n            if( verbose ) {\n                (void)fprintf(stdout,\n                              \"*** To avoid wrapping, explicitly specify a\\n\"\n                              \"    buffer size of %d in your Simulink model\\n\"\n                              \"    by adding OPTS=\\\"-DDEFAULT_BUFFER_SIZE=%d\\\"\\n\"\n                              \"    as an argument to the ConfigSet MakeCommand\\n\"\n                              \"    parameter\\n\",\n                              var->nDataPoints, var->nDataPoints);\n            }\n        }\n    }\n\n    if (nDims < 2 && nCols > 1) {  /* Transpose? */\n        /* Don't need to transpose valueDimensions */\n        int_T  nEl    = nRows*nCols;\n        char   *src   = var->data.re;\n        char   *pmT;\n        int_T  k;\n\n        /**********************************\n         * If memory cannot be allocated, *\n         * write to a temporary buffer    *\n         **********************************/\n        if ((pmT = malloc(nEl*elSize)) == NULL) {\n            FILE  *fptr;\n            char  fName[mxMAXNAM+13];\n\n            (void)sprintf(fName, \"%s%s\", var->data.name, \"_rtw_tmw.tmw\");\n            if ((fptr=fopen(fName,\"w+b\")) == NULL) {\n                (void)fprintf(stderr,\"*** Error opening %s\",fName);\n                return(\"unable to open data file\\n\");\n            }\n\n            /****************************\n             * Write the data to a file *\n             ****************************/\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nCols*(k%nRows) + (k/nRows);\n                char  *dst = src + kT*elSize;\n                (void)fwrite(dst, elSize, 1, fptr);\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n\n            /*******************************\n             * Read the data from the file *\n             *******************************/\n            (void)rewind(fptr);\n            (void)fread(var->data.re, elSize, nEl, fptr);\n            (void)fclose(fptr);\n            (void)remove(fName);\n        } else {\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nRows*(k%nCols) + (k/nCols);\n                char  *dst = pmT + kT*elSize;\n                (void)memcpy(dst, src, elSize);\n                src += elSize;\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n            FREE(var->data.re);\n            var->data.re = pmT;\n        }\n    } /* Transpose? */\n\n    if (var->wrapped > 0 && var->rowIdx != 0 ) {  /* Rotate? */\n        char_T *buffer    = var->data.re;\n        int_T  done       = 0; /* done: 0 (1) rotate real (imag) part. */\n\n        do {\n            char_T *col       = buffer;\n            int_T  rowOffset  = (int_T)((nDims == 1) ? (elSize) : (elSize * nCols));\n            int_T  colOffset  = (int_T)((nDims == 1)?  (nRows*elSize) : elSize);\n            int_T  zeroIdx    = var->rowIdx;\n            int_T  j;\n\n            for (j = 0 ; j < nCols; ++j, col += colOffset) {\n                int_T   swapCount;\n                int_T   srcIdx;\n                int_T   dstIdx;\n                int_T   tmpIdx;\n                MatReal tmp;\n\n                for (tmpIdx=0, swapCount=0; swapCount < nRows; tmpIdx++) {\n                    (void)memcpy(&tmp, col + tmpIdx*rowOffset, elSize);\n\n                    dstIdx=tmpIdx; \n                    srcIdx = ((dstIdx + zeroIdx) % nRows);\n                    while (srcIdx != tmpIdx) {\n                        (void)memcpy(col + dstIdx*rowOffset,\n                                     col + srcIdx*rowOffset,\n                                     elSize);\n                        ++swapCount;\n                        dstIdx = srcIdx;\n                        srcIdx = ((dstIdx + zeroIdx) % nRows);\n                        \n                    }\n                    (void)memcpy(col + dstIdx*rowOffset, &tmp, elSize);\n                    ++swapCount;\n                }\n            }\n            done ++;\n            /* need to rotate the imaginary part */\n        } while ((done == 1) && ((buffer = var->data.im) != NULL));\n\n        var->rowIdx = 0;\n    } /* Rotate? */\n\n    /*\n     * We might have allocated more number of rows than the number of data\n     * points that have been logged, in which case set nRows to nDataPoints\n     * so that only these values get saved.\n     */\n    if (var->nDataPoints < var->data.nRows) {\n        var->data.nRows = var->nDataPoints;\n        if(var->valDims != NULL){\n            size_t elSizeValDims = sizeof(real_T);\n            int_T  k;\n            real_T *dimsData = var->valDims->dimsData + nRows;\n            /* \n               Keep nRows of values and that of valueDimensions consistent \n               for variable-size signals.\n            */\n            var->valDims->nRows = var->data.nRows;\n            /*\n               Also need to move data when shrinking the array size,\n               because valueDimensions data is stored in array format. \n               e.g. maxRows = 4; nRows = 2; nDims = 3;\n               Before fixing up the logVar, the locations of data are as below:\n               (x, y, z -- useful data / o -- junk)\n               a[0] = x    a[4] = y    a[8] = z\n               a[1] = x    a[5] = y    a[9] = z\n               a[2] = o    a[6] = o    a[10]= o\n               a[3] = o    a[7] = o    a[11]= o\n               After fixing up the logVar, we want the data to be stored as:\n               a[0] = x    a[4] = z    a[8] = o\n               a[1] = x    a[5] = z    a[9] = o\n               a[2] = y    a[6] = o    a[10]= o\n               a[3] = y    a[7] = o    a[11]= o\n            */\n            for(k = 1; k < nDims; k++){\n                (void) memmove(dimsData, \n                              var->valDims->dimsData + k*maxRows,\n                              elSizeValDims * nRows);\n                dimsData += nRows;\n            }\n        }\n    }\n    return(NULL);\n\n} /* end rt_FixupLogVar */\n\n\n/* Function: rt_LoadModifiedLogVarName =========================================\n * Abstract:\n *      The name of the logged variable is obtained from the input argument\n *      varName and the nameModifier which is obtained from the simstruct. If\n *      the nameModifier begins with an '_', then nameModifier is post-pended to\n *      varName to obtain the name of the logged variable. If the first\n *      character does not begin with an '_', then the nameModifier is\n *      pre-pended to varName.\n *\n * Examples:\n *     a)  varName = \"tout\" & nameModifier = \"_rt\"  => logVarName = \"tout_rt\"\n *     b)  varName = \"tout\" & nameModifier = \"rt_\"  => logVarName = \"rt_tout\"\n *     c)  varName = \"tout\" & nameModifier = \"none\" => logVarName = \"tout\"\n */\nstatic void rt_LoadModifiedLogVarName(const RTWLogInfo *li,         /* in  */\n                                      const char       *varName,    /* in  */\n                                      char             *logVarName) /* out */\n{\n    int_T        nameLen;\n    const char_T *nameModifier = rtliGetLogVarNameModifier(li);\n\n    if (nameModifier != NULL && strcmp(nameModifier,\"none\")==0) {\n        nameModifier = NULL;\n    }\n\n    logVarName[mxMAXNAM-1] = '\\0';\n    if (nameModifier == NULL) {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n    } else if (nameModifier[0] == '_') {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, nameModifier, (size_t)mxMAXNAM-1-nameLen);\n    } else {\n        (void)strncpy(logVarName, nameModifier, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, varName, (size_t)mxMAXNAM-1-nameLen);\n    }\n\n} /* end rt_LoadModifiedLogVarName */\n\n\n/* Function: rt_GetActualDTypeID ===============================================\n * Abstract:\n *\tGiven a built-in data type id, return the actual data type id.\n *\tThe only time these are different is when real_T has been mapped\n *\tto a single.\n */\n#if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable: 4127)\n#endif\nstatic BuiltInDTypeId rt_GetActualDTypeID(BuiltInDTypeId dTypeID)\n{\n    /*LINTED E_FALSE_LOGICAL_EXPR*/\n    if (dTypeID == SS_DOUBLE && sizeof(real_T) != 8) {     /* polyspace DEFECT:DEAD_CODE \n                                                              [Not a defect:Unset] \n                                                              \"Needed for when real_T has been \n                                                              mapped to a single\" */\n        return(SS_SINGLE);\n    } else {\n        return(dTypeID);\n    }\n\n} /* end rt_GetActualDTypeID */\n#if defined(_MSC_VER)\n #pragma warning(pop)\n#endif\n\n\n/* Function: rt_DestroyLogVar ==================================================\n * Abstract:\n *      Destroy the log var linked list.\n */\nstatic void rt_DestroyLogVar(LogVar *head)\n{\n    while(head) {\n        LogVar *var = head;\n        head = var->next;\n        FREE(var->data.re);\n        FREE(var->data.im);\n        if (var->data.dims != var->data._dims) {\n            FREE(var->data.dims);\n        }\n        /* free valDims if necessary */\n        if(var->valDims != NULL) {\n            FREE(var->valDims->dimsData);\n            FREE(var->valDims);\n        }\n        /* free coords, strides and currStrides if necessary */\n        FREE(var->coords);\n        FREE(var->strides);\n        FREE(var->currStrides);\n\n        FREE(var);\n    }\n\n} /* end rt_DestroyLogVar */\n\n\n/* Function: rt_DestroyStructLogVar ============================================\n * Abstract:\n *      Destroy the struct log var linked list.\n */\nstatic void rt_DestroyStructLogVar(StructLogVar *head)\n{\n    while(head) {\n        StructLogVar *var = head;\n\n        head = var->next;\n\n        if (var->logTime) { /* time is LogVar */\n            rt_DestroyLogVar(var->time);\n        } else {        /* time is MatrixData */\n            FREE(var->time);\n        }\n        rt_DestroyLogVar(var->signals.values);\n        FREE(var->signals.labels);\n        FREE(var->signals.plotStyles);\n        FREE(var->signals.dimensions);\n        FREE(var->signals.titles);\n        FREE(var->signals.blockNames);\n        FREE(var->signals.stateNames);\n        FREE(var->signals.crossMdlRef);\n        FREE(var->blockName);\n        FREE(var);\n    }\n\n} /* end rt_DestroyStructLogVar */\n\n\n/* Function: rt_InitSignalsStruct ==============================================\n * Abstract:\n *      Initialize the signals structure in the struct log variable.\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nstatic const char_T *rt_InitSignalsStruct(RTWLogInfo             *li,\n                                          const real_T           startTime,\n                                          const real_T           finalTime,\n                                          const real_T           inStepSize,\n                                          const char_T           **errStatus,\n                                          StructLogVar           *var,\n                                          int_T                  maxRows,\n                                          int_T                  decimation,\n                                          real_T                 sampleTime,\n                                          const RTWLogSignalInfo *sigInfo)\n{\n    int_T                i, sigIdx;\n    SignalsStruct        *sig          = &(var->signals);\n    int_T                nSignals      = sigInfo->numSignals;\n    const int_T          *numCols      = sigInfo->numCols;\n    const int_T          *numDims      = sigInfo->numDims;\n    const int_T          *dims         = sigInfo->dims;\n    const BuiltInDTypeId *dTypes       = sigInfo->dataTypes;\n    const int_T          *cSgnls       = sigInfo->complexSignals;\n    const int_T          *fData        = sigInfo->frameData;\n    const char_T         **labels      = sigInfo->labels.cptr;\n    const int_T          *plotStyles   = sigInfo->plotStyles;\n    const char_T         *titles       = sigInfo->titles;\n    const int_T          *titleLen     = sigInfo->titleLengths;\n    const char_T         **blockNames  = sigInfo->blockNames.cptr;\n    const char_T         **stateNames  = sigInfo->stateNames.cptr;\n    const boolean_T      *crossMdlRef  = sigInfo->crossMdlRef;\n    void                 **currSigDims = sigInfo->currSigDims;\n    int_T                *currSigDimsSize = sigInfo->currSigDimsSize;\n    LogVar               *prevValues   = NULL;\n    int_T                dimsOffset    = 0;\n    boolean_T            *isVarDims    = sigInfo->isVarDims;\n    /* if any signal is variable-size, the field 'valueDimensions' is needed */\n    boolean_T            logValueDimensions = false;\n    const RTWLogDataTypeConvert *pDTConvInfo = sigInfo->dataTypeConvert;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    sig->numActiveFields = 1;\n    sig->numSignals      = nSignals;\n\n    sig->isVarDims = isVarDims;\n    /* check whether we need valueDimensions field*/\n    for (i=0; i<nSignals; i++){\n        if(isVarDims[i]){\n            logValueDimensions = true;\n            break;\n        }\n    }\n\n    /* values */\n    dimsOffset = 0;\n    for (i = 0; i < nSignals; i++) {\n        BuiltInDTypeId dt = (dTypes) ? dTypes[i] : SS_DOUBLE;\n        int_T          cs = (cSgnls) ? cSgnls[i] : 0;\n        int_T          fd = (fData)  ? fData[i]  : 0;\n        int_T          nd = (numDims) ? numDims[i] : 1;\n\n        const RTWLogDataTypeConvert *pDTConvInfoCur =\n                       (pDTConvInfo)  ? (pDTConvInfo+i)  : 0;\n\n        LogVar *values = NULL;\n        LogValDimsStat logValDimsStat;\n\n        if(!logValueDimensions){\n            logValDimsStat = NO_LOGVALDIMS;\n        }\n        else{\n            logValDimsStat = isVarDims[i] ? LOGVALDIMS_VARDIMS :  \n                                            LOGVALDIMS_EMPTYMX;\n        }\n\n        values = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                            inStepSize, errStatus,\n                                            &VALUES_FIELD_NAME,\n                                            dt, \n                                            pDTConvInfoCur,\n                                            0, cs, fd,\n                                            numCols[i],nd,\n                                            dims + dimsOffset,\n                                            logValDimsStat,\n                                            currSigDims + dimsOffset,\n                                            currSigDimsSize + dimsOffset,\n                                            maxRows,decimation,sampleTime, 0);\n\n        if (values == NULL) goto ERROR_EXIT;\n\n        if (sig->values == NULL) {\n            sig->values = values;\n        } else {\n            if (prevValues == NULL) goto ERROR_EXIT;\n            prevValues->next = values;\n        }\n        prevValues = values;\n        dimsOffset += nd;\n    }\n\n    if(logValueDimensions){\n        ++sig->numActiveFields;\n        sig->logValueDimensions = true;\n    }\n    else{\n        sig->logValueDimensions = false;\n    }\n\n    /* Dimensions */\n    {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            int_T nd = (numDims) ? numDims[i] : 1;\n            dataLen += nd;\n        }\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->dimensions = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->dimensions)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n          data[i] = dims[i]; /* cannot memcpy double <- int */\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->dimensions[i]);\n            int_T nd = (numDims) ? numDims[i] : 1;\n\n            (void)memcpy(mtxData->name, &DIMENSION_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = 1;\n            mtxData->nCols   = nd;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += nd;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* labels */\n    if (labels != NULL) {\n        unsigned short   *data;\n        size_t  nbytes;\n        int_T   dataLen    = 0;\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (labels[i] != NULL){\n                dataLen = dataLen + (int_T)strlen(labels[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->labels = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->labels)) + dataOffset);\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T labelLen = (labels[sigIdx]==NULL) ? 0 : (int_T)strlen(labels[sigIdx]);\n            for (i = 0; i < labelLen; i++) {\n                data[dataIdx++] = (uint8_T)labels[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->labels[i]);\n            int_T labelLen = (int_T)strlen(labels[i]);\n\n            (void)memcpy(mtxData->name, &LABEL_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (labelLen) ? 1 : 0;\n            mtxData->nCols   = labelLen;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += labelLen;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* plot styles */\n    if (plotStyles != NULL) {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            dataLen += numCols[i];\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->plotStyles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (real_T*) (((char_T*) (sig->plotStyles)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n            data[i] = plotStyles[i];\n        }\n\n        dimsOffset = 0;\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->plotStyles[i]);\n            \n            (void)memcpy(mtxData->name, &PLOTSTYLE_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = (numCols[i]) ? 1 : 0;\n            mtxData->nCols   = numCols[i];\n\n            mtxData->nDims   = numDims[i];\n            \n            if(mtxData->nDims > 2) {\n                if ((mtxData->dims = calloc(mtxData->nDims, sizeof(int_T))) == NULL) goto ERROR_EXIT;\n            } else {\n                mtxData->dims    = mtxData->_dims;\n            }\n            \n            mtxData->dims[0] = *(dims + dimsOffset);\n            if(mtxData->nDims >= 2) {\n                int32_T j;\n                for (j=1; j<mtxData->nDims; j++) {\n                    mtxData->dims[j] = *(dims + dimsOffset + j);\n                }\n            }\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data       += numCols[i];\n            dimsOffset += numDims[i];\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* titles */\n    if (titles != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen    = (int_T)strlen(titles);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->titles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (unsigned short*) (((char_T*) (sig->titles)) + dataOffset);\n        for (i = 0; i < dataLen; i++) {\n            data[i] = titles[i];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->titles[i]);\n\n            (void)memcpy(mtxData->name, &TITLE_FIELD_NAME, mxMAXNAM);\n            if (titleLen) {\n                mtxData->nRows   = (titleLen[i]) ? 1 : 0;\n                mtxData->nCols   = titleLen[i];\n            } else {\n                mtxData->nRows   = (dataLen) ? 1 : 0;\n                mtxData->nCols   = dataLen;\n            }\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += ((titleLen) ? titleLen[i] : dataLen);\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* block names */\n    if (blockNames != NULL)     {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (blockNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(blockNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->blockNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->blockNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (blockNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(blockNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)blockNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->blockNames[i]);\n            int_T blockNameLen = (int_T)strlen(blockNames[i]);\n\n            (void)memcpy(mtxData->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (blockNameLen) ? 1 : 0;\n            mtxData->nCols   = blockNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += blockNameLen;\n        }\n        ++sig->numActiveFields;\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    } else {\n        if(logValueDimensions){\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* state names */\n    if (stateNames != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (stateNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(stateNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->stateNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->stateNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (stateNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(stateNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)stateNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->stateNames[i]);\n            int_T stateNameLen = (int_T)strlen(stateNames[i]);\n\n            (void)memcpy(mtxData->name, &STATENAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (stateNameLen) ? 1 : 0;\n            mtxData->nCols   = stateNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += stateNameLen;\n        }\n        ++sig->numActiveFields;\n\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* CrossMdlRef */\n    if (crossMdlRef != NULL) {\n        real_T  *data;\n        size_t nbytes;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n\n        nbytes = dataOffset + nSignals*sizeof(real_T);\n\n        if ( (sig->crossMdlRef = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->crossMdlRef)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            data[sigIdx] = crossMdlRef[sigIdx];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->crossMdlRef[i]);\n\n            (void)memcpy(mtxData->name, &CROSS_MDL_REF_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = 1;\n            mtxData->nCols   = 1;\n            mtxData->nDims   = 1; /* => matlab scalar */\n\n            mtxData->re      = &data[i];\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_DOUBLE;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(SS_DOUBLE);\n            mtxData->elSize  = sizeof(real_T);\n            mtxData->logical = matLOGICAL_BIT;\n            mtxData->complex = 0U;\n            mtxData->frameData = 0;\n            mtxData->frameSize = 1;\n        }\n        ++sig->numActiveFields;\n    }\n    \n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n\n    (void)fprintf(stderr, \"*** Error creating signals structure \"\n                  \"in the struct log variable %s\\n\", var->name);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyLogVar(sig->values);\n    FREE(sig->labels);\n    FREE(sig->plotStyles);\n    FREE(sig->dimensions);\n    FREE(sig->titles);\n    FREE(sig->blockNames);\n    FREE(sig->stateNames);\n    FREE(sig->crossMdlRef);\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\n\n/* Function: local_CreateStructLogVar ==========================================\n * Abstract:\n *      Create a logging variable in the structure format.\n *\n * Returns:\n *      ~= NULL  => success, returns the log variable created.\n *      == NULL  => failure, error message set in the simstruct.\n */\nstatic StructLogVar *local_CreateStructLogVar(\n    RTWLogInfo              *li,\n    const real_T            startTime,\n    const real_T            finalTime,\n    const real_T            inStepSize,\n    const char_T            **errStatus,\n    const char_T            *varName,\n    boolean_T               logTime,\n    int_T                   maxRows,\n    int_T                   decimation,\n    real_T                  sampleTime,\n    const RTWLogSignalInfo  *sigInfo,\n    const char_T            *blockName)\n{\n    StructLogVar *var;\n    LogInfo      *logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ( (var = calloc(1, sizeof(StructLogVar))) == NULL ) goto ERROR_EXIT;\n\n    var->numActiveFields = 2;\n\n    /* Setup the structure name using varName and nameModifier */\n    rt_LoadModifiedLogVarName(li,varName,var->name);\n\n    /* time field */\n    if (logTime) {\n        /* need to create a LogVar to log time */\n        int_T dims = 1;\n        var->time = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                               inStepSize, errStatus,\n                                               &TIME_FIELD_NAME, SS_DOUBLE, \n                                               NULL,\n                                               0, 0, 0, 1,\n                                               1, &dims, NO_LOGVALDIMS, \n                                               NULL, NULL, maxRows,\n                                               decimation, sampleTime, 0);\n        if (var->time == NULL) goto ERROR_EXIT;\n    } else {\n        /* create a dummy MatrixData to write out time as an empty matrix */\n        BuiltInDTypeId dt     = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         nbytes = sizeof(MatrixData);\n        MatrixData     *time;\n\n        if ( (var->time = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n        time = var->time;\n\n        (void)memcpy(time->name, &TIME_FIELD_NAME, mxMAXNAM);\n        time->nRows   = 0;\n        time->nCols   = 0;\n        time->nDims   = 0;\n        time->re      = NULL;\n        time->im      = NULL;\n        time->dTypeID = dt;\n        time->mxID    = rt_GetMxIdFromDTypeId(dt);\n        time->elSize  = rt_GetSizeofDataType(dt);\n        time->logical = 0U;\n        time->complex = 0U;\n    }\n    var->logTime = logTime;\n\n    /* signals field */\n    if (sigInfo) {\n        if (rt_InitSignalsStruct(li,startTime,finalTime,inStepSize,errStatus,\n                                 var,maxRows,decimation,sampleTime,sigInfo)) {\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* blockName Field */\n    if (blockName != NULL) {\n        int_T  dataLen = (int_T)strlen(blockName);\n        size_t nbytes;\n        size_t dataOffset = sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (var->blockName = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        (void)memcpy(var->blockName->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n        var->blockName->nRows   = (dataLen) ? 1 : 0;\n        var->blockName->nCols   = dataLen;\n\n        var->blockName->nDims   = 1;\n        var->blockName->dims    = var->blockName->_dims;\n        var->blockName->dims[0] = dataLen;\n        {\n            /*LINTED E_BAD_PTR_CAST_ALIGN*/\n            unsigned short *data = (unsigned short*)(((char_T*) (var->blockName))+dataOffset);\n            int_T   i;\n\n            for (i=0; i<dataLen; i++) {\n                data[i] = (uint8_T)blockName[i];\n            }\n            var->blockName->re  = data;\n        }\n        var->blockName->im      = NULL;\n        var->blockName->dTypeID = SS_INT16;\n        var->blockName->mxID    = mxCHAR_CLASS;\n        var->blockName->elSize  = sizeof(short);\n        var->blockName->logical = 0U;\n        var->blockName->complex = 0U;\n\n        ++var->numActiveFields;\n    }\n\n    /* Add this struct log var to the linked list in log info */\n    {\n        StructLogVar *list = logInfo->structLogVarsList;\n\n        if (list != NULL) {\n            while (list->next != NULL) {\n                list = list->next;\n            }\n            list->next = var;\n        } else {\n            logInfo->structLogVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Error creating log variable %s\\n\", varName);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyStructLogVar(var);\n    return(NULL);\n\n} /* end local_CreateStructLogVar */\n\n\n/* Function: rt_StartDataLoggingForOutput ======================================\n * Abstract:\n */\nstatic const char_T *rt_StartDataLoggingForOutput(RTWLogInfo   *li,\n                                                  const real_T startTime,\n                                                  const real_T finalTime,\n                                                  const real_T stepSize,\n                                                  const char_T **errStatus)\n{\n    const char_T   *varName;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    LogInfo *       logInfo;\n    logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    /* outputs */\n    varName = rtliGetLogY(li);\n    if (varName[0] != '\\0') {\n        int_T                  i;\n        int_T                  ny;\n        int_T                  yIdx;\n        char_T                 name[mxMAXNAM];\n        const char_T           *cp        = strchr(varName,',');\n        LogSignalPtrsType      ySigPtrs   = rtliGetLogYSignalPtrs(li);\n        const RTWLogSignalInfo *yInfo     = rtliGetLogYSignalInfo(li);\n\n        /* count the number of variables (matrices or structures) to create */\n        for (ny=1; cp != NULL; ny++) {\n            cp = strchr(cp+1,',');\n        }\n        logInfo->ny = ny;\n\n        if (logFormat==0) {\n            if ( (logInfo->y = calloc(ny,sizeof(LogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        } else {\n            if ( (logInfo->y = calloc(ny,sizeof(StructLogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        }\n\n        for (i = yIdx = 0, cp = varName; i < ny; i++) {\n            int_T        len;\n            const char_T *cp1 = strchr(cp+1,',');\n\n            if (cp1 != NULL) {\n                /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n                len = (int_T)(cp1 - cp);\n                if (len >= mxMAXNAM) len = mxMAXNAM - 1;\n            } else {\n                len = mxMAXNAM - 1;\n            }\n            (void)strncpy(name, cp, len);\n            name[len] = '\\0';\n\n            if (ny > 1 && ySigPtrs[i] == NULL) {\n                goto NEXT_NAME;\n            }\n\n            if (logFormat == 0) {\n                int            numCols;\n                int            nDims;\n                const int      *dims;\n                BuiltInDTypeId dataType;\n                int            isComplex;\n\n                if (ny == 1) {\n                    int_T op;\n\n                    numCols = yInfo[0].numCols[0];\n                    for (op = 1; op < yInfo[0].numSignals; op++) {\n                        numCols += yInfo[0].numCols[op];\n                    }\n                    /*\n                     * If we have only one \"matrix\" outport,\n                     * we can still log it as a matrix\n                     */\n                    if (yInfo[0].numSignals == 1) {\n                        nDims = yInfo[0].numDims ? yInfo[0].numDims[0] : 1;\n                        dims  = yInfo[0].dims;\n                    } else {\n                        nDims = 1;\n                        dims  = &numCols;\n                    }\n\n                    dataType  = yInfo[0].dataTypes[0];\n                    isComplex = yInfo[0].complexSignals[0];\n                } else {\n                    numCols   = yInfo[yIdx].numCols[0];\n                    nDims     = yInfo[yIdx].numDims ? yInfo[yIdx].numDims[0] : 1;\n                    dims      = yInfo[yIdx].dims;\n                    dataType  = yInfo[yIdx].dataTypes[0];\n                    isComplex = yInfo[yIdx].complexSignals[0];\n                }\n\n                logInfo->y[yIdx] = rt_CreateLogVarWithConvert(\n                    li, startTime, finalTime,\n                    stepSize, errStatus,\n                    name,\n                    dataType,\n                    yInfo[yIdx].dataTypeConvert,\n                    0,isComplex,\n                    0,numCols,nDims,dims,\n                    NO_LOGVALDIMS, NULL, NULL,\n                    maxRows,decimation,\n                    sampleTime,1);\n                if (logInfo->y[yIdx] == NULL)  goto ERROR_EXIT;\n            } else {\n                logInfo->y[yIdx] = local_CreateStructLogVar(li, startTime,\n                                                            finalTime, stepSize,\n                                                            errStatus, name,\n                                                            logTime, maxRows,\n                                                            decimation, sampleTime,\n                                                            &yInfo[yIdx], NULL);\n                if (logInfo->y[yIdx] == NULL) goto ERROR_EXIT;\n            }\n            ++yIdx;\n        NEXT_NAME:\n            cp = cp1;\n            if (cp != NULL && *cp == ',') cp++;\n        }\n    }\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) { /* polyspace DEFECT:USELESS_IF [No action planned:Unset] \n                     \"Defense coding.\" */\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo->y);\n        logInfo->y = NULL;\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingForOutput */\n\n\n/* Function: rt_ReallocLogVar ==================================================\n * Abstract:\n *   Allocate more memory for the data buffers in the log variable.\n *   Exit if unable to allocate more memory.\n */\nstatic void rt_ReallocLogVar(LogVar *var, boolean_T isVarDims)\n{\n    void *tmp;\n    int_T nCols = var->data.nCols;\n    int_T nRows;\n    size_t elSize = var->data.elSize;\n\n    if (isVarDims)\n    {\n        nRows = var->data.nRows + DEFAULT_BUFFER_SIZE;\n    }\n    else\n    {\n        nRows = var->data.nRows == 0 ? 1 : 2*var->data.nRows;\n    }\n    \n    tmp = realloc(var->data.re, nRows*nCols*elSize);\n    if (tmp == NULL) {\n        (void)fprintf(stderr,\n                      \"*** Memory allocation error.\\n\");\n        (void)fprintf(stderr, \"\"\n                      \"    varName          = %s%s\\n\"\n                      \"    nRows            = %d\\n\"\n                      \"    nCols            = %d\\n\"\n                      \"    elementSize      = %lu\\n\"\n                      \"    Current Size     = %.16g\\n\"\n                      \"    Failed resize    = %.16g\\n\\n\",\n                      var->data.name,\n                      var->data.complex ? \" (real part)\" : \"\",\n                      var->data.nRows,\n                      var->data.nCols,\n                      (unsigned long)  var->data.elSize,\n                      (double)nRows*nCols*elSize,\n                      (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n        exit(1);\n    }\n    var->data.re = tmp;\n\n    if (var->data.complex) {\n        tmp = realloc(var->data.im, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s (complex part)\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->data.name,\n                          var->data.nRows,\n                          var->data.nCols,\n                          (unsigned long)  var->data.elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n        var->data.im = tmp;\n    }\n    var->data.nRows = nRows;\n\n    /* Also reallocate memory for \"valueDimensions\" \n       when logging the variable-size signal\n    */\n    if(isVarDims){\n        int_T k;\n        \n        nCols = var->valDims->nCols;\n        nRows = var->valDims->nRows + DEFAULT_BUFFER_SIZE;\n        elSize = sizeof(real_T);\n        tmp = realloc(var->valDims->dimsData, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->valDims->name,\n                          var->valDims->nRows,\n                          var->valDims->nCols,\n                          (unsigned long)  elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n\n        /*\n         * valueDimensions data is stored in array format and must be\n         * adjusted after reallocation (see also rt_FixupLogVar())\n         *\n         * Example: maxRows = 4; nRows = 4; nDims = 3;\n         * Before realloc of the logVar, the locations of data are as below:\n         * (x, y, z -- useful data / o -- junk, don't care)\n         * a[0] = x    a[4] = y    a[8] = z\n         * a[1] = x    a[5] = y    a[9] = z\n         * a[2] = x    a[6] = y    a[10]= z\n         * a[3] = x    a[7] = y    a[11]= z\n         *\n         * After realloc of the logVar (suppose 2 extra rows are added),\n         * the locations of data are as below:\n         * a[0] = x    a[6] = y    a[12]= o\n         * a[1] = x    a[7] = y    a[13]= o\n         * a[2] = x    a[8] = z    a[14]= o\n         * a[3] = x    a[9] = z    a[15]= o\n         * a[4] = y    a[10]= z    a[16]= o\n         * a[5] = y    a[11]= z    a[17]= o\n         *\n         * The data must be adjusted as below:\n         * a[0] = x    a[6] = y    a[12]= z\n         * a[1] = x    a[7] = y    a[13]= z\n         * a[2] = x    a[8] = y    a[14]= z\n         * a[3] = x    a[9] = y    a[15]= z\n         * a[4] = o    a[10]= o    a[16]= o\n         * a[5] = o    a[11]= o    a[17]= o\n         */\n        for(k = var->data.nDims-1; k > 0; k--){\n            (void) memcpy((real_T*)tmp + k*nRows, \n                          (real_T*)tmp + k*var->valDims->nRows,\n                          elSize * var->valDims->nRows);\n        }\n\n        var->valDims->dimsData = tmp;\n        var->valDims->nRows = nRows;\n    }\n\n} /* end rt_ReallocLogVar */\n\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs);\n                                             \n/* Function: rt_UpdateLogVarWithDiscontinuousData ==============================\n * Abstract:\n *      Log one row of the LogVar with data that is not contiguous.\n */\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs)\n{\n    size_t elSize = 0;\n    size_t offset = 0;\n    int    segIdx = 0;\n\n    if (++var->numHits % var->decimation) return(NULL);\n    var->numHits = 0;\n\n    /*\n     * Reallocate or wrap the LogVar\n     */\n    if (var->rowIdx == var->data.nRows) {\n        if (var->okayToRealloc == 1) {\n            rt_ReallocLogVar(var, false);\n        } else {\n            /* Circular buffer */\n            var->rowIdx = 0;\n            ++(var->wrapped); /* increment the wrap around counter */\n        }\n    }\n\n    /* This function is only used to log states, there's no var-dims issue. */\n    elSize = var->data.elSize;\n    offset = (size_t)(elSize * var->rowIdx * var->data.nCols);\n\n    if (var->data.complex) {\n        char_T *dstRe = (char_T*)(var->data.re) + offset;\n        char_T *dstIm = (char_T*)(var->data.im) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            int_T         nEl  = segmentLengths[segIdx];\n            char_T *src        = (char_T *)data[segIdx];\n            int_T         el;\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(elSize * nEl * 2);\n                preprocessingPtr(src, (void *)data[segIdx]);\n            }\n\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);\n            }\n            else {\n                for (el = 0; el < nEl; el++) {\n                    (void)memcpy(dstRe, src, elSize);\n                    dstRe += elSize;   src += elSize;\n                    (void)memcpy(dstIm, src, elSize);\n                    dstIm += elSize;   src += elSize;\n                }\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    } else {\n        char_T *dst = (char_T*)(var->data.re) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            size_t      segSize = elSize*segmentLengths[segIdx];\n            char_T *src         = (void *) data[segIdx];\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(segSize);\n                preprocessingPtr(src, data[segIdx]);\n            }\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);            }\n            else {\n                (void)memcpy(dst, src, segSize);\n                dst += segSize;\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    }\n\n    ++var->rowIdx;\n    return(NULL);\n\n} /* end rt_UpdateLogVarWithDiscontinuousData */\n\n\n/*==================*\n * Visible routines *\n *==================*/\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_CreateLogVarWithConvert ========================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVarWithConvert(\n    RTWLogInfo        *li,\n    const real_T      startTime,\n    const real_T      finalTime,\n    const real_T      inStepSize,\n    const char_T      **errStatus,\n    const char_T      *varName,\n    BuiltInDTypeId    inpDataTypeID,\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    int_T             logical,\n    int_T             complex,\n    int_T             frameData,\n    int_T             nCols,\n    int_T             nDims,\n    const int_T       *dims,\n    LogValDimsStat    logValDimsStat,\n    void              **currSigDims,\n    int_T             *currSigDimsSize,\n    int_T             maxRows,\n    int_T             decimation,\n    real_T            sampleTime,\n    int_T             appendToLogVarsList)\n{\n    int_T          usingDefaultBufSize = 0;\n#ifdef NO_LOGGING_REALLOC\n    int_T          okayToRealloc       = 0;\n#else\n    int_T          okayToRealloc       = 1;\n#endif\n    LogVar         *var                = NULL;\n    /*inpDataTypeID is the rt_LoggedOutputDataTypeId*/\n    BuiltInDTypeId dTypeID             = (BuiltInDTypeId)inpDataTypeID; \n    size_t         elementSize         = rt_GetSizeofDataType(dTypeID);\n    int_T          frameSize;\n    int_T          nRows;\n    int_T          nColumns;\n\n    /*===================================================================*\n     * Determine the frame size if the data is frame based               *\n     *===================================================================*/\n    frameSize = frameData ? dims[0] : 1;\n\n    /*===================================================================*\n     * Calculate maximum number of rows needed in the buffer             *\n     *===================================================================*/\n\n    if (finalTime > startTime && finalTime != rtInf) {\n        real_T nPoints;            /* Tfinal is finite  ===>  nRows can be  */\n        real_T stepSize;           /* computed since the StepSize is fixed  */\n\n        if (sampleTime == -2.0) {  /* The signal being logged is constant,  *\n                                    * Hence, only one data point is logged. */\n            stepSize = finalTime;\n        } else if (sampleTime == -1.0 || sampleTime == 0.0) {\n                                /* Signal being logged is either inside a    *\n                                 * triggered sub-system or it is continuous. */\n            stepSize = inStepSize;\n        } else {                /* Discrete signal */\n            stepSize = sampleTime;\n        }\n\n        if (stepSize == 0.0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {\n            nPoints = 1.0 + floor((finalTime-startTime)/stepSize);\n\n            /*\n             * Add one more data point if needed.\n             */\n            if ( stepSize*(nPoints-1.0) < (finalTime-startTime) ) {\n                nPoints += 1.0;\n            }\n\n            /*\n             * Actual number of points to log = nPoints * size of\n             * each frame if data is frame-based\n             */\n            nPoints = frameData ? (nPoints * frameSize) : nPoints;\n\n            nPoints /= decimation;\n            if (nPoints != floor(nPoints)) {\n                nPoints += 1.0;\n            }\n            nRows = (nPoints <= INT_MAX) ? ((int_T) nPoints) : INT_MAX;\n        }\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (finalTime == startTime) {\n        /*\n         * Number of rows to log is equal to 1 if not frame-based and\n         * equal to frame size if frame-based\n         */\n        nRows = frameData ? frameSize : 1;\n\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (maxRows > 0) {     /* maxRows is specified => nRows=maxRows  */\n        nRows = maxRows;\n        okayToRealloc = 0;\n    } else {\n\n        if (inStepSize == 0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {                    /* Use a default value for nRows          */\n            usingDefaultBufSize = 1;\n            nRows = DEFAULT_BUFFER_SIZE;\n            okayToRealloc = 0;  /* No realloc with infinite stop time */\n            (void)fprintf(stdout, \"*** Using a default buffer of size %d for \"\n                          \"logging variable %s\\n\", nRows, varName);\n        }\n    }\n\n    /*\n     * Figure out the number of columns that the log variable should have.\n     * If the data is not frame based, then number of columns should equal\n     * nCols that is provided as input to the function. If the data is\n     * frame-based, then the number of columns should be equal to the\n     * number of channels = nCols/frameSize = dims[1];\n     */\n    nColumns = frameData ? dims[1] : nCols;\n\n    /*\n     * Error out if the size of the circular buffer is absurdly large, this\n     * error message is more informative than the one we get when we try to\n     * malloc this many number of bytes in one fell swoop.\n     */\n    {\n        double tmpDbl = ((double)elementSize)*((double)nRows)*\n                                              ((double)nColumns);\n\n        if (tmpDbl >= UINT_MAX) {\n            (void)fprintf(stderr,\n                          \"\\n*** Memory required to log variable '%s' is too\"\n                          \"\\n    big. Use the 'Limit rows to last:' and (or)\"\n                          \"\\n    'Decimation:' options to reduce the required\"\n                          \"\\n    memory size.\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Required  = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long)\n                          elementSize, tmpDbl);\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* Allocate memory for the log variable */\n    if ( (var = calloc(1, sizeof(LogVar))) == NULL ) {\n        (void)fprintf(stderr, \"*** Error allocating memory for logging %s\\n\",\n                      varName);\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer (real part) */\n    if ( (var->data.re = malloc(nRows*nColumns*elementSize)) == NULL ) {\n        (void)fprintf(stderr,\n                      \"*** Error allocating memory for the circular buffer\\n\");\n        (void)fprintf(stderr, \"*** Details:\\n\"\n                      \"       varName         = %s\\n\"\n                      \"       nRows           = %d\\n\"\n                      \"       nCols           = %d\\n\"\n                      \"       elementSize     = %lu\\n\"\n                      \"       Bytes Requested = %.16g\\n\\n\",\n                      varName, nRows, nColumns, (unsigned long) elementSize,\n                      ((double)elementSize)*((double)nRows)*((double)nColumns));\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer for the imaginary part */\n    if (complex) {\n        if ( (var->data.im = malloc(nRows*nColumns*elementSize)) == NULL ) {\n            (void)fprintf(stderr,\n                          \"*** Error allocating memory for the circular buffer \"\n                          \"for logging the imaginary part of %s\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Requested = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long) elementSize,\n                          ((double)elementSize)*((double)nRows)*\n                                                 ((double)nColumns));\n            goto ERROR_EXIT;\n        }\n    }\n    /*\n     * Initialize the fields in LogVar structure.\n     */\n    if (appendToLogVarsList) {\n        rt_LoadModifiedLogVarName(li,varName,var->data.name);\n    } else {\n        var->data.name[mxMAXNAM-1] = '\\0';\n        (void)strncpy(var->data.name,varName,mxMAXNAM-1);\n    }\n    var->data.nCols           = nColumns;\n    var->data.nRows           = nRows;\n\n    var->data.nDims           = frameData ? 1 : nDims;\n    if (var->data.nDims > 2) {\n        var->data.dims = (int_T*)malloc(sizeof(int_T)*var->data.nDims);\n    } else {\n        var->data.dims = var->data._dims;\n    }\n    if (frameData) {\n        var->data.dims[0] = nColumns;\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        (void)memcpy(var->data.dims, dims, (size_t)(nDims*sizeof(int_T)));\n    }\n\n    var->data.dTypeID         = dTypeID;\n    var->data.elSize          = elementSize;\n\n    var->data.dataTypeConvertInfo = rt_GetDataTypeConvertInfo(\n        pDataTypeConvertInfo, dTypeID);\n\n    var->data.mxID            = rt_GetMxIdFromDTypeId(dTypeID);\n    /* over-ride logical bit if data type is boolean */\n    logical = dTypeID == SS_BOOLEAN ? 1 : 0;\n    var->data.logical         = (logical)   ? matLOGICAL_BIT : 0x0;\n    var->data.complex         = (complex)   ? matCOMPLEX_BIT : 0x0;\n    var->data.frameData       = frameData;\n    var->data.frameSize       = (frameData) ? frameSize : 1;\n\n    /* fill up valDims field */\n    if(logValDimsStat == NO_LOGVALDIMS){\n        /* All signals are fixed-size, no need to log valueDimensions field */\n        var->valDims     = NULL;\n        /* Set these pointers to NULLs in this case */\n        var->coords      = NULL;\n        var->strides     = NULL;\n        var->currStrides = NULL;\n    }\n    else{\n        if ( (var->valDims = calloc(1, sizeof(ValDimsData))) == NULL ) {\n            goto ERROR_EXIT;\n        }\n\n        (void)memcpy(var->valDims->name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n\n        if (logValDimsStat == LOGVALDIMS_EMPTYMX) {\n            /* At least one signal is variable-size, \n               but the current signal is fixed-size. \n               Therefore, create a dummy MatrixData to write out valueDimensions \n               as an empty matrix. \n            */\n            var->valDims->nRows = 0;\n            var->valDims->nCols = 0;\n            var->valDims->currSigDims = NULL;\n            var->valDims->currSigDimsSize = NULL;\n            var->valDims->dimsData = NULL;\n            /* Set these pointers to NULLs in this case */\n            var->coords      = NULL;\n            var->strides     = NULL;\n            var->currStrides = NULL;\n        } else { /* The current signal is a variable-size signal. */\n            /* The \"valueDimensions\" must be double, so re-assign element size */\n            elementSize = sizeof(real_T);\n\n            /* When signals are frame-based, 'valueDimensions' has 1 column */\n            if(frameData){\n                /* When signal is frame-based, the first dimension is always fixed, \n                   so we only need to record the second dimension.\n                   e.g. Two frame-based signals [10x4] and [10x3], \n                   'valueDimensions' and 'currSigDims'\n                   only record 4 or 3.\n                */\n                nColumns = 1;\n                var->valDims->currSigDims = (void**) (currSigDims + 1);\n                var->valDims->currSigDimsSize = (int_T*) (currSigDimsSize + 1);\n            } else { /* non-frame based */\n                nColumns = nDims;\n                var->valDims->currSigDims = (void**) currSigDims;\n                var->valDims->currSigDimsSize = (int_T*) currSigDimsSize;\n            }\n            \n            /* Allocate memory for the circular buffer */\n            if ( (var->valDims->dimsData = malloc(nRows*nColumns*elementSize)) == NULL ) {\n                (void)fprintf(stderr,\n                              \"*** Error allocating memory for the circular buffer\\n\");\n                (void)fprintf(stderr, \"*** Details:\\n\"\n                              \"       varName         = %s\\n\"\n                              \"       nRows           = %d\\n\"\n                              \"       nCols           = %d\\n\"\n                              \"       elementSize     = %lu\\n\"\n                              \"       Bytes Requested = %.16g\\n\\n\",\n                              var->valDims->name, nRows, nColumns, (unsigned long) elementSize,\n                              ((double)elementSize)*((double)nRows)*((double)nColumns));\n                goto ERROR_EXIT;\n            }\n            var->valDims->nRows = nRows;\n            var->valDims->nCols = nColumns;\n\n            /* Allocate memory for these dynamic arrays */\n            {\n                size_t nbytes = var->data.nDims*sizeof(int_T);\n                if( ((var->coords = calloc(nbytes, 1)) == NULL)\n                    ||((var->strides = calloc(nbytes, 1)) == NULL)\n                    ||((var->currStrides = calloc(nbytes, 1)) == NULL) )\n                    goto ERROR_EXIT;\n            }\n        }\n    }\n\n    var->rowIdx               = 0;\n    var->wrapped              = 0;\n    var->nDataPoints          = 0;\n    var->usingDefaultBufSize  = usingDefaultBufSize;\n    var->okayToRealloc        = okayToRealloc;\n    var->decimation           = decimation;\n    var->numHits              = -1;  /* so first point gets logged */\n\n    /* Add this log var to list in log info, if necessary */\n    if (appendToLogVarsList) {\n        LogInfo *logInfo = (LogInfo*) rtliGetLogInfo(li);\n        LogVar  *varList = logInfo->logVarsList;\n\n        if (varList != NULL) {\n            while (varList->next != NULL) {\n                varList = varList->next;\n            }\n            varList->next = var;\n        } else {\n            logInfo->logVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    \n    *errStatus = rtMemAllocError;\n    rt_DestroyLogVar(var);\n    return(NULL);\n\n} /* end rt_CreateLogVarWithConvert */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateLogVar ===================================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVar(RTWLogInfo        *li,\n                               const real_T      startTime,\n                               const real_T      finalTime,\n                               const real_T      inStepSize,\n                               const char_T      **errStatus,\n                               const char_T      *varName,\n                               BuiltInDTypeId    inpDataTypeID,\n                               int_T             logical,\n                               int_T             complex,\n                               int_T             frameData,\n                               int_T             nCols,\n                               int_T             nDims,\n                               const int_T       *dims,\n                               LogValDimsStat    logValDimsStat,\n                               void              **currSigDims,\n                               int_T             *currSigDimsSize,\n                               int_T             maxRows,\n                               int_T             decimation,\n                               real_T            sampleTime,\n                               int_T             appendToLogVarsList)\n{\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo = NULL;\n\n    return rt_CreateLogVarWithConvert(li,\n                                      startTime,\n                                      finalTime,\n                                      inStepSize,\n                                      errStatus,\n                                      varName,\n                                      inpDataTypeID,\n                                      pDataTypeConvertInfo,\n                                      logical,\n                                      complex,\n                                      frameData,\n                                      nCols,\n                                      nDims,\n                                      dims,\n                                      logValDimsStat,\n                                      currSigDims,\n                                      currSigDimsSize,\n                                      maxRows,\n                                      decimation,\n                                      sampleTime,\n                                      appendToLogVarsList);\n\n} /* end rt_CreateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateStructLogVar =============================================\n * Abstract:\n *\tCreate a logging variable in the structure format.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nStructLogVar *rt_CreateStructLogVar(RTWLogInfo              *li,\n                                           const real_T            startTime,\n                                           const real_T            finalTime,\n                                           const real_T            inStepSize,\n                                           const char_T            **errStatus,\n                                           const char_T            *varName,\n                                           boolean_T               logTime,\n                                           int_T                   maxRows,\n                                           int_T                   decimation,\n                                           real_T                  sampleTime,\n                                           const RTWLogSignalInfo  *sigInfo,\n                                           const char_T            *blockName)\n{\n\n    return( local_CreateStructLogVar(li,\n                                     startTime,\n                                     finalTime,\n                                     inStepSize,\n                                     errStatus,\n                                     varName,\n                                     logTime,\n                                     maxRows,\n                                     decimation,\n                                     sampleTime,\n                                     sigInfo,\n                                     blockName));\n\n} /* end rt_CreateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_StartDataLoggingWithStartTime ==================================\n * Abstract:\n *      Initialize data logging info based upon the following settings cached\n *      in the RTWLogging data structure of the SimStruct.\n *\n * Return value is:\n *\t== NULL  => success\n *\t!= NULL  => failure (the return value is a pointer that points to the\n *                           error message, which is also set in the simstruct)\n */\nconst char_T *rt_StartDataLoggingWithStartTime(RTWLogInfo   *li,\n                                                      const real_T startTime,\n                                                      const real_T finalTime,\n                                                      const real_T stepSize,\n                                                      const char_T **errStatus)\n{\n    const char_T   *varName;\n    LogInfo        *logInfo;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ((logInfo=calloc(1,sizeof(LogInfo))) == NULL) {\n        *errStatus = rtMemAllocError;\n        goto ERROR_EXIT;\n    }\n    rtliSetLogInfo(li, (void*)logInfo);\n\n    /* time */\n    varName = rtliGetLogT(li);\n    if (varName[0] != '\\0') {\n        int_T dims = 1;\n        logInfo->t = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                stepSize, errStatus,\n                                                varName,SS_DOUBLE,\n                                                NULL,\n                                                0,0,0,1,1,\n                                                &dims, NO_LOGVALDIMS, NULL, NULL,\n                                                maxRows,decimation,\n                                                sampleTime,1);\n        if (logInfo->t == NULL) goto ERROR_EXIT;\n    }\n\n    /* states */\n    if ( rtliGetLogX(li)[0] != '\\0' ||  rtliGetLogXFinal(li)[0] != '\\0' ) {\n        const RTWLogSignalInfo  *xInfo = rtliGetLogXSignalInfo(li);\n\n        if (logFormat == 0) {                                /* Matrix Format */\n            int            numCols;\n            int            nDims;\n            const int      *dims;\n            BuiltInDTypeId dataType;\n            int            isComplex;\n            int_T          sIdx;\n\n            const RTWLogDataTypeConvert *pDTConvInfo;\n\n            numCols = xInfo[0].numCols ? xInfo[0].numCols[0] : 0;\n            for (sIdx = 1; sIdx < xInfo[0].numSignals; sIdx++) {\n                numCols += xInfo[0].numCols[sIdx];\n            }\n            /* If we have only one \"matrix\" state, we can log as a matrix */\n            if (xInfo[0].numSignals == 1) {\n                nDims     = xInfo[0].numDims ? xInfo[0].numDims[0] : 1;\n                dims      = xInfo[0].dims;\n            } else {\n                nDims     = 1;\n                dims      = &numCols;\n            }\n            dataType  = xInfo[0].dataTypes ? xInfo[0].dataTypes[0] : 0;\n            isComplex = xInfo[0].complexSignals ? xInfo[0].complexSignals[0] : 0;\n\n            pDTConvInfo = xInfo[0].dataTypeConvert;\n\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                        stepSize, errStatus,\n                                                        rtliGetLogX(li),dataType,\n                                                        pDTConvInfo,\n                                                        0,\n                                                        isComplex,0,numCols,nDims,dims,\n                                                        NO_LOGVALDIMS, NULL, NULL,\n                                                        maxRows,decimation,sampleTime,1);\n                if (logInfo->x == NULL)  goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                             stepSize, errStatus,\n                                                             rtliGetLogXFinal(li),dataType,\n                                                             pDTConvInfo,\n                                                             0,isComplex,0,numCols,nDims,\n                                                             dims, NO_LOGVALDIMS, NULL, \n                                                             NULL, 1,decimation,\n                                                             sampleTime,1);\n                if (logInfo->xFinal == NULL)  goto ERROR_EXIT;\n            }\n        } else {                                          /* Structure Format */\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = local_CreateStructLogVar(li, startTime, finalTime,\n                                                      stepSize, errStatus,\n                                                      rtliGetLogX(li), logTime,\n                                                      maxRows, decimation,\n                                                      sampleTime, xInfo, NULL);\n                if (logInfo->x == NULL) goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = local_CreateStructLogVar(li, startTime, finalTime,\n                                                           stepSize, errStatus,\n                                                           rtliGetLogXFinal(li),\n                                                           logTime,1,decimation,\n                                                           sampleTime,xInfo,NULL);\n                if (logInfo->xFinal == NULL) goto ERROR_EXIT;\n            }\n        }\n    }\n\n    /* outputs */\n    *errStatus = rt_StartDataLoggingForOutput(li,startTime,finalTime,\n                                              stepSize,errStatus);\n    if (*errStatus != NULL)  goto ERROR_EXIT;\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) {\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo);\n        rtliSetLogInfo(li,NULL);\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingWithStartTime */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StartDataLogging ===============================================\n * Abstract:\n */\nconst char_T *rt_StartDataLogging(RTWLogInfo   *li,\n                                         const real_T finalTime,\n                                         const real_T stepSize,\n                                         const char_T **errStatus)\n{\n    return rt_StartDataLoggingWithStartTime(li,\n                                            0.0,\n                                            finalTime,\n                                            stepSize,\n                                            errStatus);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_UpdateLogVar ===================================================\n * Abstract:\n *\tCalled to log data for a log variable.\n */\nvoid rt_UpdateLogVar(LogVar *var, const void *data, boolean_T isVarDims)\n{\n    size_t        elSize    = var->data.elSize;\n    const  char_T *cData    = data;\n    const  int_T  frameData = var->data.frameData;\n    const  int_T  frameSize = frameData ? (var->data.frameSize) : 1;\n    const  int_T  logWidth  = var->data.nCols;\n    BuiltInDTypeId dTypeID  = var->data.dTypeID;\n\n    size_t offset        = 0;\n    char_T *currRealRow  = NULL;\n    char_T *currImagRow  = NULL;\n    int_T  pointSize     = (int_T)((var->data.complex) ? rt_GetSizeofComplexType(dTypeID) : elSize);\n\n    int    i, j, k;\n\n    /* The following variables will be used for \n       logging variable-size signals */\n    const  int_T  nDims = var->data.nDims;\n    const  int_T  *dims = var->data.dims;\n    const  void   * const *currDimsPtr = NULL;\n    const  int_T  *currDimsSizePtr = NULL;\n\n    /* The following variables will be used for \n       logging \"valueDimensions\" field */\n    size_t offset_valDims   = 0;\n    char_T *currValDimsRow  = NULL;\n    size_t elSize_valDims   = sizeof(real_T);\n    real_T currentSigDims   = 0;\n    int_T  nRows_valDims    = 0;\n    int_T  logWidth_valDims = 0;\n\n    for (i = 0; i < frameSize; i++) {\n        if (++var->numHits % var->decimation) continue;\n        var->numHits = 0;\n\n        if (var->rowIdx == var->data.nRows) {\n            if (var->okayToRealloc == 1) {\n                rt_ReallocLogVar(var, isVarDims);\n            } else {\n                /* Circular buffer */\n                var->rowIdx = 0;\n                ++(var->wrapped); /* increment the wrap around counter */\n            }\n        }\n\n        if(isVarDims){\n            currDimsPtr = (const void * const *) var->valDims->currSigDims;\n            currDimsSizePtr = (const int_T*) var->valDims->currSigDimsSize;\n            logWidth_valDims = frameData ? 1 : var->valDims->nCols;\n            nRows_valDims = var->valDims->nRows;\n\n            var->strides[0] = 1;\n            var->currStrides[0] = 1;\n\n            for (k = 1; k < nDims; k++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[k-1]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                }\n                var->strides[k] = var->strides[k-1] * dims[k-1];\n                var->currStrides[k] = var->currStrides[k-1] * currDimsVal;\n            }\n        }\n\n        offset       = (size_t)(elSize * var->rowIdx * logWidth);\n        currRealRow  = ((char_T*) (var->data.re)) + offset;\n        currImagRow  = (var->data.complex) ?\n                       ((char_T*) (var->data.im)) + offset :  NULL;\n\n        /* update logging data */\n        for (j = 0; j < logWidth; j++) {\n\n            boolean_T inRange = true;\n            int idx = j;\n\n            /* Check whether the currently logged value is in range or not.\n               For fixed-size signal logging, always inRange = true; idx = j;\n               For variable-size signal logging, use strides, coordinates\n               and current strides to decide whether the currently logged\n               data is in range or not and its location in the logging \n               matrix.\n             */\n            if(isVarDims){\n                int rem = j;\n                idx = 0;\n                for(k = nDims-1; k>=0; k--){\n                    int32_T currDimsVal=0;\n                    switch (currDimsSizePtr[k]) {\n                      case 1:\n                        currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+k));\n                        break;\n                      case 2:\n                        currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+k));\n                        break;\n                      case 4:\n                        currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+k));\n                        break;\n                    }\n                    var->coords[k] = rem / var->strides[k];\n                    if( var->coords[k] >= currDimsVal ){\n                        inRange = false;\n                        break;\n                    }\n                    rem = rem - var->coords[k] * var->strides[k];\n                }\n                if(inRange){\n                    idx = var->coords[0];\n                    for (k = 1; k < nDims; k++){\n                        idx += var->coords[k] * var->currStrides[k];\n                    }\n                }\n            }\n            \n            if (!var->data.dataTypeConvertInfo.conversionNeeded) {\n                /* NO  conversion needed\n                 */ \n                if (inRange) {\n                    /* If in range, fill in data */\n                    const char *cDataPoint = cData + (i+frameSize*idx) * pointSize;\n\n                    (void) memcpy(currRealRow, cDataPoint, elSize);\n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        (void) memcpy(currImagRow, cDataPoint + pointSize/2, elSize);\n                        currImagRow += elSize;\n                    }\n                } else {\n                    /* If out of range, fill in NaN or 0:\n                       1) For bool, int32, uint32, int16, uint16, etc,\n                          memset to zeros;\n                       2) For fixed-point data type, NaN conversion is not\n                          allowed, memset to zeros.\n                    */\n                    if (dTypeID == SS_DOUBLE) {\n                       ((real_T*)(currRealRow))[0] = rtNaN;\n                    } else if (dTypeID == SS_SINGLE){\n                        ((real32_T*)(currRealRow))[0] = rtNaNF;\n                    } else {\n                        (void) memset(currRealRow, 0, elSize);\n                    }\n                    \n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        /* For imaginary part, fill in 0 */\n                        (void) memset(currImagRow, 0, elSize);\n                        currImagRow += elSize;\n                    }\n                }\n            }\n            else\n            {\n                /* YES conversion needed\n                 */ \n                DTypeId dataTypeIdOriginal = \n                    var->data.dataTypeConvertInfo.dataTypeIdOriginal;\n                int_T DpSize = (int_T)((var->data.complex) ? \n                                       rt_GetSizeofComplexType(dataTypeIdOriginal) : \n                                       rt_GetSizeofDataType(dataTypeIdOriginal));\n\n                DTypeId dataTypeIdLoggingTo = \n                    var->data.dataTypeConvertInfo.dataTypeIdLoggingTo;\n\n                int bitsPerChunk = var->data.dataTypeConvertInfo.bitsPerChunk;\n                int numOfChunk =  var->data.dataTypeConvertInfo.numOfChunk;\n                unsigned int isSigned = var->data.dataTypeConvertInfo.isSigned;\n\n                double fracSlope = var->data.dataTypeConvertInfo.fracSlope;\n                int    fixedExp  = var->data.dataTypeConvertInfo.fixedExp;\n                double bias      = var->data.dataTypeConvertInfo.bias;\n\n                double curRealValue = -0.12345678987654;\n                double curImagValue = -0.12345678987654;\n\n                int_T adjIndexIfComplex = (var->data.complex) ? 2 : 1;\n\n                if(inRange){\n                    if(numOfChunk > 1)\n                    {\n                        /* For multiword */\n                        const char *pInData = (const char *)(cData);\n                        int dtSize = bitsPerChunk*numOfChunk/8;\n                        pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                        \n                        curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                       isSigned, fracSlope, fixedExp, bias);\n                        if (var->data.complex) {\n                            curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                           isSigned, fracSlope, fixedExp, bias);\n                        }\n                    }\n                    else\n                    {\n                        /* if in range, fill in data that is converted first */\n                        switch ( dataTypeIdOriginal )\n                        {\n                          case SS_DOUBLE:\n                            {\n                                const real_T *pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_SINGLE:\n                            {\n                                const real32_T *pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT8:\n                            {\n                                const int8_T *pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT8:\n                            {\n                                const uint8_T *pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT16:\n                            {\n                                const int16_T *pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT16:\n                            {\n                                const uint16_T *pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT32:\n                            {\n                                const int32_T *pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT32:\n                            {\n                                const uint32_T *pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_BOOLEAN:\n                            {\n                                const boolean_T *pInData = ((const boolean_T *)(cData));\n                                \n                                pInData += (i+frameSize*idx) * adjIndexIfComplex;\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          default: \n                            {\n                                /* For biglong */\n                                const char *pInData = (const char *)(cData);\n                                int dtSize = bitsPerChunk*numOfChunk/8;\n                                pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                                \n                                curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                               isSigned, fracSlope, fixedExp, bias);\n                                if (var->data.complex) {\n                                    curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                                   isSigned, fracSlope, fixedExp, bias);\n                                }\n                            }\n                            break;\n                        } /* -- end of switch -- */\n                    }\n                } else {\n                    /* if out of range, just fill NaN or 0 */\n                    if(dTypeID == SS_DOUBLE || dTypeID == SS_SINGLE){\n                        /* vijay 4/11/2013: DO NOT CALL ldexp() with NaN below as it causes \n                         * lcc-win64 to generate inf instead of NaN as output. \n                         * Just use rtNaN directly */\n                        curRealValue = rtNaN;\n                    }\n                    else{\n                        curRealValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                    if (var->data.complex) {\n                        /* fill 0 in imaginary part*/\n                        curImagValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                }\n\n                switch ( dataTypeIdLoggingTo )\n                {\n                  case SS_DOUBLE:\n                    {\n                        *((real_T *)currRealRow) = (real_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real_T *)currImagRow) = (real_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_SINGLE:\n                    {\n                        *((real32_T *)currRealRow) = (real32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real32_T *)currImagRow) = (real32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT8:\n                    {\n                        *((int8_T *)currRealRow) = (int8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int8_T *)currImagRow) = (int8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT8:\n                    {\n                        *((uint8_T *)currRealRow) = (uint8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint8_T *)currImagRow) = (uint8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT16:\n                    {\n                        *((int16_T *)currRealRow) = (int16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int16_T *)currImagRow) = (int16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT16:\n                    {\n                        *((uint16_T *)currRealRow) = (uint16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint16_T *)currImagRow) = (uint16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT32:\n                    {\n                        *((int32_T *)currRealRow) = (int32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int32_T *)currImagRow) = (int32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT32:\n                    {\n                        *((uint32_T *)currRealRow) = (uint32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint32_T *)currImagRow) = (uint32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_BOOLEAN:\n                    {\n                        *((boolean_T *)currRealRow) = (boolean_T)(curRealValue != 0.0);\n\n                        if (var->data.complex) {\n\n                            *((boolean_T *)currImagRow) = (boolean_T)(curImagValue != 0.0);\n                        }\n                    }\n                    break;\n                } /* -- end of switch -- */\n\n                currRealRow += elSize;\n                if (var->data.complex) {\n                    currImagRow += elSize;\n                }\n            }\n        }\n\n        if(isVarDims){ /* update \"valueDimensions\" field */\n            for(j = 0; j < logWidth_valDims; j ++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[j]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+j));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+j));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+j));\n                    break;\n                }\n                offset_valDims  = (size_t)(elSize_valDims *( var->rowIdx + nRows_valDims * j));\n                currValDimsRow  = ((char_T*) (var->valDims->dimsData)) + offset_valDims;\n\n                /* convert int_T to real_T */\n                currentSigDims = (real_T) currDimsVal;\n                (void) memcpy(currValDimsRow, &currentSigDims, elSize_valDims);\n                currValDimsRow += elSize_valDims;\n            }\n        }\n        \n        ++var->rowIdx;\n    }\n\n    return;\n\n} /* end rt_UpdateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n \n \n/* Function: rt_UpdateStructLogVar =============================================\n * Abstract:\n *      Called to log data for a structure log variable.\n */\nvoid rt_UpdateStructLogVar(StructLogVar *var, const real_T *t, const void *data)\n{\n    LogVar       *values = var->signals.values;\n    const char_T *signal = data;\n    boolean_T *isVarDims = var->signals.isVarDims;\n    int i = 0;\n\n    /* time */\n    if (var->logTime) {\n        rt_UpdateLogVar(var->time, t, false);\n    }\n\n    /* signals */\n    while (values) {\n        size_t elSz = values->data.elSize;\n\n        rt_UpdateLogVar(values, signal, isVarDims[i]);\n\n        if (values->data.complex) elSz *= 2;\n        signal += elSz * values->data.nCols;\n\n        values = values->next;\n        i++;\n    }\n\n} /* end rt_UpdateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * g1614989:Refactoring this function to accept number of elements\n *          instead of accepting signalInfo and index.\n */\nvoid* rt_getTempMemory(LogVar* var, int_T numEls);\n\nvoid* rt_getTempMemory(LogVar* var, int_T numEls)\n{\n    size_t elSize  = var->data.elSize;\n    size_t cmplxMult = var->data.complex ? 2 : 1;\n    /*\n     * g1689750: With multiword support for mat file logging in row major array layout, we need to allocate more space to\n     * store the data when the transpose operation is being performed. The additional space is required to store multiple\n     * chunks that each multi word contains.\n     */\n    size_t numOfChunks = var->data.dataTypeConvertInfo.conversionNeeded ? var->data.dataTypeConvertInfo.numOfChunk : 1;\n    void* tempMemory = malloc(elSize * numEls * cmplxMult * numOfChunks);\n    return tempMemory;\n}\n\n/*\n* g1614989:This function processes the signal data if a function pointer is available and then logs the data.\n*          If a function pointer is not present, signal data is logged without any processing.\n*          The idx parameter specifies which information from the SignalInfo to be used for processing and logging.\n*          When idx is -1, the provided signal info is to be used for processing and logging the data.\n*/\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    RTWPreprocessingFcnPtr preprocessingPtr = NULL;\n    int_T numEls = -1;\n    if (idx == -1) {\n        preprocessingPtr = *(signalInfo->preprocessingPtrs);\n        numEls = *(signalInfo->numCols);\n    }\n    else {\n        preprocessingPtr = signalInfo->preprocessingPtrs[idx];\n        numEls = signalInfo->numCols[idx];\n    }\n\n    if (preprocessingPtr != NULL) {\n        void* curData = rt_getTempMemory(val, numEls);\n        preprocessingPtr(curData, data);\n        rt_UpdateLogVar(val, curData, isVarDims);\n        free(curData);\n    }\n    else {\n        rt_UpdateLogVar(val, data, isVarDims);\n    }\n}\n\n/*\n* g1614989:This function is called when each signal has a specific RTWLogSignalInfo structure defined.\n*/\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    rt_preProcessAndLogDataWithIndex(&signalInfo, -1, val, data, isVarDims);\n}\n \n/* Function: rt_UpdateTXYLogVars ===============================================\n * Abstract:\n *\tUpdate the xFinal,T,X,Y variables that are being logged.\n */\nconst char_T *rt_UpdateTXYLogVars(RTWLogInfo *li, time_T *tPtr)\n{\n    return rt_UpdateTXXFYLogVars(li, tPtr, true);\n}\n \n/* Function: rt_UpdateTXXFYLogVars =============================================\n * Abstract:\n *\tUpdate xFinal and/or the T,X,Y variables that are being logged\n */\nconst char_T *rt_UpdateTXXFYLogVars(RTWLogInfo *li, time_T *tPtr, boolean_T updateTXY)\n{\n    LogInfo *logInfo     = rtliGetLogInfo(li);\n    int_T   matrixFormat = (rtliGetLogFormat(li) == 0);\n    const RTWLogSignalInfo* yInfo = rtliGetLogYSignalInfo(li);\n    const RTWLogSignalInfo* xInfo = rtliGetLogXSignalInfo(li);\n\n    /* time */\n    if (logInfo->t != NULL && updateTXY) {\n        rt_UpdateLogVar(logInfo->t, tPtr, false);\n    }\n\n    if (matrixFormat) {                                      /* MATRIX_FORMAT */\n        /* states */\n        if (logInfo->x != NULL || logInfo->xFinal != NULL) {\n            int8_T**               segAddr     = _rtliGetLogXSignalPtrs(li);\n            const int_T            *segLengths = xInfo->numCols;\n            int_T                  nSegments   = xInfo->numSignals;\n            RTWPreprocessingFcnPtr* preprocessingPtrs = xInfo->preprocessingPtrs;\n\n            if (logInfo->x != NULL && updateTXY) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->x, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n            if (logInfo->xFinal != NULL) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->xFinal, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n        }\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            LogVar **var = (LogVar**) (logInfo->y);\n            int_T  ny    = logInfo->ny;\n            int_T  i;\n            int    yIdx;\n            LogSignalPtrsType data = rtliGetLogYSignalPtrs(li);\n\n            for (i = 0, yIdx = 0; i < ny; i++) {\n                if (data[i] != NULL) {\n                    /* \n                       When outputs are logged in Matrix format, \n                       no variable-size signal logging is allowed.\n                    */\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *          Function pointer is now identified by using \n                     *          Y Signal Info instead of iterating over pre-processing \n                     *          function pointers.\n                    */ \n                    rt_preProcessAndLogData(yInfo[yIdx], var[yIdx], data[i], false);\n                    yIdx++;\n                }\n            }\n        }\n    } else {                                              /* STRUCTURE_FORMAT */\n        /* states */\n        if (logInfo->x != NULL && updateTXY) {\n            int_T             i;\n            StructLogVar      *var = logInfo->x;\n            LogVar            *val = var->signals.values;\n            int_T             nsig = var->signals.numSignals;\n            LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n\n            /* time */\n            if (var->logTime) {\n                rt_UpdateLogVar(var->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            int_T             ny      = logInfo->ny;\n            LogSignalPtrsType data    = rtliGetLogYSignalPtrs(li);\n            StructLogVar      **var   = (StructLogVar**) (logInfo->y);\n\n            if (ny == 1) {\n                int_T  i;\n                int_T  dataIdx;\n                LogVar *val = var[0]->signals.values;\n                int_T  nsig = var[0]->signals.numSignals;\n                boolean_T   *isVarDims = var[0]->signals.isVarDims;\n\n                /* time */\n                if (var[0]->logTime) {\n                    rt_UpdateLogVar(var[0]->time, tPtr, false);\n                }\n\n                /* signals */\n                for (i = 0, dataIdx = 0; i < nsig; i++) {                    \n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogDataWithIndex(yInfo, i, val, data[dataIdx], isVarDims[i]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            } else {\n                int_T  i;\n                int_T  dataIdx;\n\n                for (i = 0, dataIdx = 0; i < ny && var[i] != NULL; i++) {\n                    LogVar *val = var[i]->signals.values;\n                    boolean_T   *isVarDims = var[i]->signals.isVarDims;\n\n                    /* time */\n                    if (var[i]->logTime) {\n                        rt_UpdateLogVar(var[i]->time, tPtr, false);\n                    }\n\n                    /* signals */\n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogData(yInfo[i], val, data[dataIdx], isVarDims[0]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            }\n        }\n        /* final state */\n        if (logInfo->xFinal != NULL) {\n            StructLogVar *xf  = logInfo->xFinal;\n            LogVar       *val = xf->signals.values;\n            int_T        nsig = xf->signals.numSignals;\n            int_T        i;\n\n            /* time */\n            if (xf->logTime) {\n                rt_UpdateLogVar(xf->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n    }\n    return(NULL);\n} /* end rt_UpdateTXXFYLogVars */\n\n\n#ifdef __cplusplus\n}\n#endif\n          \n\n          \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLoggingImpl =======================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLoggingImpl(const char_T *file, RTWLogInfo *li, boolean_T isRaccel)\n{\n    FILE          *fptr;\n    LogInfo       *logInfo     = (LogInfo*) rtliGetLogInfo(li);\n    LogVar        *var         = logInfo->logVarsList;\n    StructLogVar  *svar        = logInfo->structLogVarsList;\n    /* At this time, verbose is only needed if running rapid accelerator\n     * simulations. */\n    int           verbose      = isRaccel ? 0: 1;\n\n    boolean_T     emptyFile    = 1; /* assume */\n    boolean_T     errFlag      = 0;\n    const char_T  *msg;\n\n    /*******************************\n     * Create MAT file with header *\n     *******************************/\n    if ((fptr=fopen(file,\"w+b\")) == NULL) {\n        (void)fprintf(stderr,\"*** Error opening %s\",file);\n        goto EXIT_POINT;\n    }\n    if (rt_WriteMat5FileHeader(fptr)) {\n        (void)fprintf(stderr,\"*** Error writing to %s\",file);\n        goto EXIT_POINT;\n    }\n\n    /**************************************************\n     * First log all the variables in the LogVar list *\n     **************************************************/\n    while (var != NULL) {\n        if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n            (void)fprintf(stderr,\"*** Error writing %s due to: %s\\n\",file,msg);\n            errFlag = 1;\n            break;\n        }\n        if (var->nDataPoints > 0 || isRaccel) {\n            MatItem item;\n\n            item.type   = matMATRIX;\n            item.nbytes = 0; /* not yet known */\n            item.data   = &(var->data);\n            if (rt_WriteItemToMatFile(fptr, &item, MATRIX_ITEM)) {\n                (void)fprintf(stderr,\"*** Error writing log variable %s to \"\n                              \"file %s\",var->data.name, file);\n                errFlag = 1;\n                break;\n            }\n            emptyFile = 0;\n        }\n        var = var->next;\n    }\n    /* free up some memory by destroying the log var list here */\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n\n    /*******************************************************\n     * Next log all the variables in the StructLogVar list *\n     *******************************************************/\n    while (svar != NULL) {\n        MatItem item;\n\n        if (svar->logTime) {\n            var = svar->time;\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n        }\n\n        var = svar->signals.values;\n        while (var) {\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n            var = var->next;\n        }\n\n        item.type   = matMATRIX;\n        item.nbytes = 0; /* not yet known */\n        item.data   = svar;\n\n        if (rt_WriteItemToMatFile(fptr, &item, STRUCT_LOG_VAR_ITEM)) {\n            (void)fprintf(stderr,\"*** Error writing structure log variable \"\n                          \"%s to file %s\",svar->name, file);\n            errFlag = 1;\n            break;\n        }\n        emptyFile = 0;\n\n        svar = svar->next;\n    }\n\n    /******************\n     * Close the file *\n     ******************/\n    (void)fclose(fptr);\n    if (emptyFile || errFlag) {\n        (void)remove(file);\n    } else {\n        if( verbose ) {\n            (void)printf(\"** created %s **\\n\\n\", file);\n        }\n    }\n\n EXIT_POINT:\n\n    /****************\n     * free logInfo *\n     ****************/\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n    rt_DestroyStructLogVar(logInfo->structLogVarsList);\n    logInfo->structLogVarsList = NULL;\n    FREE(logInfo->y);\n    logInfo->y = NULL;\n    FREE(logInfo);\n    rtliSetLogInfo(li,NULL);\n\n} /* end rt_StopDataLoggingImpl */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLogging ================================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLogging(const char_T *file, RTWLogInfo *li)\n{\n    rt_StopDataLoggingImpl(file,li,false);\n\n} /* end rt_StopDataLogging */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#else /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#define rt_StartDataLogging(li, finalTime, stepSize, errStatus) NULL /* do nothing */\n#define rt_UpdateTXYLogVars(li, tPtr) NULL /* do nothing */\n#define rt_StopDataLogging(file, li) { (void(file)); } /* use file quiet unused macro warning */ /* do nothing */\n\n#endif /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n\n\n/* [eof] rt_logging.c */\n\n/* LocalWords:  Tfinal MAXNAM nonfinite DType PWS RSim Fixup logvar DDEFAULT th\n * LocalWords:  curr Realloc realloc inp biglong vijay ldexp TXY eof XFinal th\n * LocalWords:  TXXFY NULL typedefs ret polyspace NUL\n */\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};